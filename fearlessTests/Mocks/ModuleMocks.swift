import Cuckoo
@testable import fearless

import Foundation






public class MockLocalizable: Localizable, Cuckoo.ProtocolMock {
    
    public typealias MocksType = Localizable
    
    public typealias Stubbing = __StubbingProxy_Localizable
    public typealias Verification = __VerificationProxy_Localizable

    public let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: Localizable?

    public func enableDefaultImplementation(_ stub: Localizable) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

    public struct __StubbingProxy_Localizable: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
        public init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockLocalizable, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockLocalizable.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

    public struct __VerificationProxy_Localizable: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
        public init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


public class LocalizableStub: Localizable {
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockAccountSelectionPresentable: AccountSelectionPresentable, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountSelectionPresentable
    
     typealias Stubbing = __StubbingProxy_AccountSelectionPresentable
     typealias Verification = __VerificationProxy_AccountSelectionPresentable

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountSelectionPresentable?

     func enableDefaultImplementation(_ stub: AccountSelectionPresentable) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func presentAccountSelection(_ accounts: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from view: ControllerBackedProtocol?, context: AnyObject?)  {
        
    return cuckoo_manager.call(
    """
    presentAccountSelection(_: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from: ControllerBackedProtocol?, context: AnyObject?)
    """,
            parameters: (accounts, selectedAccountItem, title, delegate, view, context),
            escapingParameters: (accounts, selectedAccountItem, title, delegate, view, context),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentAccountSelection(accounts, selectedAccountItem: selectedAccountItem, title: title, delegate: delegate, from: view, context: context))
        
    }
    
    

     struct __StubbingProxy_AccountSelectionPresentable: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func presentAccountSelection<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable, M6: Cuckoo.OptionalMatchable>(_ accounts: M1, selectedAccountItem: M2, title: M3, delegate: M4, from view: M5, context: M6) -> Cuckoo.ProtocolStubNoReturnFunction<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?)> where M1.MatchedType == [ChainAccountResponse], M2.OptionalMatchedType == ChainAccountResponse, M3.MatchedType == LocalizableResource<String>, M4.MatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == ControllerBackedProtocol, M6.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?)>] = [wrap(matchable: accounts) { $0.0 }, wrap(matchable: selectedAccountItem) { $0.1 }, wrap(matchable: title) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: view) { $0.4 }, wrap(matchable: context) { $0.5 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountSelectionPresentable.self, method:
    """
    presentAccountSelection(_: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from: ControllerBackedProtocol?, context: AnyObject?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountSelectionPresentable: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func presentAccountSelection<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable, M6: Cuckoo.OptionalMatchable>(_ accounts: M1, selectedAccountItem: M2, title: M3, delegate: M4, from view: M5, context: M6) -> Cuckoo.__DoNotUse<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?), Void> where M1.MatchedType == [ChainAccountResponse], M2.OptionalMatchedType == ChainAccountResponse, M3.MatchedType == LocalizableResource<String>, M4.MatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == ControllerBackedProtocol, M6.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?)>] = [wrap(matchable: accounts) { $0.0 }, wrap(matchable: selectedAccountItem) { $0.1 }, wrap(matchable: title) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: view) { $0.4 }, wrap(matchable: context) { $0.5 }]
            return cuckoo_manager.verify(
    """
    presentAccountSelection(_: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from: ControllerBackedProtocol?, context: AnyObject?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountSelectionPresentableStub: AccountSelectionPresentable {
    

    

    
    
    
    
     func presentAccountSelection(_ accounts: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from view: ControllerBackedProtocol?, context: AnyObject?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import UIKit






 class MockControllerBackedProtocol: ControllerBackedProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ControllerBackedProtocol
    
     typealias Stubbing = __StubbingProxy_ControllerBackedProtocol
     typealias Verification = __VerificationProxy_ControllerBackedProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ControllerBackedProtocol?

     func enableDefaultImplementation(_ stub: ControllerBackedProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    

     struct __StubbingProxy_ControllerBackedProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockControllerBackedProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockControllerBackedProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
    }

     struct __VerificationProxy_ControllerBackedProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
    }
}


 class ControllerBackedProtocolStub: ControllerBackedProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
}





import Cuckoo
@testable import fearless

import SoraUI
import UIKit






 class MockLoadableViewProtocol: LoadableViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = LoadableViewProtocol
    
     typealias Stubbing = __StubbingProxy_LoadableViewProtocol
     typealias Verification = __VerificationProxy_LoadableViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: LoadableViewProtocol?

     func enableDefaultImplementation(_ stub: LoadableViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_LoadableViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockLoadableViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockLoadableViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockLoadableViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockLoadableViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_LoadableViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class LoadableViewProtocolStub: LoadableViewProtocol {
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import UIKit






 class MockModalAlertPresenting: ModalAlertPresenting, Cuckoo.ProtocolMock {
    
     typealias MocksType = ModalAlertPresenting
    
     typealias Stubbing = __StubbingProxy_ModalAlertPresenting
     typealias Verification = __VerificationProxy_ModalAlertPresenting

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ModalAlertPresenting?

     func enableDefaultImplementation(_ stub: ModalAlertPresenting) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func presentSuccessNotification(_ title: String, from view: ControllerBackedProtocol?, completion closure: (() -> Void)?)  {
        
    return cuckoo_manager.call(
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """,
            parameters: (title, view, closure),
            escapingParameters: (title, view, closure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentSuccessNotification(title, from: view, completion: closure))
        
    }
    
    

     struct __StubbingProxy_ModalAlertPresenting: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func presentSuccessNotification<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(_ title: M1, from view: M2, completion closure: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String, ControllerBackedProtocol?, (() -> Void)?)> where M1.MatchedType == String, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == (() -> Void) {
            let matchers: [Cuckoo.ParameterMatcher<(String, ControllerBackedProtocol?, (() -> Void)?)>] = [wrap(matchable: title) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: closure) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockModalAlertPresenting.self, method:
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ModalAlertPresenting: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func presentSuccessNotification<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(_ title: M1, from view: M2, completion closure: M3) -> Cuckoo.__DoNotUse<(String, ControllerBackedProtocol?, (() -> Void)?), Void> where M1.MatchedType == String, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == (() -> Void) {
            let matchers: [Cuckoo.ParameterMatcher<(String, ControllerBackedProtocol?, (() -> Void)?)>] = [wrap(matchable: title) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: closure) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ModalAlertPresentingStub: ModalAlertPresenting {
    

    

    
    
    
    
     func presentSuccessNotification(_ title: String, from view: ControllerBackedProtocol?, completion closure: (() -> Void)?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import UIKit






 class MockSharingPresentable: SharingPresentable, Cuckoo.ProtocolMock {
    
     typealias MocksType = SharingPresentable
    
     typealias Stubbing = __StubbingProxy_SharingPresentable
     typealias Verification = __VerificationProxy_SharingPresentable

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SharingPresentable?

     func enableDefaultImplementation(_ stub: SharingPresentable) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func share(source: UIActivityItemSource, from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)  {
        
    return cuckoo_manager.call(
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """,
            parameters: (source, view, completionHandler),
            escapingParameters: (source, view, completionHandler),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.share(source: source, from: view, with: completionHandler))
        
    }
    
    
    
    
    
     func share(sources: [Any], from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)  {
        
    return cuckoo_manager.call(
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """,
            parameters: (sources, view, completionHandler),
            escapingParameters: (sources, view, completionHandler),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.share(sources: sources, from: view, with: completionHandler))
        
    }
    
    

     struct __StubbingProxy_SharingPresentable: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(source: M1, from view: M2, with completionHandler: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)> where M1.MatchedType == UIActivityItemSource, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: source) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSharingPresentable.self, method:
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(sources: M1, from view: M2, with completionHandler: M3) -> Cuckoo.ProtocolStubNoReturnFunction<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)> where M1.MatchedType == [Any], M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: sources) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSharingPresentable.self, method:
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SharingPresentable: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(source: M1, from view: M2, with completionHandler: M3) -> Cuckoo.__DoNotUse<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?), Void> where M1.MatchedType == UIActivityItemSource, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: source) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return cuckoo_manager.verify(
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(sources: M1, from view: M2, with completionHandler: M3) -> Cuckoo.__DoNotUse<([Any], ControllerBackedProtocol?, SharingCompletionHandler?), Void> where M1.MatchedType == [Any], M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: sources) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return cuckoo_manager.verify(
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SharingPresentableStub: SharingPresentable {
    

    

    
    
    
    
     func share(source: UIActivityItemSource, from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func share(sources: [Any], from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import UIKit






 class MockSheetAlertPresentable: SheetAlertPresentable, Cuckoo.ProtocolMock {
    
     typealias MocksType = SheetAlertPresentable
    
     typealias Stubbing = __StubbingProxy_SheetAlertPresentable
     typealias Verification = __VerificationProxy_SheetAlertPresentable

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SheetAlertPresentable?

     func enableDefaultImplementation(_ stub: SheetAlertPresentable) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_SheetAlertPresentable: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSheetAlertPresentable.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSheetAlertPresentable.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSheetAlertPresentable.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SheetAlertPresentable: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SheetAlertPresentableStub: SheetAlertPresentable {
    

    

    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import SafariServices
import UIKit






 class MockWebPresentable: WebPresentable, Cuckoo.ProtocolMock {
    
     typealias MocksType = WebPresentable
    
     typealias Stubbing = __StubbingProxy_WebPresentable
     typealias Verification = __VerificationProxy_WebPresentable

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: WebPresentable?

     func enableDefaultImplementation(_ stub: WebPresentable) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    

     struct __StubbingProxy_WebPresentable: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockWebPresentable.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_WebPresentable: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class WebPresentableStub: WebPresentable {
    

    

    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation






 class MockSelectionListViewProtocol: SelectionListViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectionListViewProtocol
    
     typealias Stubbing = __StubbingProxy_SelectionListViewProtocol
     typealias Verification = __VerificationProxy_SelectionListViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectionListViewProtocol?

     func enableDefaultImplementation(_ stub: SelectionListViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func didReload()  {
        
    return cuckoo_manager.call(
    """
    didReload()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReload())
        
    }
    
    
    
    
    
     func bind(viewModel: TextSearchViewModel?)  {
        
    return cuckoo_manager.call(
    """
    bind(viewModel: TextSearchViewModel?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.bind(viewModel: viewModel))
        
    }
    
    
    
    
    
     func reloadCell(at indexPath: IndexPath)  {
        
    return cuckoo_manager.call(
    """
    reloadCell(at: IndexPath)
    """,
            parameters: (indexPath),
            escapingParameters: (indexPath),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reloadCell(at: indexPath))
        
    }
    
    

     struct __StubbingProxy_SelectionListViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectionListViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectionListViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func didReload() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectionListViewProtocol.self, method:
    """
    didReload()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func bind<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(TextSearchViewModel?)> where M1.OptionalMatchedType == TextSearchViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(TextSearchViewModel?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectionListViewProtocol.self, method:
    """
    bind(viewModel: TextSearchViewModel?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func reloadCell<M1: Cuckoo.Matchable>(at indexPath: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(IndexPath)> where M1.MatchedType == IndexPath {
            let matchers: [Cuckoo.ParameterMatcher<(IndexPath)>] = [wrap(matchable: indexPath) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectionListViewProtocol.self, method:
    """
    reloadCell(at: IndexPath)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectionListViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReload() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didReload()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func bind<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(TextSearchViewModel?), Void> where M1.OptionalMatchedType == TextSearchViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(TextSearchViewModel?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    bind(viewModel: TextSearchViewModel?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func reloadCell<M1: Cuckoo.Matchable>(at indexPath: M1) -> Cuckoo.__DoNotUse<(IndexPath), Void> where M1.MatchedType == IndexPath {
            let matchers: [Cuckoo.ParameterMatcher<(IndexPath)>] = [wrap(matchable: indexPath) { $0 }]
            return cuckoo_manager.verify(
    """
    reloadCell(at: IndexPath)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectionListViewProtocolStub: SelectionListViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReload()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func bind(viewModel: TextSearchViewModel?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func reloadCell(at indexPath: IndexPath)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectionListPresenterProtocol: SelectionListPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectionListPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_SelectionListPresenterProtocol
     typealias Verification = __VerificationProxy_SelectionListPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectionListPresenterProtocol?

     func enableDefaultImplementation(_ stub: SelectionListPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var numberOfItems: Int {
        get {
            return cuckoo_manager.getter("numberOfItems",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.numberOfItems)
        }
        
    }
    
    

    

    
    
    
    
     func item(at index: Int) -> SelectableViewModelProtocol {
        
    return cuckoo_manager.call(
    """
    item(at: Int) -> SelectableViewModelProtocol
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.item(at: index))
        
    }
    
    
    
    
    
     func selectItem(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    selectItem(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectItem(at: index))
        
    }
    
    
    
    
    
     func searchItem(with text: String?)  {
        
    return cuckoo_manager.call(
    """
    searchItem(with: String?)
    """,
            parameters: (text),
            escapingParameters: (text),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.searchItem(with: text))
        
    }
    
    

     struct __StubbingProxy_SelectionListPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var numberOfItems: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectionListPresenterProtocol, Int> {
            return .init(manager: cuckoo_manager, name: "numberOfItems")
        }
        
        
        
        
        
        func item<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubFunction<(Int), SelectableViewModelProtocol> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectionListPresenterProtocol.self, method:
    """
    item(at: Int) -> SelectableViewModelProtocol
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectionListPresenterProtocol.self, method:
    """
    selectItem(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func searchItem<M1: Cuckoo.OptionalMatchable>(with text: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String?)> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: text) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectionListPresenterProtocol.self, method:
    """
    searchItem(with: String?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectionListPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var numberOfItems: Cuckoo.VerifyReadOnlyProperty<Int> {
            return .init(manager: cuckoo_manager, name: "numberOfItems", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func item<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), SelectableViewModelProtocol> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    item(at: Int) -> SelectableViewModelProtocol
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    selectItem(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func searchItem<M1: Cuckoo.OptionalMatchable>(with text: M1) -> Cuckoo.__DoNotUse<(String?), Void> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: text) { $0 }]
            return cuckoo_manager.verify(
    """
    searchItem(with: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectionListPresenterProtocolStub: SelectionListPresenterProtocol {
    
    
    
    
     var numberOfItems: Int {
        get {
            return DefaultValueRegistry.defaultValue(for: (Int).self)
        }
        
    }
    
    

    

    
    
    
    
     func item(at index: Int) -> SelectableViewModelProtocol  {
        return DefaultValueRegistry.defaultValue(for: (SelectableViewModelProtocol).self)
    }
    
    
    
    
    
     func selectItem(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func searchItem(with text: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless






 class MockAccountConfirmViewProtocol: AccountConfirmViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountConfirmViewProtocol
    
     typealias Stubbing = __StubbingProxy_AccountConfirmViewProtocol
     typealias Verification = __VerificationProxy_AccountConfirmViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountConfirmViewProtocol?

     func enableDefaultImplementation(_ stub: AccountConfirmViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(words: [String], afterConfirmationFail: Bool)  {
        
    return cuckoo_manager.call(
    """
    didReceive(words: [String], afterConfirmationFail: Bool)
    """,
            parameters: (words, afterConfirmationFail),
            escapingParameters: (words, afterConfirmationFail),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(words: words, afterConfirmationFail: afterConfirmationFail))
        
    }
    
    

     struct __StubbingProxy_AccountConfirmViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountConfirmViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountConfirmViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(words: M1, afterConfirmationFail: M2) -> Cuckoo.ProtocolStubNoReturnFunction<([String], Bool)> where M1.MatchedType == [String], M2.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<([String], Bool)>] = [wrap(matchable: words) { $0.0 }, wrap(matchable: afterConfirmationFail) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmViewProtocol.self, method:
    """
    didReceive(words: [String], afterConfirmationFail: Bool)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountConfirmViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(words: M1, afterConfirmationFail: M2) -> Cuckoo.__DoNotUse<([String], Bool), Void> where M1.MatchedType == [String], M2.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<([String], Bool)>] = [wrap(matchable: words) { $0.0 }, wrap(matchable: afterConfirmationFail) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didReceive(words: [String], afterConfirmationFail: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountConfirmViewProtocolStub: AccountConfirmViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(words: [String], afterConfirmationFail: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountConfirmPresenterProtocol: AccountConfirmPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountConfirmPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_AccountConfirmPresenterProtocol
     typealias Verification = __VerificationProxy_AccountConfirmPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountConfirmPresenterProtocol?

     func enableDefaultImplementation(_ stub: AccountConfirmPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didLoad(view: AccountConfirmViewProtocol)  {
        
    return cuckoo_manager.call(
    """
    didLoad(view: AccountConfirmViewProtocol)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didLoad(view: view))
        
    }
    
    
    
    
    
     func requestWords()  {
        
    return cuckoo_manager.call(
    """
    requestWords()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.requestWords())
        
    }
    
    
    
    
    
     func confirm(words: [String])  {
        
    return cuckoo_manager.call(
    """
    confirm(words: [String])
    """,
            parameters: (words),
            escapingParameters: (words),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm(words: words))
        
    }
    
    
    
    
    
     func skip()  {
        
    return cuckoo_manager.call(
    """
    skip()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.skip())
        
    }
    
    

     struct __StubbingProxy_AccountConfirmPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountConfirmViewProtocol)> where M1.MatchedType == AccountConfirmViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AccountConfirmViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmPresenterProtocol.self, method:
    """
    didLoad(view: AccountConfirmViewProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func requestWords() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmPresenterProtocol.self, method:
    """
    requestWords()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func confirm<M1: Cuckoo.Matchable>(words: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([String])> where M1.MatchedType == [String] {
            let matchers: [Cuckoo.ParameterMatcher<([String])>] = [wrap(matchable: words) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmPresenterProtocol.self, method:
    """
    confirm(words: [String])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func skip() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmPresenterProtocol.self, method:
    """
    skip()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountConfirmPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.__DoNotUse<(AccountConfirmViewProtocol), Void> where M1.MatchedType == AccountConfirmViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AccountConfirmViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    didLoad(view: AccountConfirmViewProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func requestWords() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    requestWords()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func confirm<M1: Cuckoo.Matchable>(words: M1) -> Cuckoo.__DoNotUse<([String]), Void> where M1.MatchedType == [String] {
            let matchers: [Cuckoo.ParameterMatcher<([String])>] = [wrap(matchable: words) { $0 }]
            return cuckoo_manager.verify(
    """
    confirm(words: [String])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func skip() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    skip()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountConfirmPresenterProtocolStub: AccountConfirmPresenterProtocol {
    

    

    
    
    
    
     func didLoad(view: AccountConfirmViewProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func requestWords()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func confirm(words: [String])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func skip()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountConfirmInteractorInputProtocol: AccountConfirmInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountConfirmInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountConfirmInteractorInputProtocol
     typealias Verification = __VerificationProxy_AccountConfirmInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountConfirmInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: AccountConfirmInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var flow: AccountConfirmFlow? {
        get {
            return cuckoo_manager.getter("flow",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.flow)
        }
        
    }
    
    

    

    
    
    
    
     func requestWords()  {
        
    return cuckoo_manager.call(
    """
    requestWords()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.requestWords())
        
    }
    
    
    
    
    
     func confirm(words: [String])  {
        
    return cuckoo_manager.call(
    """
    confirm(words: [String])
    """,
            parameters: (words),
            escapingParameters: (words),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm(words: words))
        
    }
    
    
    
    
    
     func skipConfirmation()  {
        
    return cuckoo_manager.call(
    """
    skipConfirmation()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.skipConfirmation())
        
    }
    
    

     struct __StubbingProxy_AccountConfirmInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var flow: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountConfirmInteractorInputProtocol, AccountConfirmFlow?> {
            return .init(manager: cuckoo_manager, name: "flow")
        }
        
        
        
        
        
        func requestWords() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmInteractorInputProtocol.self, method:
    """
    requestWords()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func confirm<M1: Cuckoo.Matchable>(words: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([String])> where M1.MatchedType == [String] {
            let matchers: [Cuckoo.ParameterMatcher<([String])>] = [wrap(matchable: words) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmInteractorInputProtocol.self, method:
    """
    confirm(words: [String])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func skipConfirmation() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmInteractorInputProtocol.self, method:
    """
    skipConfirmation()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountConfirmInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var flow: Cuckoo.VerifyReadOnlyProperty<AccountConfirmFlow?> {
            return .init(manager: cuckoo_manager, name: "flow", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func requestWords() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    requestWords()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func confirm<M1: Cuckoo.Matchable>(words: M1) -> Cuckoo.__DoNotUse<([String]), Void> where M1.MatchedType == [String] {
            let matchers: [Cuckoo.ParameterMatcher<([String])>] = [wrap(matchable: words) { $0 }]
            return cuckoo_manager.verify(
    """
    confirm(words: [String])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func skipConfirmation() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    skipConfirmation()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountConfirmInteractorInputProtocolStub: AccountConfirmInteractorInputProtocol {
    
    
    
    
     var flow: AccountConfirmFlow? {
        get {
            return DefaultValueRegistry.defaultValue(for: (AccountConfirmFlow?).self)
        }
        
    }
    
    

    

    
    
    
    
     func requestWords()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func confirm(words: [String])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func skipConfirmation()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountConfirmInteractorOutputProtocol: AccountConfirmInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountConfirmInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountConfirmInteractorOutputProtocol
     typealias Verification = __VerificationProxy_AccountConfirmInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountConfirmInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: AccountConfirmInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(words: [String], afterConfirmationFail: Bool)  {
        
    return cuckoo_manager.call(
    """
    didReceive(words: [String], afterConfirmationFail: Bool)
    """,
            parameters: (words, afterConfirmationFail),
            escapingParameters: (words, afterConfirmationFail),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(words: words, afterConfirmationFail: afterConfirmationFail))
        
    }
    
    
    
    
    
     func didCompleteConfirmation()  {
        
    return cuckoo_manager.call(
    """
    didCompleteConfirmation()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didCompleteConfirmation())
        
    }
    
    
    
    
    
     func didReceive(error: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(error: Error)
    """,
            parameters: (error),
            escapingParameters: (error),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(error: error))
        
    }
    
    

     struct __StubbingProxy_AccountConfirmInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(words: M1, afterConfirmationFail: M2) -> Cuckoo.ProtocolStubNoReturnFunction<([String], Bool)> where M1.MatchedType == [String], M2.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<([String], Bool)>] = [wrap(matchable: words) { $0.0 }, wrap(matchable: afterConfirmationFail) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmInteractorOutputProtocol.self, method:
    """
    didReceive(words: [String], afterConfirmationFail: Bool)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didCompleteConfirmation() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmInteractorOutputProtocol.self, method:
    """
    didCompleteConfirmation()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmInteractorOutputProtocol.self, method:
    """
    didReceive(error: Error)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountConfirmInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(words: M1, afterConfirmationFail: M2) -> Cuckoo.__DoNotUse<([String], Bool), Void> where M1.MatchedType == [String], M2.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<([String], Bool)>] = [wrap(matchable: words) { $0.0 }, wrap(matchable: afterConfirmationFail) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didReceive(words: [String], afterConfirmationFail: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didCompleteConfirmation() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didCompleteConfirmation()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(error: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountConfirmInteractorOutputProtocolStub: AccountConfirmInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceive(words: [String], afterConfirmationFail: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didCompleteConfirmation()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(error: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountConfirmWireframeProtocol: AccountConfirmWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountConfirmWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_AccountConfirmWireframeProtocol
     typealias Verification = __VerificationProxy_AccountConfirmWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountConfirmWireframeProtocol?

     func enableDefaultImplementation(_ stub: AccountConfirmWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func proceed(from view: AccountConfirmViewProtocol?, flow: AccountConfirmFlow?)  {
        
    return cuckoo_manager.call(
    """
    proceed(from: AccountConfirmViewProtocol?, flow: AccountConfirmFlow?)
    """,
            parameters: (view, flow),
            escapingParameters: (view, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(from: view, flow: flow))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_AccountConfirmWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(from view: M1, flow: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountConfirmViewProtocol?, AccountConfirmFlow?)> where M1.OptionalMatchedType == AccountConfirmViewProtocol, M2.OptionalMatchedType == AccountConfirmFlow {
            let matchers: [Cuckoo.ParameterMatcher<(AccountConfirmViewProtocol?, AccountConfirmFlow?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmWireframeProtocol.self, method:
    """
    proceed(from: AccountConfirmViewProtocol?, flow: AccountConfirmFlow?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountConfirmWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountConfirmWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(from view: M1, flow: M2) -> Cuckoo.__DoNotUse<(AccountConfirmViewProtocol?, AccountConfirmFlow?), Void> where M1.OptionalMatchedType == AccountConfirmViewProtocol, M2.OptionalMatchedType == AccountConfirmFlow {
            let matchers: [Cuckoo.ParameterMatcher<(AccountConfirmViewProtocol?, AccountConfirmFlow?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }]
            return cuckoo_manager.verify(
    """
    proceed(from: AccountConfirmViewProtocol?, flow: AccountConfirmFlow?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountConfirmWireframeProtocolStub: AccountConfirmWireframeProtocol {
    

    

    
    
    
    
     func proceed(from view: AccountConfirmViewProtocol?, flow: AccountConfirmFlow?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import IrohaCrypto
import SoraFoundation






 class MockAccountCreateViewProtocol: AccountCreateViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountCreateViewProtocol
    
     typealias Stubbing = __StubbingProxy_AccountCreateViewProtocol
     typealias Verification = __VerificationProxy_AccountCreateViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountCreateViewProtocol?

     func enableDefaultImplementation(_ stub: AccountCreateViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func set(mnemonic: [String])  {
        
    return cuckoo_manager.call(
    """
    set(mnemonic: [String])
    """,
            parameters: (mnemonic),
            escapingParameters: (mnemonic),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.set(mnemonic: mnemonic))
        
    }
    
    
    
    
    
     func set(chainType: AccountCreateChainType)  {
        
    return cuckoo_manager.call(
    """
    set(chainType: AccountCreateChainType)
    """,
            parameters: (chainType),
            escapingParameters: (chainType),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.set(chainType: chainType))
        
    }
    
    
    
    
    
     func setSelectedSubstrateCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)  {
        
    return cuckoo_manager.call(
    """
    setSelectedSubstrateCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)
    """,
            parameters: (model),
            escapingParameters: (model),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setSelectedSubstrateCrypto(model: model))
        
    }
    
    
    
    
    
     func setEthereumCrypto(model: TitleWithSubtitleViewModel)  {
        
    return cuckoo_manager.call(
    """
    setEthereumCrypto(model: TitleWithSubtitleViewModel)
    """,
            parameters: (model),
            escapingParameters: (model),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setEthereumCrypto(model: model))
        
    }
    
    
    
    
    
     func bind(substrateViewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    bind(substrateViewModel: InputViewModelProtocol)
    """,
            parameters: (substrateViewModel),
            escapingParameters: (substrateViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.bind(substrateViewModel: substrateViewModel))
        
    }
    
    
    
    
    
     func bind(ethereumViewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    bind(ethereumViewModel: InputViewModelProtocol)
    """,
            parameters: (ethereumViewModel),
            escapingParameters: (ethereumViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.bind(ethereumViewModel: ethereumViewModel))
        
    }
    
    
    
    
    
     func didCompleteCryptoTypeSelection()  {
        
    return cuckoo_manager.call(
    """
    didCompleteCryptoTypeSelection()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didCompleteCryptoTypeSelection())
        
    }
    
    
    
    
    
     func didValidateSubstrateDerivationPath(_ status: FieldStatus)  {
        
    return cuckoo_manager.call(
    """
    didValidateSubstrateDerivationPath(_: FieldStatus)
    """,
            parameters: (status),
            escapingParameters: (status),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didValidateSubstrateDerivationPath(status))
        
    }
    
    
    
    
    
     func didValidateEthereumDerivationPath(_ status: FieldStatus)  {
        
    return cuckoo_manager.call(
    """
    didValidateEthereumDerivationPath(_: FieldStatus)
    """,
            parameters: (status),
            escapingParameters: (status),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didValidateEthereumDerivationPath(status))
        
    }
    
    

     struct __StubbingProxy_AccountCreateViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountCreateViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountCreateViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func set<M1: Cuckoo.Matchable>(mnemonic: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([String])> where M1.MatchedType == [String] {
            let matchers: [Cuckoo.ParameterMatcher<([String])>] = [wrap(matchable: mnemonic) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateViewProtocol.self, method:
    """
    set(mnemonic: [String])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func set<M1: Cuckoo.Matchable>(chainType: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountCreateChainType)> where M1.MatchedType == AccountCreateChainType {
            let matchers: [Cuckoo.ParameterMatcher<(AccountCreateChainType)>] = [wrap(matchable: chainType) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateViewProtocol.self, method:
    """
    set(chainType: AccountCreateChainType)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setSelectedSubstrateCrypto<M1: Cuckoo.Matchable>(model: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectableViewModel<TitleWithSubtitleViewModel>)> where M1.MatchedType == SelectableViewModel<TitleWithSubtitleViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(SelectableViewModel<TitleWithSubtitleViewModel>)>] = [wrap(matchable: model) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateViewProtocol.self, method:
    """
    setSelectedSubstrateCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setEthereumCrypto<M1: Cuckoo.Matchable>(model: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(TitleWithSubtitleViewModel)> where M1.MatchedType == TitleWithSubtitleViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(TitleWithSubtitleViewModel)>] = [wrap(matchable: model) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateViewProtocol.self, method:
    """
    setEthereumCrypto(model: TitleWithSubtitleViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func bind<M1: Cuckoo.Matchable>(substrateViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: substrateViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateViewProtocol.self, method:
    """
    bind(substrateViewModel: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func bind<M1: Cuckoo.Matchable>(ethereumViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: ethereumViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateViewProtocol.self, method:
    """
    bind(ethereumViewModel: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didCompleteCryptoTypeSelection() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateViewProtocol.self, method:
    """
    didCompleteCryptoTypeSelection()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didValidateSubstrateDerivationPath<M1: Cuckoo.Matchable>(_ status: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(FieldStatus)> where M1.MatchedType == FieldStatus {
            let matchers: [Cuckoo.ParameterMatcher<(FieldStatus)>] = [wrap(matchable: status) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateViewProtocol.self, method:
    """
    didValidateSubstrateDerivationPath(_: FieldStatus)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didValidateEthereumDerivationPath<M1: Cuckoo.Matchable>(_ status: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(FieldStatus)> where M1.MatchedType == FieldStatus {
            let matchers: [Cuckoo.ParameterMatcher<(FieldStatus)>] = [wrap(matchable: status) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateViewProtocol.self, method:
    """
    didValidateEthereumDerivationPath(_: FieldStatus)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountCreateViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func set<M1: Cuckoo.Matchable>(mnemonic: M1) -> Cuckoo.__DoNotUse<([String]), Void> where M1.MatchedType == [String] {
            let matchers: [Cuckoo.ParameterMatcher<([String])>] = [wrap(matchable: mnemonic) { $0 }]
            return cuckoo_manager.verify(
    """
    set(mnemonic: [String])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func set<M1: Cuckoo.Matchable>(chainType: M1) -> Cuckoo.__DoNotUse<(AccountCreateChainType), Void> where M1.MatchedType == AccountCreateChainType {
            let matchers: [Cuckoo.ParameterMatcher<(AccountCreateChainType)>] = [wrap(matchable: chainType) { $0 }]
            return cuckoo_manager.verify(
    """
    set(chainType: AccountCreateChainType)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setSelectedSubstrateCrypto<M1: Cuckoo.Matchable>(model: M1) -> Cuckoo.__DoNotUse<(SelectableViewModel<TitleWithSubtitleViewModel>), Void> where M1.MatchedType == SelectableViewModel<TitleWithSubtitleViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(SelectableViewModel<TitleWithSubtitleViewModel>)>] = [wrap(matchable: model) { $0 }]
            return cuckoo_manager.verify(
    """
    setSelectedSubstrateCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setEthereumCrypto<M1: Cuckoo.Matchable>(model: M1) -> Cuckoo.__DoNotUse<(TitleWithSubtitleViewModel), Void> where M1.MatchedType == TitleWithSubtitleViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(TitleWithSubtitleViewModel)>] = [wrap(matchable: model) { $0 }]
            return cuckoo_manager.verify(
    """
    setEthereumCrypto(model: TitleWithSubtitleViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func bind<M1: Cuckoo.Matchable>(substrateViewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: substrateViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    bind(substrateViewModel: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func bind<M1: Cuckoo.Matchable>(ethereumViewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: ethereumViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    bind(ethereumViewModel: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didCompleteCryptoTypeSelection() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didCompleteCryptoTypeSelection()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didValidateSubstrateDerivationPath<M1: Cuckoo.Matchable>(_ status: M1) -> Cuckoo.__DoNotUse<(FieldStatus), Void> where M1.MatchedType == FieldStatus {
            let matchers: [Cuckoo.ParameterMatcher<(FieldStatus)>] = [wrap(matchable: status) { $0 }]
            return cuckoo_manager.verify(
    """
    didValidateSubstrateDerivationPath(_: FieldStatus)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didValidateEthereumDerivationPath<M1: Cuckoo.Matchable>(_ status: M1) -> Cuckoo.__DoNotUse<(FieldStatus), Void> where M1.MatchedType == FieldStatus {
            let matchers: [Cuckoo.ParameterMatcher<(FieldStatus)>] = [wrap(matchable: status) { $0 }]
            return cuckoo_manager.verify(
    """
    didValidateEthereumDerivationPath(_: FieldStatus)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountCreateViewProtocolStub: AccountCreateViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func set(mnemonic: [String])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func set(chainType: AccountCreateChainType)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setSelectedSubstrateCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setEthereumCrypto(model: TitleWithSubtitleViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func bind(substrateViewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func bind(ethereumViewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didCompleteCryptoTypeSelection()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didValidateSubstrateDerivationPath(_ status: FieldStatus)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didValidateEthereumDerivationPath(_ status: FieldStatus)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountCreatePresenterProtocol: AccountCreatePresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountCreatePresenterProtocol
    
     typealias Stubbing = __StubbingProxy_AccountCreatePresenterProtocol
     typealias Verification = __VerificationProxy_AccountCreatePresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountCreatePresenterProtocol?

     func enableDefaultImplementation(_ stub: AccountCreatePresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func selectSubstrateCryptoType()  {
        
    return cuckoo_manager.call(
    """
    selectSubstrateCryptoType()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectSubstrateCryptoType())
        
    }
    
    
    
    
    
     func activateInfo()  {
        
    return cuckoo_manager.call(
    """
    activateInfo()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateInfo())
        
    }
    
    
    
    
    
     func validateSubstrate()  {
        
    return cuckoo_manager.call(
    """
    validateSubstrate()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.validateSubstrate())
        
    }
    
    
    
    
    
     func validateEthereum()  {
        
    return cuckoo_manager.call(
    """
    validateEthereum()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.validateEthereum())
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    

     struct __StubbingProxy_AccountCreatePresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreatePresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectSubstrateCryptoType() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreatePresenterProtocol.self, method:
    """
    selectSubstrateCryptoType()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateInfo() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreatePresenterProtocol.self, method:
    """
    activateInfo()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func validateSubstrate() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreatePresenterProtocol.self, method:
    """
    validateSubstrate()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func validateEthereum() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreatePresenterProtocol.self, method:
    """
    validateEthereum()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreatePresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountCreatePresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectSubstrateCryptoType() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectSubstrateCryptoType()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateInfo() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateInfo()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func validateSubstrate() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    validateSubstrate()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func validateEthereum() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    validateEthereum()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountCreatePresenterProtocolStub: AccountCreatePresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectSubstrateCryptoType()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateInfo()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func validateSubstrate()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func validateEthereum()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountCreateInteractorInputProtocol: AccountCreateInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountCreateInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountCreateInteractorInputProtocol
     typealias Verification = __VerificationProxy_AccountCreateInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountCreateInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: AccountCreateInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func createMnemonicFromString(_ mnemonicString: String) -> IRMnemonicProtocol? {
        
    return cuckoo_manager.call(
    """
    createMnemonicFromString(_: String) -> IRMnemonicProtocol?
    """,
            parameters: (mnemonicString),
            escapingParameters: (mnemonicString),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.createMnemonicFromString(mnemonicString))
        
    }
    
    

     struct __StubbingProxy_AccountCreateInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func createMnemonicFromString<M1: Cuckoo.Matchable>(_ mnemonicString: M1) -> Cuckoo.ProtocolStubFunction<(String), IRMnemonicProtocol?> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: mnemonicString) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateInteractorInputProtocol.self, method:
    """
    createMnemonicFromString(_: String) -> IRMnemonicProtocol?
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountCreateInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func createMnemonicFromString<M1: Cuckoo.Matchable>(_ mnemonicString: M1) -> Cuckoo.__DoNotUse<(String), IRMnemonicProtocol?> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: mnemonicString) { $0 }]
            return cuckoo_manager.verify(
    """
    createMnemonicFromString(_: String) -> IRMnemonicProtocol?
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountCreateInteractorInputProtocolStub: AccountCreateInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func createMnemonicFromString(_ mnemonicString: String) -> IRMnemonicProtocol?  {
        return DefaultValueRegistry.defaultValue(for: (IRMnemonicProtocol?).self)
    }
    
    
}










 class MockAccountCreateInteractorOutputProtocol: AccountCreateInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountCreateInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountCreateInteractorOutputProtocol
     typealias Verification = __VerificationProxy_AccountCreateInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountCreateInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: AccountCreateInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(mnemonic: [String])  {
        
    return cuckoo_manager.call(
    """
    didReceive(mnemonic: [String])
    """,
            parameters: (mnemonic),
            escapingParameters: (mnemonic),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(mnemonic: mnemonic))
        
    }
    
    
    
    
    
     func didReceiveMnemonicGeneration(error: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMnemonicGeneration(error: Error)
    """,
            parameters: (error),
            escapingParameters: (error),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMnemonicGeneration(error: error))
        
    }
    
    

     struct __StubbingProxy_AccountCreateInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(mnemonic: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([String])> where M1.MatchedType == [String] {
            let matchers: [Cuckoo.ParameterMatcher<([String])>] = [wrap(matchable: mnemonic) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateInteractorOutputProtocol.self, method:
    """
    didReceive(mnemonic: [String])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMnemonicGeneration<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateInteractorOutputProtocol.self, method:
    """
    didReceiveMnemonicGeneration(error: Error)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountCreateInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(mnemonic: M1) -> Cuckoo.__DoNotUse<([String]), Void> where M1.MatchedType == [String] {
            let matchers: [Cuckoo.ParameterMatcher<([String])>] = [wrap(matchable: mnemonic) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(mnemonic: [String])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMnemonicGeneration<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMnemonicGeneration(error: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountCreateInteractorOutputProtocolStub: AccountCreateInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceive(mnemonic: [String])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMnemonicGeneration(error: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountCreateWireframeProtocol: AccountCreateWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountCreateWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_AccountCreateWireframeProtocol
     typealias Verification = __VerificationProxy_AccountCreateWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountCreateWireframeProtocol?

     func enableDefaultImplementation(_ stub: AccountCreateWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func confirm(from view: AccountCreateViewProtocol?, flow: AccountConfirmFlow)  {
        
    return cuckoo_manager.call(
    """
    confirm(from: AccountCreateViewProtocol?, flow: AccountConfirmFlow)
    """,
            parameters: (view, flow),
            escapingParameters: (view, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm(from: view, flow: flow))
        
    }
    
    
    
    
    
     func presentCryptoTypeSelection(from view: AccountCreateViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)  {
        
    return cuckoo_manager.call(
    """
    presentCryptoTypeSelection(from: AccountCreateViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """,
            parameters: (view, availableTypes, selectedType, delegate, context),
            escapingParameters: (view, availableTypes, selectedType, delegate, context),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentCryptoTypeSelection(from: view, availableTypes: availableTypes, selectedType: selectedType, delegate: delegate, context: context))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_AccountCreateWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func confirm<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, flow: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountCreateViewProtocol?, AccountConfirmFlow)> where M1.OptionalMatchedType == AccountCreateViewProtocol, M2.MatchedType == AccountConfirmFlow {
            let matchers: [Cuckoo.ParameterMatcher<(AccountCreateViewProtocol?, AccountConfirmFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateWireframeProtocol.self, method:
    """
    confirm(from: AccountCreateViewProtocol?, flow: AccountConfirmFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentCryptoTypeSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.OptionalMatchable>(from view: M1, availableTypes: M2, selectedType: M3, delegate: M4, context: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountCreateViewProtocol?, [CryptoType], CryptoType, ModalPickerViewControllerDelegate?, AnyObject?)> where M1.OptionalMatchedType == AccountCreateViewProtocol, M2.MatchedType == [CryptoType], M3.MatchedType == CryptoType, M4.OptionalMatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<(AccountCreateViewProtocol?, [CryptoType], CryptoType, ModalPickerViewControllerDelegate?, AnyObject?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: availableTypes) { $0.1 }, wrap(matchable: selectedType) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: context) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateWireframeProtocol.self, method:
    """
    presentCryptoTypeSelection(from: AccountCreateViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountCreateWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountCreateWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func confirm<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, flow: M2) -> Cuckoo.__DoNotUse<(AccountCreateViewProtocol?, AccountConfirmFlow), Void> where M1.OptionalMatchedType == AccountCreateViewProtocol, M2.MatchedType == AccountConfirmFlow {
            let matchers: [Cuckoo.ParameterMatcher<(AccountCreateViewProtocol?, AccountConfirmFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }]
            return cuckoo_manager.verify(
    """
    confirm(from: AccountCreateViewProtocol?, flow: AccountConfirmFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentCryptoTypeSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.OptionalMatchable>(from view: M1, availableTypes: M2, selectedType: M3, delegate: M4, context: M5) -> Cuckoo.__DoNotUse<(AccountCreateViewProtocol?, [CryptoType], CryptoType, ModalPickerViewControllerDelegate?, AnyObject?), Void> where M1.OptionalMatchedType == AccountCreateViewProtocol, M2.MatchedType == [CryptoType], M3.MatchedType == CryptoType, M4.OptionalMatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<(AccountCreateViewProtocol?, [CryptoType], CryptoType, ModalPickerViewControllerDelegate?, AnyObject?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: availableTypes) { $0.1 }, wrap(matchable: selectedType) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: context) { $0.4 }]
            return cuckoo_manager.verify(
    """
    presentCryptoTypeSelection(from: AccountCreateViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountCreateWireframeProtocolStub: AccountCreateWireframeProtocol {
    

    

    
    
    
    
     func confirm(from view: AccountCreateViewProtocol?, flow: AccountConfirmFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentCryptoTypeSelection(from view: AccountCreateViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import IrohaCrypto
import SoraFoundation






 class MockAccountImportViewProtocol: AccountImportViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountImportViewProtocol
    
     typealias Stubbing = __StubbingProxy_AccountImportViewProtocol
     typealias Verification = __VerificationProxy_AccountImportViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountImportViewProtocol?

     func enableDefaultImplementation(_ stub: AccountImportViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func show(chainType: AccountCreateChainType)  {
        
    return cuckoo_manager.call(
    """
    show(chainType: AccountCreateChainType)
    """,
            parameters: (chainType),
            escapingParameters: (chainType),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.show(chainType: chainType))
        
    }
    
    
    
    
    
     func setSource(type: AccountImportSource, chainType: AccountCreateChainType, selectable: Bool)  {
        
    return cuckoo_manager.call(
    """
    setSource(type: AccountImportSource, chainType: AccountCreateChainType, selectable: Bool)
    """,
            parameters: (type, chainType, selectable),
            escapingParameters: (type, chainType, selectable),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setSource(type: type, chainType: chainType, selectable: selectable))
        
    }
    
    
    
    
    
     func setSource(viewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    setSource(viewModel: InputViewModelProtocol)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setSource(viewModel: viewModel))
        
    }
    
    
    
    
    
     func setName(viewModel: InputViewModelProtocol, visible: Bool)  {
        
    return cuckoo_manager.call(
    """
    setName(viewModel: InputViewModelProtocol, visible: Bool)
    """,
            parameters: (viewModel, visible),
            escapingParameters: (viewModel, visible),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setName(viewModel: viewModel, visible: visible))
        
    }
    
    
    
    
    
     func setPassword(viewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    setPassword(viewModel: InputViewModelProtocol)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setPassword(viewModel: viewModel))
        
    }
    
    
    
    
    
     func setSelectedCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)  {
        
    return cuckoo_manager.call(
    """
    setSelectedCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)
    """,
            parameters: (model),
            escapingParameters: (model),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setSelectedCrypto(model: model))
        
    }
    
    
    
    
    
     func bind(substrateViewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    bind(substrateViewModel: InputViewModelProtocol)
    """,
            parameters: (substrateViewModel),
            escapingParameters: (substrateViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.bind(substrateViewModel: substrateViewModel))
        
    }
    
    
    
    
    
     func bind(ethereumViewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    bind(ethereumViewModel: InputViewModelProtocol)
    """,
            parameters: (ethereumViewModel),
            escapingParameters: (ethereumViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.bind(ethereumViewModel: ethereumViewModel))
        
    }
    
    
    
    
    
     func setUploadWarning(message: String)  {
        
    return cuckoo_manager.call(
    """
    setUploadWarning(message: String)
    """,
            parameters: (message),
            escapingParameters: (message),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setUploadWarning(message: message))
        
    }
    
    
    
    
    
     func setUniqueChain(viewModel: UniqueChainViewModel)  {
        
    return cuckoo_manager.call(
    """
    setUniqueChain(viewModel: UniqueChainViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setUniqueChain(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didCompleteSourceTypeSelection()  {
        
    return cuckoo_manager.call(
    """
    didCompleteSourceTypeSelection()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didCompleteSourceTypeSelection())
        
    }
    
    
    
    
    
     func didCompleteCryptoTypeSelection()  {
        
    return cuckoo_manager.call(
    """
    didCompleteCryptoTypeSelection()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didCompleteCryptoTypeSelection())
        
    }
    
    
    
    
    
     func didValidateSubstrateDerivationPath(_ status: FieldStatus)  {
        
    return cuckoo_manager.call(
    """
    didValidateSubstrateDerivationPath(_: FieldStatus)
    """,
            parameters: (status),
            escapingParameters: (status),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didValidateSubstrateDerivationPath(status))
        
    }
    
    
    
    
    
     func didValidateEthereumDerivationPath(_ status: FieldStatus)  {
        
    return cuckoo_manager.call(
    """
    didValidateEthereumDerivationPath(_: FieldStatus)
    """,
            parameters: (status),
            escapingParameters: (status),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didValidateEthereumDerivationPath(status))
        
    }
    
    

     struct __StubbingProxy_AccountImportViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountImportViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountImportViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func show<M1: Cuckoo.Matchable>(chainType: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountCreateChainType)> where M1.MatchedType == AccountCreateChainType {
            let matchers: [Cuckoo.ParameterMatcher<(AccountCreateChainType)>] = [wrap(matchable: chainType) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    show(chainType: AccountCreateChainType)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setSource<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(type: M1, chainType: M2, selectable: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountImportSource, AccountCreateChainType, Bool)> where M1.MatchedType == AccountImportSource, M2.MatchedType == AccountCreateChainType, M3.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportSource, AccountCreateChainType, Bool)>] = [wrap(matchable: type) { $0.0 }, wrap(matchable: chainType) { $0.1 }, wrap(matchable: selectable) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    setSource(type: AccountImportSource, chainType: AccountCreateChainType, selectable: Bool)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setSource<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    setSource(viewModel: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setName<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(viewModel: M1, visible: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol, Bool)> where M1.MatchedType == InputViewModelProtocol, M2.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol, Bool)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: visible) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    setName(viewModel: InputViewModelProtocol, visible: Bool)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setPassword<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    setPassword(viewModel: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setSelectedCrypto<M1: Cuckoo.Matchable>(model: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectableViewModel<TitleWithSubtitleViewModel>)> where M1.MatchedType == SelectableViewModel<TitleWithSubtitleViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(SelectableViewModel<TitleWithSubtitleViewModel>)>] = [wrap(matchable: model) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    setSelectedCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func bind<M1: Cuckoo.Matchable>(substrateViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: substrateViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    bind(substrateViewModel: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func bind<M1: Cuckoo.Matchable>(ethereumViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: ethereumViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    bind(ethereumViewModel: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setUploadWarning<M1: Cuckoo.Matchable>(message: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String)> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: message) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    setUploadWarning(message: String)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setUniqueChain<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UniqueChainViewModel)> where M1.MatchedType == UniqueChainViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(UniqueChainViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    setUniqueChain(viewModel: UniqueChainViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didCompleteSourceTypeSelection() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    didCompleteSourceTypeSelection()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didCompleteCryptoTypeSelection() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    didCompleteCryptoTypeSelection()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didValidateSubstrateDerivationPath<M1: Cuckoo.Matchable>(_ status: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(FieldStatus)> where M1.MatchedType == FieldStatus {
            let matchers: [Cuckoo.ParameterMatcher<(FieldStatus)>] = [wrap(matchable: status) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    didValidateSubstrateDerivationPath(_: FieldStatus)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didValidateEthereumDerivationPath<M1: Cuckoo.Matchable>(_ status: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(FieldStatus)> where M1.MatchedType == FieldStatus {
            let matchers: [Cuckoo.ParameterMatcher<(FieldStatus)>] = [wrap(matchable: status) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportViewProtocol.self, method:
    """
    didValidateEthereumDerivationPath(_: FieldStatus)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountImportViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func show<M1: Cuckoo.Matchable>(chainType: M1) -> Cuckoo.__DoNotUse<(AccountCreateChainType), Void> where M1.MatchedType == AccountCreateChainType {
            let matchers: [Cuckoo.ParameterMatcher<(AccountCreateChainType)>] = [wrap(matchable: chainType) { $0 }]
            return cuckoo_manager.verify(
    """
    show(chainType: AccountCreateChainType)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setSource<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(type: M1, chainType: M2, selectable: M3) -> Cuckoo.__DoNotUse<(AccountImportSource, AccountCreateChainType, Bool), Void> where M1.MatchedType == AccountImportSource, M2.MatchedType == AccountCreateChainType, M3.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportSource, AccountCreateChainType, Bool)>] = [wrap(matchable: type) { $0.0 }, wrap(matchable: chainType) { $0.1 }, wrap(matchable: selectable) { $0.2 }]
            return cuckoo_manager.verify(
    """
    setSource(type: AccountImportSource, chainType: AccountCreateChainType, selectable: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setSource<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    setSource(viewModel: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setName<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(viewModel: M1, visible: M2) -> Cuckoo.__DoNotUse<(InputViewModelProtocol, Bool), Void> where M1.MatchedType == InputViewModelProtocol, M2.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol, Bool)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: visible) { $0.1 }]
            return cuckoo_manager.verify(
    """
    setName(viewModel: InputViewModelProtocol, visible: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setPassword<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    setPassword(viewModel: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setSelectedCrypto<M1: Cuckoo.Matchable>(model: M1) -> Cuckoo.__DoNotUse<(SelectableViewModel<TitleWithSubtitleViewModel>), Void> where M1.MatchedType == SelectableViewModel<TitleWithSubtitleViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(SelectableViewModel<TitleWithSubtitleViewModel>)>] = [wrap(matchable: model) { $0 }]
            return cuckoo_manager.verify(
    """
    setSelectedCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func bind<M1: Cuckoo.Matchable>(substrateViewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: substrateViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    bind(substrateViewModel: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func bind<M1: Cuckoo.Matchable>(ethereumViewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: ethereumViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    bind(ethereumViewModel: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setUploadWarning<M1: Cuckoo.Matchable>(message: M1) -> Cuckoo.__DoNotUse<(String), Void> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: message) { $0 }]
            return cuckoo_manager.verify(
    """
    setUploadWarning(message: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setUniqueChain<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(UniqueChainViewModel), Void> where M1.MatchedType == UniqueChainViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(UniqueChainViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    setUniqueChain(viewModel: UniqueChainViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didCompleteSourceTypeSelection() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didCompleteSourceTypeSelection()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didCompleteCryptoTypeSelection() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didCompleteCryptoTypeSelection()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didValidateSubstrateDerivationPath<M1: Cuckoo.Matchable>(_ status: M1) -> Cuckoo.__DoNotUse<(FieldStatus), Void> where M1.MatchedType == FieldStatus {
            let matchers: [Cuckoo.ParameterMatcher<(FieldStatus)>] = [wrap(matchable: status) { $0 }]
            return cuckoo_manager.verify(
    """
    didValidateSubstrateDerivationPath(_: FieldStatus)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didValidateEthereumDerivationPath<M1: Cuckoo.Matchable>(_ status: M1) -> Cuckoo.__DoNotUse<(FieldStatus), Void> where M1.MatchedType == FieldStatus {
            let matchers: [Cuckoo.ParameterMatcher<(FieldStatus)>] = [wrap(matchable: status) { $0 }]
            return cuckoo_manager.verify(
    """
    didValidateEthereumDerivationPath(_: FieldStatus)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountImportViewProtocolStub: AccountImportViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func show(chainType: AccountCreateChainType)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setSource(type: AccountImportSource, chainType: AccountCreateChainType, selectable: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setSource(viewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setName(viewModel: InputViewModelProtocol, visible: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setPassword(viewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setSelectedCrypto(model: SelectableViewModel<TitleWithSubtitleViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func bind(substrateViewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func bind(ethereumViewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setUploadWarning(message: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setUniqueChain(viewModel: UniqueChainViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didCompleteSourceTypeSelection()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didCompleteCryptoTypeSelection()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didValidateSubstrateDerivationPath(_ status: FieldStatus)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didValidateEthereumDerivationPath(_ status: FieldStatus)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountImportPresenterProtocol: AccountImportPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountImportPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_AccountImportPresenterProtocol
     typealias Verification = __VerificationProxy_AccountImportPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountImportPresenterProtocol?

     func enableDefaultImplementation(_ stub: AccountImportPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var flow: AccountImportFlow {
        get {
            return cuckoo_manager.getter("flow",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.flow)
        }
        
    }
    
    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func selectSourceType()  {
        
    return cuckoo_manager.call(
    """
    selectSourceType()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectSourceType())
        
    }
    
    
    
    
    
     func selectCryptoType()  {
        
    return cuckoo_manager.call(
    """
    selectCryptoType()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectCryptoType())
        
    }
    
    
    
    
    
     func activateUpload()  {
        
    return cuckoo_manager.call(
    """
    activateUpload()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateUpload())
        
    }
    
    
    
    
    
     func validateSubstrateDerivationPath()  {
        
    return cuckoo_manager.call(
    """
    validateSubstrateDerivationPath()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.validateSubstrateDerivationPath())
        
    }
    
    
    
    
    
     func validateEthereumDerivationPath()  {
        
    return cuckoo_manager.call(
    """
    validateEthereumDerivationPath()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.validateEthereumDerivationPath())
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    

     struct __StubbingProxy_AccountImportPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var flow: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountImportPresenterProtocol, AccountImportFlow> {
            return .init(manager: cuckoo_manager, name: "flow")
        }
        
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectSourceType() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportPresenterProtocol.self, method:
    """
    selectSourceType()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectCryptoType() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportPresenterProtocol.self, method:
    """
    selectCryptoType()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateUpload() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportPresenterProtocol.self, method:
    """
    activateUpload()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func validateSubstrateDerivationPath() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportPresenterProtocol.self, method:
    """
    validateSubstrateDerivationPath()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func validateEthereumDerivationPath() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportPresenterProtocol.self, method:
    """
    validateEthereumDerivationPath()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountImportPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var flow: Cuckoo.VerifyReadOnlyProperty<AccountImportFlow> {
            return .init(manager: cuckoo_manager, name: "flow", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectSourceType() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectSourceType()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectCryptoType() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectCryptoType()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateUpload() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateUpload()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func validateSubstrateDerivationPath() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    validateSubstrateDerivationPath()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func validateEthereumDerivationPath() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    validateEthereumDerivationPath()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountImportPresenterProtocolStub: AccountImportPresenterProtocol {
    
    
    
    
     var flow: AccountImportFlow {
        get {
            return DefaultValueRegistry.defaultValue(for: (AccountImportFlow).self)
        }
        
    }
    
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectSourceType()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectCryptoType()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateUpload()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func validateSubstrateDerivationPath()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func validateEthereumDerivationPath()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountImportInteractorInputProtocol: AccountImportInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountImportInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountImportInteractorInputProtocol
     typealias Verification = __VerificationProxy_AccountImportInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountImportInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: AccountImportInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func importMetaAccount(request: MetaAccountImportRequest)  {
        
    return cuckoo_manager.call(
    """
    importMetaAccount(request: MetaAccountImportRequest)
    """,
            parameters: (request),
            escapingParameters: (request),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.importMetaAccount(request: request))
        
    }
    
    
    
    
    
     func importUniqueChain(request: UniqueChainImportRequest)  {
        
    return cuckoo_manager.call(
    """
    importUniqueChain(request: UniqueChainImportRequest)
    """,
            parameters: (request),
            escapingParameters: (request),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.importUniqueChain(request: request))
        
    }
    
    
    
    
    
     func deriveMetadataFromKeystore(_ keystore: String)  {
        
    return cuckoo_manager.call(
    """
    deriveMetadataFromKeystore(_: String)
    """,
            parameters: (keystore),
            escapingParameters: (keystore),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.deriveMetadataFromKeystore(keystore))
        
    }
    
    
    
    
    
     func createMnemonicFromString(_ mnemonicString: String) -> IRMnemonicProtocol? {
        
    return cuckoo_manager.call(
    """
    createMnemonicFromString(_: String) -> IRMnemonicProtocol?
    """,
            parameters: (mnemonicString),
            escapingParameters: (mnemonicString),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.createMnemonicFromString(mnemonicString))
        
    }
    
    

     struct __StubbingProxy_AccountImportInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func importMetaAccount<M1: Cuckoo.Matchable>(request: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(MetaAccountImportRequest)> where M1.MatchedType == MetaAccountImportRequest {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountImportRequest)>] = [wrap(matchable: request) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportInteractorInputProtocol.self, method:
    """
    importMetaAccount(request: MetaAccountImportRequest)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func importUniqueChain<M1: Cuckoo.Matchable>(request: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UniqueChainImportRequest)> where M1.MatchedType == UniqueChainImportRequest {
            let matchers: [Cuckoo.ParameterMatcher<(UniqueChainImportRequest)>] = [wrap(matchable: request) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportInteractorInputProtocol.self, method:
    """
    importUniqueChain(request: UniqueChainImportRequest)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func deriveMetadataFromKeystore<M1: Cuckoo.Matchable>(_ keystore: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String)> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: keystore) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportInteractorInputProtocol.self, method:
    """
    deriveMetadataFromKeystore(_: String)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func createMnemonicFromString<M1: Cuckoo.Matchable>(_ mnemonicString: M1) -> Cuckoo.ProtocolStubFunction<(String), IRMnemonicProtocol?> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: mnemonicString) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportInteractorInputProtocol.self, method:
    """
    createMnemonicFromString(_: String) -> IRMnemonicProtocol?
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountImportInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func importMetaAccount<M1: Cuckoo.Matchable>(request: M1) -> Cuckoo.__DoNotUse<(MetaAccountImportRequest), Void> where M1.MatchedType == MetaAccountImportRequest {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountImportRequest)>] = [wrap(matchable: request) { $0 }]
            return cuckoo_manager.verify(
    """
    importMetaAccount(request: MetaAccountImportRequest)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func importUniqueChain<M1: Cuckoo.Matchable>(request: M1) -> Cuckoo.__DoNotUse<(UniqueChainImportRequest), Void> where M1.MatchedType == UniqueChainImportRequest {
            let matchers: [Cuckoo.ParameterMatcher<(UniqueChainImportRequest)>] = [wrap(matchable: request) { $0 }]
            return cuckoo_manager.verify(
    """
    importUniqueChain(request: UniqueChainImportRequest)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func deriveMetadataFromKeystore<M1: Cuckoo.Matchable>(_ keystore: M1) -> Cuckoo.__DoNotUse<(String), Void> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: keystore) { $0 }]
            return cuckoo_manager.verify(
    """
    deriveMetadataFromKeystore(_: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func createMnemonicFromString<M1: Cuckoo.Matchable>(_ mnemonicString: M1) -> Cuckoo.__DoNotUse<(String), IRMnemonicProtocol?> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: mnemonicString) { $0 }]
            return cuckoo_manager.verify(
    """
    createMnemonicFromString(_: String) -> IRMnemonicProtocol?
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountImportInteractorInputProtocolStub: AccountImportInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func importMetaAccount(request: MetaAccountImportRequest)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func importUniqueChain(request: UniqueChainImportRequest)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func deriveMetadataFromKeystore(_ keystore: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func createMnemonicFromString(_ mnemonicString: String) -> IRMnemonicProtocol?  {
        return DefaultValueRegistry.defaultValue(for: (IRMnemonicProtocol?).self)
    }
    
    
}










 class MockAccountImportInteractorOutputProtocol: AccountImportInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountImportInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountImportInteractorOutputProtocol
     typealias Verification = __VerificationProxy_AccountImportInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountImportInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: AccountImportInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceiveAccountImport(metadata: MetaAccountImportMetadata)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountImport(metadata: MetaAccountImportMetadata)
    """,
            parameters: (metadata),
            escapingParameters: (metadata),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountImport(metadata: metadata))
        
    }
    
    
    
    
    
     func didCompleteAccountImport()  {
        
    return cuckoo_manager.call(
    """
    didCompleteAccountImport()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didCompleteAccountImport())
        
    }
    
    
    
    
    
     func didReceiveAccountImport(error: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountImport(error: Error)
    """,
            parameters: (error),
            escapingParameters: (error),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountImport(error: error))
        
    }
    
    
    
    
    
     func didSuggestKeystore(text: String, preferredInfo: MetaAccountImportPreferredInfo?)  {
        
    return cuckoo_manager.call(
    """
    didSuggestKeystore(text: String, preferredInfo: MetaAccountImportPreferredInfo?)
    """,
            parameters: (text, preferredInfo),
            escapingParameters: (text, preferredInfo),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSuggestKeystore(text: text, preferredInfo: preferredInfo))
        
    }
    
    

     struct __StubbingProxy_AccountImportInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceiveAccountImport<M1: Cuckoo.Matchable>(metadata: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(MetaAccountImportMetadata)> where M1.MatchedType == MetaAccountImportMetadata {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountImportMetadata)>] = [wrap(matchable: metadata) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportInteractorOutputProtocol.self, method:
    """
    didReceiveAccountImport(metadata: MetaAccountImportMetadata)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didCompleteAccountImport() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportInteractorOutputProtocol.self, method:
    """
    didCompleteAccountImport()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountImport<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportInteractorOutputProtocol.self, method:
    """
    didReceiveAccountImport(error: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didSuggestKeystore<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(text: M1, preferredInfo: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(String, MetaAccountImportPreferredInfo?)> where M1.MatchedType == String, M2.OptionalMatchedType == MetaAccountImportPreferredInfo {
            let matchers: [Cuckoo.ParameterMatcher<(String, MetaAccountImportPreferredInfo?)>] = [wrap(matchable: text) { $0.0 }, wrap(matchable: preferredInfo) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportInteractorOutputProtocol.self, method:
    """
    didSuggestKeystore(text: String, preferredInfo: MetaAccountImportPreferredInfo?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountImportInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceiveAccountImport<M1: Cuckoo.Matchable>(metadata: M1) -> Cuckoo.__DoNotUse<(MetaAccountImportMetadata), Void> where M1.MatchedType == MetaAccountImportMetadata {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountImportMetadata)>] = [wrap(matchable: metadata) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountImport(metadata: MetaAccountImportMetadata)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didCompleteAccountImport() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didCompleteAccountImport()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountImport<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountImport(error: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didSuggestKeystore<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(text: M1, preferredInfo: M2) -> Cuckoo.__DoNotUse<(String, MetaAccountImportPreferredInfo?), Void> where M1.MatchedType == String, M2.OptionalMatchedType == MetaAccountImportPreferredInfo {
            let matchers: [Cuckoo.ParameterMatcher<(String, MetaAccountImportPreferredInfo?)>] = [wrap(matchable: text) { $0.0 }, wrap(matchable: preferredInfo) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didSuggestKeystore(text: String, preferredInfo: MetaAccountImportPreferredInfo?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountImportInteractorOutputProtocolStub: AccountImportInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceiveAccountImport(metadata: MetaAccountImportMetadata)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didCompleteAccountImport()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountImport(error: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didSuggestKeystore(text: String, preferredInfo: MetaAccountImportPreferredInfo?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountImportWireframeProtocol: AccountImportWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountImportWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_AccountImportWireframeProtocol
     typealias Verification = __VerificationProxy_AccountImportWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountImportWireframeProtocol?

     func enableDefaultImplementation(_ stub: AccountImportWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showSecondStep(from view: AccountImportViewProtocol?, with data: AccountCreationStep.FirstStepData)  {
        
    return cuckoo_manager.call(
    """
    showSecondStep(from: AccountImportViewProtocol?, with: AccountCreationStep.FirstStepData)
    """,
            parameters: (view, data),
            escapingParameters: (view, data),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showSecondStep(from: view, with: data))
        
    }
    
    
    
    
    
     func proceed(from view: AccountImportViewProtocol?, flow: AccountImportFlow)  {
        
    return cuckoo_manager.call(
    """
    proceed(from: AccountImportViewProtocol?, flow: AccountImportFlow)
    """,
            parameters: (view, flow),
            escapingParameters: (view, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(from: view, flow: flow))
        
    }
    
    
    
    
    
     func presentSourceTypeSelection(from view: AccountImportViewProtocol?, availableSources: [AccountImportSource], selectedSource: AccountImportSource, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)  {
        
    return cuckoo_manager.call(
    """
    presentSourceTypeSelection(from: AccountImportViewProtocol?, availableSources: [AccountImportSource], selectedSource: AccountImportSource, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """,
            parameters: (view, availableSources, selectedSource, delegate, context),
            escapingParameters: (view, availableSources, selectedSource, delegate, context),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentSourceTypeSelection(from: view, availableSources: availableSources, selectedSource: selectedSource, delegate: delegate, context: context))
        
    }
    
    
    
    
    
     func presentCryptoTypeSelection(from view: AccountImportViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)  {
        
    return cuckoo_manager.call(
    """
    presentCryptoTypeSelection(from: AccountImportViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """,
            parameters: (view, availableTypes, selectedType, delegate, context),
            escapingParameters: (view, availableTypes, selectedType, delegate, context),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentCryptoTypeSelection(from: view, availableTypes: availableTypes, selectedType: selectedType, delegate: delegate, context: context))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_AccountImportWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showSecondStep<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, with data: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountImportViewProtocol?, AccountCreationStep.FirstStepData)> where M1.OptionalMatchedType == AccountImportViewProtocol, M2.MatchedType == AccountCreationStep.FirstStepData {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportViewProtocol?, AccountCreationStep.FirstStepData)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: data) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportWireframeProtocol.self, method:
    """
    showSecondStep(from: AccountImportViewProtocol?, with: AccountCreationStep.FirstStepData)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, flow: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountImportViewProtocol?, AccountImportFlow)> where M1.OptionalMatchedType == AccountImportViewProtocol, M2.MatchedType == AccountImportFlow {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportViewProtocol?, AccountImportFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportWireframeProtocol.self, method:
    """
    proceed(from: AccountImportViewProtocol?, flow: AccountImportFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentSourceTypeSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.OptionalMatchable>(from view: M1, availableSources: M2, selectedSource: M3, delegate: M4, context: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountImportViewProtocol?, [AccountImportSource], AccountImportSource, ModalPickerViewControllerDelegate?, AnyObject?)> where M1.OptionalMatchedType == AccountImportViewProtocol, M2.MatchedType == [AccountImportSource], M3.MatchedType == AccountImportSource, M4.OptionalMatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportViewProtocol?, [AccountImportSource], AccountImportSource, ModalPickerViewControllerDelegate?, AnyObject?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: availableSources) { $0.1 }, wrap(matchable: selectedSource) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: context) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportWireframeProtocol.self, method:
    """
    presentSourceTypeSelection(from: AccountImportViewProtocol?, availableSources: [AccountImportSource], selectedSource: AccountImportSource, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentCryptoTypeSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.OptionalMatchable>(from view: M1, availableTypes: M2, selectedType: M3, delegate: M4, context: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountImportViewProtocol?, [CryptoType], CryptoType, ModalPickerViewControllerDelegate?, AnyObject?)> where M1.OptionalMatchedType == AccountImportViewProtocol, M2.MatchedType == [CryptoType], M3.MatchedType == CryptoType, M4.OptionalMatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportViewProtocol?, [CryptoType], CryptoType, ModalPickerViewControllerDelegate?, AnyObject?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: availableTypes) { $0.1 }, wrap(matchable: selectedType) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: context) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportWireframeProtocol.self, method:
    """
    presentCryptoTypeSelection(from: AccountImportViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountImportWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountImportWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showSecondStep<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, with data: M2) -> Cuckoo.__DoNotUse<(AccountImportViewProtocol?, AccountCreationStep.FirstStepData), Void> where M1.OptionalMatchedType == AccountImportViewProtocol, M2.MatchedType == AccountCreationStep.FirstStepData {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportViewProtocol?, AccountCreationStep.FirstStepData)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: data) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showSecondStep(from: AccountImportViewProtocol?, with: AccountCreationStep.FirstStepData)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, flow: M2) -> Cuckoo.__DoNotUse<(AccountImportViewProtocol?, AccountImportFlow), Void> where M1.OptionalMatchedType == AccountImportViewProtocol, M2.MatchedType == AccountImportFlow {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportViewProtocol?, AccountImportFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }]
            return cuckoo_manager.verify(
    """
    proceed(from: AccountImportViewProtocol?, flow: AccountImportFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentSourceTypeSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.OptionalMatchable>(from view: M1, availableSources: M2, selectedSource: M3, delegate: M4, context: M5) -> Cuckoo.__DoNotUse<(AccountImportViewProtocol?, [AccountImportSource], AccountImportSource, ModalPickerViewControllerDelegate?, AnyObject?), Void> where M1.OptionalMatchedType == AccountImportViewProtocol, M2.MatchedType == [AccountImportSource], M3.MatchedType == AccountImportSource, M4.OptionalMatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportViewProtocol?, [AccountImportSource], AccountImportSource, ModalPickerViewControllerDelegate?, AnyObject?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: availableSources) { $0.1 }, wrap(matchable: selectedSource) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: context) { $0.4 }]
            return cuckoo_manager.verify(
    """
    presentSourceTypeSelection(from: AccountImportViewProtocol?, availableSources: [AccountImportSource], selectedSource: AccountImportSource, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentCryptoTypeSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.OptionalMatchable>(from view: M1, availableTypes: M2, selectedType: M3, delegate: M4, context: M5) -> Cuckoo.__DoNotUse<(AccountImportViewProtocol?, [CryptoType], CryptoType, ModalPickerViewControllerDelegate?, AnyObject?), Void> where M1.OptionalMatchedType == AccountImportViewProtocol, M2.MatchedType == [CryptoType], M3.MatchedType == CryptoType, M4.OptionalMatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<(AccountImportViewProtocol?, [CryptoType], CryptoType, ModalPickerViewControllerDelegate?, AnyObject?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: availableTypes) { $0.1 }, wrap(matchable: selectedType) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: context) { $0.4 }]
            return cuckoo_manager.verify(
    """
    presentCryptoTypeSelection(from: AccountImportViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountImportWireframeProtocolStub: AccountImportWireframeProtocol {
    

    

    
    
    
    
     func showSecondStep(from view: AccountImportViewProtocol?, with data: AccountCreationStep.FirstStepData)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed(from view: AccountImportViewProtocol?, flow: AccountImportFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentSourceTypeSelection(from view: AccountImportViewProtocol?, availableSources: [AccountImportSource], selectedSource: AccountImportSource, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentCryptoTypeSelection(from view: AccountImportViewProtocol?, availableTypes: [CryptoType], selectedType: CryptoType, delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import RobinHood






 class MockAccountManagementViewProtocol: AccountManagementViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountManagementViewProtocol
    
     typealias Stubbing = __StubbingProxy_AccountManagementViewProtocol
     typealias Verification = __VerificationProxy_AccountManagementViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountManagementViewProtocol?

     func enableDefaultImplementation(_ stub: AccountManagementViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func reload()  {
        
    return cuckoo_manager.call(
    """
    reload()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload())
        
    }
    
    
    
    
    
     func didRemoveItem(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    didRemoveItem(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRemoveItem(at: index))
        
    }
    
    

     struct __StubbingProxy_AccountManagementViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountManagementViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountManagementViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func reload() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementViewProtocol.self, method:
    """
    reload()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didRemoveItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementViewProtocol.self, method:
    """
    didRemoveItem(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountManagementViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func reload() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    reload()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didRemoveItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    didRemoveItem(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountManagementViewProtocolStub: AccountManagementViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func reload()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didRemoveItem(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountManagementPresenterProtocol: AccountManagementPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountManagementPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_AccountManagementPresenterProtocol
     typealias Verification = __VerificationProxy_AccountManagementPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountManagementPresenterProtocol?

     func enableDefaultImplementation(_ stub: AccountManagementPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func numberOfItems() -> Int {
        
    return cuckoo_manager.call(
    """
    numberOfItems() -> Int
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.numberOfItems())
        
    }
    
    
    
    
    
     func item(at index: Int) -> ManagedAccountViewModelItem {
        
    return cuckoo_manager.call(
    """
    item(at: Int) -> ManagedAccountViewModelItem
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.item(at: index))
        
    }
    
    
    
    
    
     func activateWalletDetails(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    activateWalletDetails(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateWalletDetails(at: index))
        
    }
    
    
    
    
    
     func activateAddAccount()  {
        
    return cuckoo_manager.call(
    """
    activateAddAccount()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateAddAccount())
        
    }
    
    
    
    
    
     func selectItem(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    selectItem(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectItem(at: index))
        
    }
    
    
    
    
    
     func moveItem(at startIndex: Int, to finalIndex: Int)  {
        
    return cuckoo_manager.call(
    """
    moveItem(at: Int, to: Int)
    """,
            parameters: (startIndex, finalIndex),
            escapingParameters: (startIndex, finalIndex),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.moveItem(at: startIndex, to: finalIndex))
        
    }
    
    
    
    
    
     func removeItem(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    removeItem(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.removeItem(at: index))
        
    }
    
    
    
    
    
     func didTapCloseButton()  {
        
    return cuckoo_manager.call(
    """
    didTapCloseButton()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didTapCloseButton())
        
    }
    
    

     struct __StubbingProxy_AccountManagementPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func numberOfItems() -> Cuckoo.ProtocolStubFunction<(), Int> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementPresenterProtocol.self, method:
    """
    numberOfItems() -> Int
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func item<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubFunction<(Int), ManagedAccountViewModelItem> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementPresenterProtocol.self, method:
    """
    item(at: Int) -> ManagedAccountViewModelItem
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateWalletDetails<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementPresenterProtocol.self, method:
    """
    activateWalletDetails(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateAddAccount() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementPresenterProtocol.self, method:
    """
    activateAddAccount()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementPresenterProtocol.self, method:
    """
    selectItem(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func moveItem<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(at startIndex: M1, to finalIndex: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(Int, Int)> where M1.MatchedType == Int, M2.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int, Int)>] = [wrap(matchable: startIndex) { $0.0 }, wrap(matchable: finalIndex) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementPresenterProtocol.self, method:
    """
    moveItem(at: Int, to: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func removeItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementPresenterProtocol.self, method:
    """
    removeItem(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didTapCloseButton() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementPresenterProtocol.self, method:
    """
    didTapCloseButton()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountManagementPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func numberOfItems() -> Cuckoo.__DoNotUse<(), Int> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    numberOfItems() -> Int
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func item<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), ManagedAccountViewModelItem> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    item(at: Int) -> ManagedAccountViewModelItem
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateWalletDetails<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    activateWalletDetails(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateAddAccount() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateAddAccount()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    selectItem(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func moveItem<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(at startIndex: M1, to finalIndex: M2) -> Cuckoo.__DoNotUse<(Int, Int), Void> where M1.MatchedType == Int, M2.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int, Int)>] = [wrap(matchable: startIndex) { $0.0 }, wrap(matchable: finalIndex) { $0.1 }]
            return cuckoo_manager.verify(
    """
    moveItem(at: Int, to: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func removeItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    removeItem(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didTapCloseButton() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didTapCloseButton()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountManagementPresenterProtocolStub: AccountManagementPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func numberOfItems() -> Int  {
        return DefaultValueRegistry.defaultValue(for: (Int).self)
    }
    
    
    
    
    
     func item(at index: Int) -> ManagedAccountViewModelItem  {
        return DefaultValueRegistry.defaultValue(for: (ManagedAccountViewModelItem).self)
    }
    
    
    
    
    
     func activateWalletDetails(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateAddAccount()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectItem(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func moveItem(at startIndex: Int, to finalIndex: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func removeItem(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didTapCloseButton()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountManagementInteractorInputProtocol: AccountManagementInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountManagementInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountManagementInteractorInputProtocol
     typealias Verification = __VerificationProxy_AccountManagementInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountManagementInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: AccountManagementInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func select(item: ManagedMetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    select(item: ManagedMetaAccountModel)
    """,
            parameters: (item),
            escapingParameters: (item),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.select(item: item))
        
    }
    
    
    
    
    
     func save(items: [ManagedMetaAccountModel])  {
        
    return cuckoo_manager.call(
    """
    save(items: [ManagedMetaAccountModel])
    """,
            parameters: (items),
            escapingParameters: (items),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.save(items: items))
        
    }
    
    
    
    
    
     func remove(item: ManagedMetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    remove(item: ManagedMetaAccountModel)
    """,
            parameters: (item),
            escapingParameters: (item),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.remove(item: item))
        
    }
    
    
    
    
    
     func update(item: ManagedMetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    update(item: ManagedMetaAccountModel)
    """,
            parameters: (item),
            escapingParameters: (item),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.update(item: item))
        
    }
    
    

     struct __StubbingProxy_AccountManagementInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func select<M1: Cuckoo.Matchable>(item: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ManagedMetaAccountModel)> where M1.MatchedType == ManagedMetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ManagedMetaAccountModel)>] = [wrap(matchable: item) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementInteractorInputProtocol.self, method:
    """
    select(item: ManagedMetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func save<M1: Cuckoo.Matchable>(items: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([ManagedMetaAccountModel])> where M1.MatchedType == [ManagedMetaAccountModel] {
            let matchers: [Cuckoo.ParameterMatcher<([ManagedMetaAccountModel])>] = [wrap(matchable: items) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementInteractorInputProtocol.self, method:
    """
    save(items: [ManagedMetaAccountModel])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func remove<M1: Cuckoo.Matchable>(item: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ManagedMetaAccountModel)> where M1.MatchedType == ManagedMetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ManagedMetaAccountModel)>] = [wrap(matchable: item) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementInteractorInputProtocol.self, method:
    """
    remove(item: ManagedMetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func update<M1: Cuckoo.Matchable>(item: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ManagedMetaAccountModel)> where M1.MatchedType == ManagedMetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ManagedMetaAccountModel)>] = [wrap(matchable: item) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementInteractorInputProtocol.self, method:
    """
    update(item: ManagedMetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountManagementInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func select<M1: Cuckoo.Matchable>(item: M1) -> Cuckoo.__DoNotUse<(ManagedMetaAccountModel), Void> where M1.MatchedType == ManagedMetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ManagedMetaAccountModel)>] = [wrap(matchable: item) { $0 }]
            return cuckoo_manager.verify(
    """
    select(item: ManagedMetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func save<M1: Cuckoo.Matchable>(items: M1) -> Cuckoo.__DoNotUse<([ManagedMetaAccountModel]), Void> where M1.MatchedType == [ManagedMetaAccountModel] {
            let matchers: [Cuckoo.ParameterMatcher<([ManagedMetaAccountModel])>] = [wrap(matchable: items) { $0 }]
            return cuckoo_manager.verify(
    """
    save(items: [ManagedMetaAccountModel])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func remove<M1: Cuckoo.Matchable>(item: M1) -> Cuckoo.__DoNotUse<(ManagedMetaAccountModel), Void> where M1.MatchedType == ManagedMetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ManagedMetaAccountModel)>] = [wrap(matchable: item) { $0 }]
            return cuckoo_manager.verify(
    """
    remove(item: ManagedMetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func update<M1: Cuckoo.Matchable>(item: M1) -> Cuckoo.__DoNotUse<(ManagedMetaAccountModel), Void> where M1.MatchedType == ManagedMetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ManagedMetaAccountModel)>] = [wrap(matchable: item) { $0 }]
            return cuckoo_manager.verify(
    """
    update(item: ManagedMetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountManagementInteractorInputProtocolStub: AccountManagementInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func select(item: ManagedMetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func save(items: [ManagedMetaAccountModel])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func remove(item: ManagedMetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func update(item: ManagedMetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountManagementInteractorOutputProtocol: AccountManagementInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountManagementInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountManagementInteractorOutputProtocol
     typealias Verification = __VerificationProxy_AccountManagementInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountManagementInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: AccountManagementInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didCompleteSelection(of metaAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    didCompleteSelection(of: MetaAccountModel)
    """,
            parameters: (metaAccount),
            escapingParameters: (metaAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didCompleteSelection(of: metaAccount))
        
    }
    
    
    
    
    
     func didReceive(changes: [DataProviderChange<ManagedMetaAccountModel>])  {
        
    return cuckoo_manager.call(
    """
    didReceive(changes: [DataProviderChange<ManagedMetaAccountModel>])
    """,
            parameters: (changes),
            escapingParameters: (changes),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(changes: changes))
        
    }
    
    
    
    
    
     func didReceive(error: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(error: Error)
    """,
            parameters: (error),
            escapingParameters: (error),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(error: error))
        
    }
    
    

     struct __StubbingProxy_AccountManagementInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didCompleteSelection<M1: Cuckoo.Matchable>(of metaAccount: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(MetaAccountModel)> where M1.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel)>] = [wrap(matchable: metaAccount) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementInteractorOutputProtocol.self, method:
    """
    didCompleteSelection(of: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(changes: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([DataProviderChange<ManagedMetaAccountModel>])> where M1.MatchedType == [DataProviderChange<ManagedMetaAccountModel>] {
            let matchers: [Cuckoo.ParameterMatcher<([DataProviderChange<ManagedMetaAccountModel>])>] = [wrap(matchable: changes) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementInteractorOutputProtocol.self, method:
    """
    didReceive(changes: [DataProviderChange<ManagedMetaAccountModel>])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementInteractorOutputProtocol.self, method:
    """
    didReceive(error: Error)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountManagementInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didCompleteSelection<M1: Cuckoo.Matchable>(of metaAccount: M1) -> Cuckoo.__DoNotUse<(MetaAccountModel), Void> where M1.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel)>] = [wrap(matchable: metaAccount) { $0 }]
            return cuckoo_manager.verify(
    """
    didCompleteSelection(of: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(changes: M1) -> Cuckoo.__DoNotUse<([DataProviderChange<ManagedMetaAccountModel>]), Void> where M1.MatchedType == [DataProviderChange<ManagedMetaAccountModel>] {
            let matchers: [Cuckoo.ParameterMatcher<([DataProviderChange<ManagedMetaAccountModel>])>] = [wrap(matchable: changes) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(changes: [DataProviderChange<ManagedMetaAccountModel>])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(error: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountManagementInteractorOutputProtocolStub: AccountManagementInteractorOutputProtocol {
    

    

    
    
    
    
     func didCompleteSelection(of metaAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(changes: [DataProviderChange<ManagedMetaAccountModel>])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(error: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountManagementWireframeProtocol: AccountManagementWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountManagementWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_AccountManagementWireframeProtocol
     typealias Verification = __VerificationProxy_AccountManagementWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountManagementWireframeProtocol?

     func enableDefaultImplementation(_ stub: AccountManagementWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showAccountDetails(from view: AccountManagementViewProtocol?, metaAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showAccountDetails(from: AccountManagementViewProtocol?, metaAccount: MetaAccountModel)
    """,
            parameters: (view, metaAccount),
            escapingParameters: (view, metaAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showAccountDetails(from: view, metaAccount: metaAccount))
        
    }
    
    
    
    
    
     func showAddAccount(from view: AccountManagementViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showAddAccount(from: AccountManagementViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showAddAccount(from: view))
        
    }
    
    
    
    
    
     func complete(from view: AccountManagementViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    complete(from: AccountManagementViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(from: view))
        
    }
    
    
    
    
    
     func showWalletSettings(from view: AccountManagementViewProtocol?, items: [WalletSettingsRow], callback: @escaping ModalPickerSelectionCallback)  {
        
    return cuckoo_manager.call(
    """
    showWalletSettings(from: AccountManagementViewProtocol?, items: [WalletSettingsRow], callback: @escaping ModalPickerSelectionCallback)
    """,
            parameters: (view, items, callback),
            escapingParameters: (view, items, callback),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWalletSettings(from: view, items: items, callback: callback))
        
    }
    
    
    
    
    
     func showSelectAccounts(from view: AccountManagementViewProtocol?, managedMetaAccountModel: ManagedMetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showSelectAccounts(from: AccountManagementViewProtocol?, managedMetaAccountModel: ManagedMetaAccountModel)
    """,
            parameters: (view, managedMetaAccountModel),
            escapingParameters: (view, managedMetaAccountModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showSelectAccounts(from: view, managedMetaAccountModel: managedMetaAccountModel))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_AccountManagementWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showAccountDetails<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, metaAccount: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountManagementViewProtocol?, MetaAccountModel)> where M1.OptionalMatchedType == AccountManagementViewProtocol, M2.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: metaAccount) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementWireframeProtocol.self, method:
    """
    showAccountDetails(from: AccountManagementViewProtocol?, metaAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showAddAccount<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountManagementViewProtocol?)> where M1.OptionalMatchedType == AccountManagementViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementWireframeProtocol.self, method:
    """
    showAddAccount(from: AccountManagementViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountManagementViewProtocol?)> where M1.OptionalMatchedType == AccountManagementViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementWireframeProtocol.self, method:
    """
    complete(from: AccountManagementViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWalletSettings<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, items: M2, callback: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountManagementViewProtocol?, [WalletSettingsRow], ModalPickerSelectionCallback)> where M1.OptionalMatchedType == AccountManagementViewProtocol, M2.MatchedType == [WalletSettingsRow], M3.MatchedType == ModalPickerSelectionCallback {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?, [WalletSettingsRow], ModalPickerSelectionCallback)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: items) { $0.1 }, wrap(matchable: callback) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementWireframeProtocol.self, method:
    """
    showWalletSettings(from: AccountManagementViewProtocol?, items: [WalletSettingsRow], callback: @escaping ModalPickerSelectionCallback)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showSelectAccounts<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, managedMetaAccountModel: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountManagementViewProtocol?, ManagedMetaAccountModel)> where M1.OptionalMatchedType == AccountManagementViewProtocol, M2.MatchedType == ManagedMetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?, ManagedMetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: managedMetaAccountModel) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementWireframeProtocol.self, method:
    """
    showSelectAccounts(from: AccountManagementViewProtocol?, managedMetaAccountModel: ManagedMetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountManagementWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountManagementWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showAccountDetails<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, metaAccount: M2) -> Cuckoo.__DoNotUse<(AccountManagementViewProtocol?, MetaAccountModel), Void> where M1.OptionalMatchedType == AccountManagementViewProtocol, M2.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: metaAccount) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showAccountDetails(from: AccountManagementViewProtocol?, metaAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showAddAccount<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(AccountManagementViewProtocol?), Void> where M1.OptionalMatchedType == AccountManagementViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showAddAccount(from: AccountManagementViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(AccountManagementViewProtocol?), Void> where M1.OptionalMatchedType == AccountManagementViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    complete(from: AccountManagementViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWalletSettings<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, items: M2, callback: M3) -> Cuckoo.__DoNotUse<(AccountManagementViewProtocol?, [WalletSettingsRow], ModalPickerSelectionCallback), Void> where M1.OptionalMatchedType == AccountManagementViewProtocol, M2.MatchedType == [WalletSettingsRow], M3.MatchedType == ModalPickerSelectionCallback {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?, [WalletSettingsRow], ModalPickerSelectionCallback)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: items) { $0.1 }, wrap(matchable: callback) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWalletSettings(from: AccountManagementViewProtocol?, items: [WalletSettingsRow], callback: @escaping ModalPickerSelectionCallback)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showSelectAccounts<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, managedMetaAccountModel: M2) -> Cuckoo.__DoNotUse<(AccountManagementViewProtocol?, ManagedMetaAccountModel), Void> where M1.OptionalMatchedType == AccountManagementViewProtocol, M2.MatchedType == ManagedMetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountManagementViewProtocol?, ManagedMetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: managedMetaAccountModel) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showSelectAccounts(from: AccountManagementViewProtocol?, managedMetaAccountModel: ManagedMetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountManagementWireframeProtocolStub: AccountManagementWireframeProtocol {
    

    

    
    
    
    
     func showAccountDetails(from view: AccountManagementViewProtocol?, metaAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showAddAccount(from view: AccountManagementViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func complete(from view: AccountManagementViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWalletSettings(from view: AccountManagementViewProtocol?, items: [WalletSettingsRow], callback: @escaping ModalPickerSelectionCallback)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showSelectAccounts(from view: AccountManagementViewProtocol?, managedMetaAccountModel: ManagedMetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless






 class MockAssetSelectionWireframeProtocol: AssetSelectionWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AssetSelectionWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_AssetSelectionWireframeProtocol
     typealias Verification = __VerificationProxy_AssetSelectionWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AssetSelectionWireframeProtocol?

     func enableDefaultImplementation(_ stub: AssetSelectionWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(on view: ChainSelectionViewProtocol, selecting chainAsset: ChainAsset, context: Any?)  {
        
    return cuckoo_manager.call(
    """
    complete(on: ChainSelectionViewProtocol, selecting: ChainAsset, context: Any?)
    """,
            parameters: (view, chainAsset, context),
            escapingParameters: (view, chainAsset, context),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(on: view, selecting: chainAsset, context: context))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_AssetSelectionWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(on view: M1, selecting chainAsset: M2, context: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainSelectionViewProtocol, ChainAsset, Any?)> where M1.MatchedType == ChainSelectionViewProtocol, M2.MatchedType == ChainAsset, M3.OptionalMatchedType == Any {
            let matchers: [Cuckoo.ParameterMatcher<(ChainSelectionViewProtocol, ChainAsset, Any?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: context) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAssetSelectionWireframeProtocol.self, method:
    """
    complete(on: ChainSelectionViewProtocol, selecting: ChainAsset, context: Any?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAssetSelectionWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAssetSelectionWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAssetSelectionWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AssetSelectionWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(on view: M1, selecting chainAsset: M2, context: M3) -> Cuckoo.__DoNotUse<(ChainSelectionViewProtocol, ChainAsset, Any?), Void> where M1.MatchedType == ChainSelectionViewProtocol, M2.MatchedType == ChainAsset, M3.OptionalMatchedType == Any {
            let matchers: [Cuckoo.ParameterMatcher<(ChainSelectionViewProtocol, ChainAsset, Any?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: context) { $0.2 }]
            return cuckoo_manager.verify(
    """
    complete(on: ChainSelectionViewProtocol, selecting: ChainAsset, context: Any?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AssetSelectionWireframeProtocolStub: AssetSelectionWireframeProtocol {
    

    

    
    
    
    
     func complete(on view: ChainSelectionViewProtocol, selecting chainAsset: ChainAsset, context: Any?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAssetSelectionDelegate: AssetSelectionDelegate, Cuckoo.ProtocolMock {
    
     typealias MocksType = AssetSelectionDelegate
    
     typealias Stubbing = __StubbingProxy_AssetSelectionDelegate
     typealias Verification = __VerificationProxy_AssetSelectionDelegate

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AssetSelectionDelegate?

     func enableDefaultImplementation(_ stub: AssetSelectionDelegate) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func assetSelection(view: ChainSelectionViewProtocol, didCompleteWith chainAsset: ChainAsset, context: Any?)  {
        
    return cuckoo_manager.call(
    """
    assetSelection(view: ChainSelectionViewProtocol, didCompleteWith: ChainAsset, context: Any?)
    """,
            parameters: (view, chainAsset, context),
            escapingParameters: (view, chainAsset, context),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.assetSelection(view: view, didCompleteWith: chainAsset, context: context))
        
    }
    
    

     struct __StubbingProxy_AssetSelectionDelegate: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func assetSelection<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(view: M1, didCompleteWith chainAsset: M2, context: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainSelectionViewProtocol, ChainAsset, Any?)> where M1.MatchedType == ChainSelectionViewProtocol, M2.MatchedType == ChainAsset, M3.OptionalMatchedType == Any {
            let matchers: [Cuckoo.ParameterMatcher<(ChainSelectionViewProtocol, ChainAsset, Any?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: context) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAssetSelectionDelegate.self, method:
    """
    assetSelection(view: ChainSelectionViewProtocol, didCompleteWith: ChainAsset, context: Any?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AssetSelectionDelegate: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func assetSelection<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(view: M1, didCompleteWith chainAsset: M2, context: M3) -> Cuckoo.__DoNotUse<(ChainSelectionViewProtocol, ChainAsset, Any?), Void> where M1.MatchedType == ChainSelectionViewProtocol, M2.MatchedType == ChainAsset, M3.OptionalMatchedType == Any {
            let matchers: [Cuckoo.ParameterMatcher<(ChainSelectionViewProtocol, ChainAsset, Any?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: context) { $0.2 }]
            return cuckoo_manager.verify(
    """
    assetSelection(view: ChainSelectionViewProtocol, didCompleteWith: ChainAsset, context: Any?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AssetSelectionDelegateStub: AssetSelectionDelegate {
    

    

    
    
    
    
     func assetSelection(view: ChainSelectionViewProtocol, didCompleteWith chainAsset: ChainAsset, context: Any?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless






 class MockChainSelectionViewProtocol: ChainSelectionViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ChainSelectionViewProtocol
    
     typealias Stubbing = __StubbingProxy_ChainSelectionViewProtocol
     typealias Verification = __VerificationProxy_ChainSelectionViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ChainSelectionViewProtocol?

     func enableDefaultImplementation(_ stub: ChainSelectionViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func didReload()  {
        
    return cuckoo_manager.call(
    """
    didReload()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReload())
        
    }
    
    
    
    
    
     func bind(viewModel: TextSearchViewModel?)  {
        
    return cuckoo_manager.call(
    """
    bind(viewModel: TextSearchViewModel?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.bind(viewModel: viewModel))
        
    }
    
    
    
    
    
     func reloadCell(at indexPath: IndexPath)  {
        
    return cuckoo_manager.call(
    """
    reloadCell(at: IndexPath)
    """,
            parameters: (indexPath),
            escapingParameters: (indexPath),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reloadCell(at: indexPath))
        
    }
    
    

     struct __StubbingProxy_ChainSelectionViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockChainSelectionViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockChainSelectionViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func didReload() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionViewProtocol.self, method:
    """
    didReload()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func bind<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(TextSearchViewModel?)> where M1.OptionalMatchedType == TextSearchViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(TextSearchViewModel?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionViewProtocol.self, method:
    """
    bind(viewModel: TextSearchViewModel?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func reloadCell<M1: Cuckoo.Matchable>(at indexPath: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(IndexPath)> where M1.MatchedType == IndexPath {
            let matchers: [Cuckoo.ParameterMatcher<(IndexPath)>] = [wrap(matchable: indexPath) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionViewProtocol.self, method:
    """
    reloadCell(at: IndexPath)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ChainSelectionViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReload() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didReload()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func bind<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(TextSearchViewModel?), Void> where M1.OptionalMatchedType == TextSearchViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(TextSearchViewModel?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    bind(viewModel: TextSearchViewModel?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func reloadCell<M1: Cuckoo.Matchable>(at indexPath: M1) -> Cuckoo.__DoNotUse<(IndexPath), Void> where M1.MatchedType == IndexPath {
            let matchers: [Cuckoo.ParameterMatcher<(IndexPath)>] = [wrap(matchable: indexPath) { $0 }]
            return cuckoo_manager.verify(
    """
    reloadCell(at: IndexPath)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ChainSelectionViewProtocolStub: ChainSelectionViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReload()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func bind(viewModel: TextSearchViewModel?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func reloadCell(at indexPath: IndexPath)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockChainSelectionPresenterProtocol: ChainSelectionPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ChainSelectionPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_ChainSelectionPresenterProtocol
     typealias Verification = __VerificationProxy_ChainSelectionPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ChainSelectionPresenterProtocol?

     func enableDefaultImplementation(_ stub: ChainSelectionPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var numberOfItems: Int {
        get {
            return cuckoo_manager.getter("numberOfItems",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.numberOfItems)
        }
        
    }
    
    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func item(at index: Int) -> SelectableViewModelProtocol {
        
    return cuckoo_manager.call(
    """
    item(at: Int) -> SelectableViewModelProtocol
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.item(at: index))
        
    }
    
    
    
    
    
     func selectItem(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    selectItem(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectItem(at: index))
        
    }
    
    
    
    
    
     func searchItem(with text: String?)  {
        
    return cuckoo_manager.call(
    """
    searchItem(with: String?)
    """,
            parameters: (text),
            escapingParameters: (text),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.searchItem(with: text))
        
    }
    
    

     struct __StubbingProxy_ChainSelectionPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var numberOfItems: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockChainSelectionPresenterProtocol, Int> {
            return .init(manager: cuckoo_manager, name: "numberOfItems")
        }
        
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func item<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubFunction<(Int), SelectableViewModelProtocol> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionPresenterProtocol.self, method:
    """
    item(at: Int) -> SelectableViewModelProtocol
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionPresenterProtocol.self, method:
    """
    selectItem(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func searchItem<M1: Cuckoo.OptionalMatchable>(with text: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String?)> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: text) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionPresenterProtocol.self, method:
    """
    searchItem(with: String?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ChainSelectionPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var numberOfItems: Cuckoo.VerifyReadOnlyProperty<Int> {
            return .init(manager: cuckoo_manager, name: "numberOfItems", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func item<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), SelectableViewModelProtocol> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    item(at: Int) -> SelectableViewModelProtocol
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    selectItem(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func searchItem<M1: Cuckoo.OptionalMatchable>(with text: M1) -> Cuckoo.__DoNotUse<(String?), Void> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: text) { $0 }]
            return cuckoo_manager.verify(
    """
    searchItem(with: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ChainSelectionPresenterProtocolStub: ChainSelectionPresenterProtocol {
    
    
    
    
     var numberOfItems: Int {
        get {
            return DefaultValueRegistry.defaultValue(for: (Int).self)
        }
        
    }
    
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func item(at index: Int) -> SelectableViewModelProtocol  {
        return DefaultValueRegistry.defaultValue(for: (SelectableViewModelProtocol).self)
    }
    
    
    
    
    
     func selectItem(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func searchItem(with text: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockChainSelectionInteractorInputProtocol: ChainSelectionInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ChainSelectionInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_ChainSelectionInteractorInputProtocol
     typealias Verification = __VerificationProxy_ChainSelectionInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ChainSelectionInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: ChainSelectionInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    

     struct __StubbingProxy_ChainSelectionInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ChainSelectionInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ChainSelectionInteractorInputProtocolStub: ChainSelectionInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockChainSelectionInteractorOutputProtocol: ChainSelectionInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ChainSelectionInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_ChainSelectionInteractorOutputProtocol
     typealias Verification = __VerificationProxy_ChainSelectionInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ChainSelectionInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: ChainSelectionInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceiveChains(result: Result<[ChainModel], Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveChains(result: Result<[ChainModel], Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveChains(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>, for chainAssetKey: ChainAssetKey)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>, for: ChainAssetKey)
    """,
            parameters: (result, chainAssetKey),
            escapingParameters: (result, chainAssetKey),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result, for: chainAssetKey))
        
    }
    
    

     struct __StubbingProxy_ChainSelectionInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceiveChains<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<[ChainModel], Error>)> where M1.MatchedType == Result<[ChainModel], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[ChainModel], Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionInteractorOutputProtocol.self, method:
    """
    didReceiveChains(result: Result<[ChainModel], Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(result: M1, for chainAssetKey: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>, ChainAssetKey)> where M1.MatchedType == Result<AccountInfo?, Error>, M2.MatchedType == ChainAssetKey {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>, ChainAssetKey)>] = [wrap(matchable: result) { $0.0 }, wrap(matchable: chainAssetKey) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>, for: ChainAssetKey)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ChainSelectionInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceiveChains<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<[ChainModel], Error>), Void> where M1.MatchedType == Result<[ChainModel], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[ChainModel], Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveChains(result: Result<[ChainModel], Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(result: M1, for chainAssetKey: M2) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>, ChainAssetKey), Void> where M1.MatchedType == Result<AccountInfo?, Error>, M2.MatchedType == ChainAssetKey {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>, ChainAssetKey)>] = [wrap(matchable: result) { $0.0 }, wrap(matchable: chainAssetKey) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>, for: ChainAssetKey)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ChainSelectionInteractorOutputProtocolStub: ChainSelectionInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceiveChains(result: Result<[ChainModel], Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>, for chainAssetKey: ChainAssetKey)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockChainSelectionWireframeProtocol: ChainSelectionWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ChainSelectionWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ChainSelectionWireframeProtocol
     typealias Verification = __VerificationProxy_ChainSelectionWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ChainSelectionWireframeProtocol?

     func enableDefaultImplementation(_ stub: ChainSelectionWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(on view: ChainSelectionViewProtocol, selecting chain: ChainModel?)  {
        
    return cuckoo_manager.call(
    """
    complete(on: ChainSelectionViewProtocol, selecting: ChainModel?)
    """,
            parameters: (view, chain),
            escapingParameters: (view, chain),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(on: view, selecting: chain))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_ChainSelectionWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(on view: M1, selecting chain: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainSelectionViewProtocol, ChainModel?)> where M1.MatchedType == ChainSelectionViewProtocol, M2.OptionalMatchedType == ChainModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChainSelectionViewProtocol, ChainModel?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chain) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionWireframeProtocol.self, method:
    """
    complete(on: ChainSelectionViewProtocol, selecting: ChainModel?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ChainSelectionWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(on view: M1, selecting chain: M2) -> Cuckoo.__DoNotUse<(ChainSelectionViewProtocol, ChainModel?), Void> where M1.MatchedType == ChainSelectionViewProtocol, M2.OptionalMatchedType == ChainModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChainSelectionViewProtocol, ChainModel?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chain) { $0.1 }]
            return cuckoo_manager.verify(
    """
    complete(on: ChainSelectionViewProtocol, selecting: ChainModel?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ChainSelectionWireframeProtocolStub: ChainSelectionWireframeProtocol {
    

    

    
    
    
    
     func complete(on view: ChainSelectionViewProtocol, selecting chain: ChainModel?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockChainSelectionDelegate: ChainSelectionDelegate, Cuckoo.ProtocolMock {
    
     typealias MocksType = ChainSelectionDelegate
    
     typealias Stubbing = __StubbingProxy_ChainSelectionDelegate
     typealias Verification = __VerificationProxy_ChainSelectionDelegate

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ChainSelectionDelegate?

     func enableDefaultImplementation(_ stub: ChainSelectionDelegate) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func chainSelection(view: ChainSelectionViewProtocol, didCompleteWith chain: ChainModel?)  {
        
    return cuckoo_manager.call(
    """
    chainSelection(view: ChainSelectionViewProtocol, didCompleteWith: ChainModel?)
    """,
            parameters: (view, chain),
            escapingParameters: (view, chain),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.chainSelection(view: view, didCompleteWith: chain))
        
    }
    
    

     struct __StubbingProxy_ChainSelectionDelegate: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func chainSelection<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(view: M1, didCompleteWith chain: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainSelectionViewProtocol, ChainModel?)> where M1.MatchedType == ChainSelectionViewProtocol, M2.OptionalMatchedType == ChainModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChainSelectionViewProtocol, ChainModel?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chain) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockChainSelectionDelegate.self, method:
    """
    chainSelection(view: ChainSelectionViewProtocol, didCompleteWith: ChainModel?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ChainSelectionDelegate: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func chainSelection<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(view: M1, didCompleteWith chain: M2) -> Cuckoo.__DoNotUse<(ChainSelectionViewProtocol, ChainModel?), Void> where M1.MatchedType == ChainSelectionViewProtocol, M2.OptionalMatchedType == ChainModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChainSelectionViewProtocol, ChainModel?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chain) { $0.1 }]
            return cuckoo_manager.verify(
    """
    chainSelection(view: ChainSelectionViewProtocol, didCompleteWith: ChainModel?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ChainSelectionDelegateStub: ChainSelectionDelegate {
    

    

    
    
    
    
     func chainSelection(view: ChainSelectionViewProtocol, didCompleteWith chain: ChainModel?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import Foundation






 class MockCrowdloanContributionInteractorInputProtocol: CrowdloanContributionInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionInteractorInputProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(for amount: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(for: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)
    """,
            parameters: (amount, bonusService),
            escapingParameters: (amount, bonusService),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(for: amount, bonusService: bonusService))
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(for amount: M1, bonusService: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(BigUInt, CrowdloanBonusServiceProtocol?)> where M1.MatchedType == BigUInt, M2.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: amount) { $0.0 }, wrap(matchable: bonusService) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorInputProtocol.self, method:
    """
    estimateFee(for: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(for amount: M1, bonusService: M2) -> Cuckoo.__DoNotUse<(BigUInt, CrowdloanBonusServiceProtocol?), Void> where M1.MatchedType == BigUInt, M2.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: amount) { $0.0 }, wrap(matchable: bonusService) { $0.1 }]
            return cuckoo_manager.verify(
    """
    estimateFee(for: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionInteractorInputProtocolStub: CrowdloanContributionInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(for amount: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanContributionInteractorOutputProtocol: CrowdloanContributionInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionInteractorOutputProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceiveCrowdloan(result: Result<Crowdloan, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCrowdloan(result: Result<Crowdloan, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCrowdloan(result: result))
        
    }
    
    
    
    
    
     func didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveDisplayInfo(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result))
        
    }
    
    
    
    
    
     func didReceiveBlockNumber(result: Result<BlockNumber?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBlockNumber(result: result))
        
    }
    
    
    
    
    
     func didReceiveBlockDuration(result: Result<BlockTime, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBlockDuration(result: result))
        
    }
    
    
    
    
    
     func didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLeasingPeriod(result: result))
        
    }
    
    
    
    
    
     func didReceiveMinimumBalance(result: Result<BigUInt, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMinimumBalance(result: Result<BigUInt, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMinimumBalance(result: result))
        
    }
    
    
    
    
    
     func didReceiveMinimumContribution(result: Result<BigUInt, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMinimumContribution(result: Result<BigUInt, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMinimumContribution(result: result))
        
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(result: result))
        
    }
    
    
    
    
    
     func didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLeasingOffset(result: result))
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<Crowdloan, Error>)> where M1.MatchedType == Result<Crowdloan, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<Crowdloan, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveCrowdloan(result: Result<Crowdloan, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveDisplayInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<CrowdloanDisplayInfo?, Error>)> where M1.MatchedType == Result<CrowdloanDisplayInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanDisplayInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>)> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBlockNumber<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BlockNumber?, Error>)> where M1.MatchedType == Result<BlockNumber?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockNumber?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBlockDuration<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BlockTime, Error>)> where M1.MatchedType == Result<BlockTime, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockTime, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveLeasingPeriod<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<LeasingPeriod, Error>)> where M1.MatchedType == Result<LeasingPeriod, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingPeriod, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMinimumBalance<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BigUInt, Error>)> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveMinimumBalance(result: Result<BigUInt, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMinimumContribution<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BigUInt, Error>)> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveMinimumContribution(result: Result<BigUInt, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RuntimeDispatchInfo, Error>)> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveLeasingOffset<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<LeasingOffset, Error>)> where M1.MatchedType == Result<LeasingOffset, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingOffset, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionInteractorOutputProtocol.self, method:
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<Crowdloan, Error>), Void> where M1.MatchedType == Result<Crowdloan, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<Crowdloan, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCrowdloan(result: Result<Crowdloan, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveDisplayInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<CrowdloanDisplayInfo?, Error>), Void> where M1.MatchedType == Result<CrowdloanDisplayInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanDisplayInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>), Void> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBlockNumber<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BlockNumber?, Error>), Void> where M1.MatchedType == Result<BlockNumber?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockNumber?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBlockDuration<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BlockTime, Error>), Void> where M1.MatchedType == Result<BlockTime, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockTime, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveLeasingPeriod<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<LeasingPeriod, Error>), Void> where M1.MatchedType == Result<LeasingPeriod, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingPeriod, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMinimumBalance<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BigUInt, Error>), Void> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMinimumBalance(result: Result<BigUInt, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMinimumContribution<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BigUInt, Error>), Void> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMinimumContribution(result: Result<BigUInt, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RuntimeDispatchInfo, Error>), Void> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveLeasingOffset<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<LeasingOffset, Error>), Void> where M1.MatchedType == Result<LeasingOffset, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingOffset, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionInteractorOutputProtocolStub: CrowdloanContributionInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceiveCrowdloan(result: Result<Crowdloan, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBlockNumber(result: Result<BlockNumber?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBlockDuration(result: Result<BlockTime, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMinimumBalance(result: Result<BigUInt, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMinimumContribution(result: Result<BigUInt, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import SoraFoundation






 class MockCrowdloanContributionConfirmViewProtocol: CrowdloanContributionConfirmViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionConfirmViewProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionConfirmViewProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionConfirmViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionConfirmViewProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionConfirmViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAsset(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: BalanceViewModelProtocol?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: BalanceViewModelProtocol?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveCrowdloan(viewModel: CrowdloanContributeConfirmViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCrowdloan(viewModel: CrowdloanContributeConfirmViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCrowdloan(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveEstimatedReward(viewModel: String?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveEstimatedReward(viewModel: String?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveEstimatedReward(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveBonus(viewModel: String?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBonus(viewModel: String?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBonus(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionConfirmViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCrowdloanContributionConfirmViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCrowdloanContributionConfirmViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockCrowdloanContributionConfirmViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCrowdloanContributionConfirmViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCrowdloanContributionConfirmViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AssetBalanceViewModelProtocol)> where M1.MatchedType == AssetBalanceViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AssetBalanceViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmViewProtocol.self, method:
    """
    didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(BalanceViewModelProtocol?)> where M1.OptionalMatchedType == BalanceViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BalanceViewModelProtocol?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmViewProtocol.self, method:
    """
    didReceiveFee(viewModel: BalanceViewModelProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanContributeConfirmViewModel)> where M1.MatchedType == CrowdloanContributeConfirmViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributeConfirmViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmViewProtocol.self, method:
    """
    didReceiveCrowdloan(viewModel: CrowdloanContributeConfirmViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveEstimatedReward<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String?)> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmViewProtocol.self, method:
    """
    didReceiveEstimatedReward(viewModel: String?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBonus<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String?)> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmViewProtocol.self, method:
    """
    didReceiveBonus(viewModel: String?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionConfirmViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(AssetBalanceViewModelProtocol), Void> where M1.MatchedType == AssetBalanceViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AssetBalanceViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(BalanceViewModelProtocol?), Void> where M1.OptionalMatchedType == BalanceViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BalanceViewModelProtocol?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: BalanceViewModelProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(CrowdloanContributeConfirmViewModel), Void> where M1.MatchedType == CrowdloanContributeConfirmViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributeConfirmViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCrowdloan(viewModel: CrowdloanContributeConfirmViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveEstimatedReward<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(String?), Void> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveEstimatedReward(viewModel: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBonus<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(String?), Void> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBonus(viewModel: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionConfirmViewProtocolStub: CrowdloanContributionConfirmViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: BalanceViewModelProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveCrowdloan(viewModel: CrowdloanContributeConfirmViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveEstimatedReward(viewModel: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBonus(viewModel: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanContributionConfirmPresenterProtocol: CrowdloanContributionConfirmPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionConfirmPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionConfirmPresenterProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionConfirmPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionConfirmPresenterProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionConfirmPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func confirm()  {
        
    return cuckoo_manager.call(
    """
    confirm()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm())
        
    }
    
    
    
    
    
     func presentAccountOptions()  {
        
    return cuckoo_manager.call(
    """
    presentAccountOptions()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentAccountOptions())
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionConfirmPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func confirm() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmPresenterProtocol.self, method:
    """
    confirm()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentAccountOptions() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmPresenterProtocol.self, method:
    """
    presentAccountOptions()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionConfirmPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func confirm() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    confirm()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentAccountOptions() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentAccountOptions()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionConfirmPresenterProtocolStub: CrowdloanContributionConfirmPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func confirm()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentAccountOptions()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanContributionConfirmInteractorInputProtocol: CrowdloanContributionConfirmInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionConfirmInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionConfirmInteractorInputProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionConfirmInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionConfirmInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionConfirmInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func estimateFee(for contribution: BigUInt)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(for: BigUInt)
    """,
            parameters: (contribution),
            escapingParameters: (contribution),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(for: contribution))
        
    }
    
    
    
    
    
     func submit(contribution: BigUInt)  {
        
    return cuckoo_manager.call(
    """
    submit(contribution: BigUInt)
    """,
            parameters: (contribution),
            escapingParameters: (contribution),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.submit(contribution: contribution))
        
    }
    
    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(for amount: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(for: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)
    """,
            parameters: (amount, bonusService),
            escapingParameters: (amount, bonusService),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(for: amount, bonusService: bonusService))
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionConfirmInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.Matchable>(for contribution: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(BigUInt)> where M1.MatchedType == BigUInt {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt)>] = [wrap(matchable: contribution) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorInputProtocol.self, method:
    """
    estimateFee(for: BigUInt)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func submit<M1: Cuckoo.Matchable>(contribution: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(BigUInt)> where M1.MatchedType == BigUInt {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt)>] = [wrap(matchable: contribution) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorInputProtocol.self, method:
    """
    submit(contribution: BigUInt)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(for amount: M1, bonusService: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(BigUInt, CrowdloanBonusServiceProtocol?)> where M1.MatchedType == BigUInt, M2.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: amount) { $0.0 }, wrap(matchable: bonusService) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorInputProtocol.self, method:
    """
    estimateFee(for: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionConfirmInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.Matchable>(for contribution: M1) -> Cuckoo.__DoNotUse<(BigUInt), Void> where M1.MatchedType == BigUInt {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt)>] = [wrap(matchable: contribution) { $0 }]
            return cuckoo_manager.verify(
    """
    estimateFee(for: BigUInt)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func submit<M1: Cuckoo.Matchable>(contribution: M1) -> Cuckoo.__DoNotUse<(BigUInt), Void> where M1.MatchedType == BigUInt {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt)>] = [wrap(matchable: contribution) { $0 }]
            return cuckoo_manager.verify(
    """
    submit(contribution: BigUInt)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(for amount: M1, bonusService: M2) -> Cuckoo.__DoNotUse<(BigUInt, CrowdloanBonusServiceProtocol?), Void> where M1.MatchedType == BigUInt, M2.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: amount) { $0.0 }, wrap(matchable: bonusService) { $0.1 }]
            return cuckoo_manager.verify(
    """
    estimateFee(for: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionConfirmInteractorInputProtocolStub: CrowdloanContributionConfirmInteractorInputProtocol {
    

    

    
    
    
    
     func estimateFee(for contribution: BigUInt)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func submit(contribution: BigUInt)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(for amount: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanContributionConfirmInteractorOutputProtocol: CrowdloanContributionConfirmInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionConfirmInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionConfirmInteractorOutputProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionConfirmInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionConfirmInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionConfirmInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didSubmitContribution(result: Result<String, Error>)  {
        
    return cuckoo_manager.call(
    """
    didSubmitContribution(result: Result<String, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSubmitContribution(result: result))
        
    }
    
    
    
    
    
     func didReceiveDisplayAddress(result: Result<DisplayAddress, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveDisplayAddress(result: Result<DisplayAddress, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveDisplayAddress(result: result))
        
    }
    
    
    
    
    
     func didReceiveCrowdloan(result: Result<Crowdloan, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCrowdloan(result: Result<Crowdloan, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCrowdloan(result: result))
        
    }
    
    
    
    
    
     func didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveDisplayInfo(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result))
        
    }
    
    
    
    
    
     func didReceiveBlockNumber(result: Result<BlockNumber?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBlockNumber(result: result))
        
    }
    
    
    
    
    
     func didReceiveBlockDuration(result: Result<BlockTime, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBlockDuration(result: result))
        
    }
    
    
    
    
    
     func didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLeasingPeriod(result: result))
        
    }
    
    
    
    
    
     func didReceiveMinimumBalance(result: Result<BigUInt, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMinimumBalance(result: Result<BigUInt, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMinimumBalance(result: result))
        
    }
    
    
    
    
    
     func didReceiveMinimumContribution(result: Result<BigUInt, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMinimumContribution(result: Result<BigUInt, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMinimumContribution(result: result))
        
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(result: result))
        
    }
    
    
    
    
    
     func didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLeasingOffset(result: result))
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionConfirmInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didSubmitContribution<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<String, Error>)> where M1.MatchedType == Result<String, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<String, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didSubmitContribution(result: Result<String, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveDisplayAddress<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<DisplayAddress, Error>)> where M1.MatchedType == Result<DisplayAddress, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<DisplayAddress, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveDisplayAddress(result: Result<DisplayAddress, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<Crowdloan, Error>)> where M1.MatchedType == Result<Crowdloan, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<Crowdloan, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveCrowdloan(result: Result<Crowdloan, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveDisplayInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<CrowdloanDisplayInfo?, Error>)> where M1.MatchedType == Result<CrowdloanDisplayInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanDisplayInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>)> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBlockNumber<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BlockNumber?, Error>)> where M1.MatchedType == Result<BlockNumber?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockNumber?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBlockDuration<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BlockTime, Error>)> where M1.MatchedType == Result<BlockTime, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockTime, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveLeasingPeriod<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<LeasingPeriod, Error>)> where M1.MatchedType == Result<LeasingPeriod, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingPeriod, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMinimumBalance<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BigUInt, Error>)> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveMinimumBalance(result: Result<BigUInt, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMinimumContribution<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BigUInt, Error>)> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveMinimumContribution(result: Result<BigUInt, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RuntimeDispatchInfo, Error>)> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveLeasingOffset<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<LeasingOffset, Error>)> where M1.MatchedType == Result<LeasingOffset, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingOffset, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionConfirmInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didSubmitContribution<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<String, Error>), Void> where M1.MatchedType == Result<String, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<String, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didSubmitContribution(result: Result<String, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveDisplayAddress<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<DisplayAddress, Error>), Void> where M1.MatchedType == Result<DisplayAddress, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<DisplayAddress, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveDisplayAddress(result: Result<DisplayAddress, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<Crowdloan, Error>), Void> where M1.MatchedType == Result<Crowdloan, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<Crowdloan, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCrowdloan(result: Result<Crowdloan, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveDisplayInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<CrowdloanDisplayInfo?, Error>), Void> where M1.MatchedType == Result<CrowdloanDisplayInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanDisplayInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>), Void> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBlockNumber<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BlockNumber?, Error>), Void> where M1.MatchedType == Result<BlockNumber?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockNumber?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBlockDuration<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BlockTime, Error>), Void> where M1.MatchedType == Result<BlockTime, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockTime, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveLeasingPeriod<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<LeasingPeriod, Error>), Void> where M1.MatchedType == Result<LeasingPeriod, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingPeriod, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMinimumBalance<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BigUInt, Error>), Void> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMinimumBalance(result: Result<BigUInt, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMinimumContribution<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BigUInt, Error>), Void> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMinimumContribution(result: Result<BigUInt, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RuntimeDispatchInfo, Error>), Void> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveLeasingOffset<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<LeasingOffset, Error>), Void> where M1.MatchedType == Result<LeasingOffset, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingOffset, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionConfirmInteractorOutputProtocolStub: CrowdloanContributionConfirmInteractorOutputProtocol {
    

    

    
    
    
    
     func didSubmitContribution(result: Result<String, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveDisplayAddress(result: Result<DisplayAddress, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveCrowdloan(result: Result<Crowdloan, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBlockNumber(result: Result<BlockNumber?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBlockDuration(result: Result<BlockTime, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMinimumBalance(result: Result<BigUInt, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMinimumContribution(result: Result<BigUInt, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanContributionConfirmWireframeProtocol: CrowdloanContributionConfirmWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionConfirmWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionConfirmWireframeProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionConfirmWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionConfirmWireframeProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionConfirmWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(on view: CrowdloanContributionConfirmViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    complete(on: CrowdloanContributionConfirmViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(on: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionConfirmWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.OptionalMatchable>(on view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanContributionConfirmViewProtocol?)> where M1.OptionalMatchedType == CrowdloanContributionConfirmViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributionConfirmViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmWireframeProtocol.self, method:
    """
    complete(on: CrowdloanContributionConfirmViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionConfirmWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionConfirmWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.OptionalMatchable>(on view: M1) -> Cuckoo.__DoNotUse<(CrowdloanContributionConfirmViewProtocol?), Void> where M1.OptionalMatchedType == CrowdloanContributionConfirmViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributionConfirmViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    complete(on: CrowdloanContributionConfirmViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionConfirmWireframeProtocolStub: CrowdloanContributionConfirmWireframeProtocol {
    

    

    
    
    
    
     func complete(on view: CrowdloanContributionConfirmViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import CommonWallet
import Foundation
import SoraFoundation






 class MockCrowdloanContributionSetupViewProtocol: CrowdloanContributionSetupViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionSetupViewProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionSetupViewProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionSetupViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionSetupViewProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionSetupViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAsset(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: BalanceViewModelProtocol?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: BalanceViewModelProtocol?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveInput(viewModel: IAmountInputViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveInput(viewModel: IAmountInputViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveInput(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveCrowdloan(viewModel: CrowdloanContributionSetupViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCrowdloan(viewModel: CrowdloanContributionSetupViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCrowdloan(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveEstimatedReward(viewModel: String?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveEstimatedReward(viewModel: String?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveEstimatedReward(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveBonus(viewModel: String?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBonus(viewModel: String?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBonus(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionSetupViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCrowdloanContributionSetupViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCrowdloanContributionSetupViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockCrowdloanContributionSetupViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AssetBalanceViewModelProtocol)> where M1.MatchedType == AssetBalanceViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AssetBalanceViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupViewProtocol.self, method:
    """
    didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(BalanceViewModelProtocol?)> where M1.OptionalMatchedType == BalanceViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BalanceViewModelProtocol?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupViewProtocol.self, method:
    """
    didReceiveFee(viewModel: BalanceViewModelProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(IAmountInputViewModel)> where M1.MatchedType == IAmountInputViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(IAmountInputViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupViewProtocol.self, method:
    """
    didReceiveInput(viewModel: IAmountInputViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanContributionSetupViewModel)> where M1.MatchedType == CrowdloanContributionSetupViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributionSetupViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupViewProtocol.self, method:
    """
    didReceiveCrowdloan(viewModel: CrowdloanContributionSetupViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveEstimatedReward<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String?)> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupViewProtocol.self, method:
    """
    didReceiveEstimatedReward(viewModel: String?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBonus<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String?)> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupViewProtocol.self, method:
    """
    didReceiveBonus(viewModel: String?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionSetupViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(AssetBalanceViewModelProtocol), Void> where M1.MatchedType == AssetBalanceViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(AssetBalanceViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(BalanceViewModelProtocol?), Void> where M1.OptionalMatchedType == BalanceViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BalanceViewModelProtocol?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: BalanceViewModelProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(IAmountInputViewModel), Void> where M1.MatchedType == IAmountInputViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(IAmountInputViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveInput(viewModel: IAmountInputViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(CrowdloanContributionSetupViewModel), Void> where M1.MatchedType == CrowdloanContributionSetupViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributionSetupViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCrowdloan(viewModel: CrowdloanContributionSetupViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveEstimatedReward<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(String?), Void> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveEstimatedReward(viewModel: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBonus<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(String?), Void> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBonus(viewModel: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionSetupViewProtocolStub: CrowdloanContributionSetupViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didReceiveAsset(viewModel: AssetBalanceViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: BalanceViewModelProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveInput(viewModel: IAmountInputViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveCrowdloan(viewModel: CrowdloanContributionSetupViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveEstimatedReward(viewModel: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBonus(viewModel: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanContributionSetupPresenterProtocol: CrowdloanContributionSetupPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionSetupPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionSetupPresenterProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionSetupPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionSetupPresenterProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionSetupPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)  {
        
    return cuckoo_manager.call(
    """
    selectAmountPercentage(_: Float)
    """,
            parameters: (percentage),
            escapingParameters: (percentage),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectAmountPercentage(percentage))
        
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)  {
        
    return cuckoo_manager.call(
    """
    updateAmount(_: Decimal)
    """,
            parameters: (newValue),
            escapingParameters: (newValue),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.updateAmount(newValue))
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    
    
    
    
     func presentLearnMore()  {
        
    return cuckoo_manager.call(
    """
    presentLearnMore()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentLearnMore())
        
    }
    
    
    
    
    
     func presentAdditionalBonuses()  {
        
    return cuckoo_manager.call(
    """
    presentAdditionalBonuses()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentAdditionalBonuses())
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionSetupPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Float)> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupPresenterProtocol.self, method:
    """
    selectAmountPercentage(_: Float)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Decimal)> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupPresenterProtocol.self, method:
    """
    updateAmount(_: Decimal)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentLearnMore() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupPresenterProtocol.self, method:
    """
    presentLearnMore()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentAdditionalBonuses() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupPresenterProtocol.self, method:
    """
    presentAdditionalBonuses()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionSetupPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.__DoNotUse<(Float), Void> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return cuckoo_manager.verify(
    """
    selectAmountPercentage(_: Float)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.__DoNotUse<(Decimal), Void> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return cuckoo_manager.verify(
    """
    updateAmount(_: Decimal)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentLearnMore() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentLearnMore()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentAdditionalBonuses() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentAdditionalBonuses()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionSetupPresenterProtocolStub: CrowdloanContributionSetupPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentLearnMore()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentAdditionalBonuses()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanContributionSetupInteractorInputProtocol: CrowdloanContributionSetupInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionSetupInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionSetupInteractorInputProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionSetupInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionSetupInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionSetupInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(for amount: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(for: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)
    """,
            parameters: (amount, bonusService),
            escapingParameters: (amount, bonusService),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(for: amount, bonusService: bonusService))
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionSetupInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(for amount: M1, bonusService: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(BigUInt, CrowdloanBonusServiceProtocol?)> where M1.MatchedType == BigUInt, M2.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: amount) { $0.0 }, wrap(matchable: bonusService) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorInputProtocol.self, method:
    """
    estimateFee(for: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionSetupInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(for amount: M1, bonusService: M2) -> Cuckoo.__DoNotUse<(BigUInt, CrowdloanBonusServiceProtocol?), Void> where M1.MatchedType == BigUInt, M2.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(BigUInt, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: amount) { $0.0 }, wrap(matchable: bonusService) { $0.1 }]
            return cuckoo_manager.verify(
    """
    estimateFee(for: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionSetupInteractorInputProtocolStub: CrowdloanContributionSetupInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(for amount: BigUInt, bonusService: CrowdloanBonusServiceProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanContributionSetupInteractorOutputProtocol: CrowdloanContributionSetupInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionSetupInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionSetupInteractorOutputProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionSetupInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionSetupInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionSetupInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceiveCrowdloan(result: Result<Crowdloan, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCrowdloan(result: Result<Crowdloan, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCrowdloan(result: result))
        
    }
    
    
    
    
    
     func didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveDisplayInfo(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result))
        
    }
    
    
    
    
    
     func didReceiveBlockNumber(result: Result<BlockNumber?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBlockNumber(result: result))
        
    }
    
    
    
    
    
     func didReceiveBlockDuration(result: Result<BlockTime, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBlockDuration(result: result))
        
    }
    
    
    
    
    
     func didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLeasingPeriod(result: result))
        
    }
    
    
    
    
    
     func didReceiveMinimumBalance(result: Result<BigUInt, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMinimumBalance(result: Result<BigUInt, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMinimumBalance(result: result))
        
    }
    
    
    
    
    
     func didReceiveMinimumContribution(result: Result<BigUInt, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMinimumContribution(result: Result<BigUInt, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMinimumContribution(result: result))
        
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(result: result))
        
    }
    
    
    
    
    
     func didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLeasingOffset(result: result))
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionSetupInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<Crowdloan, Error>)> where M1.MatchedType == Result<Crowdloan, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<Crowdloan, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveCrowdloan(result: Result<Crowdloan, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveDisplayInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<CrowdloanDisplayInfo?, Error>)> where M1.MatchedType == Result<CrowdloanDisplayInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanDisplayInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>)> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBlockNumber<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BlockNumber?, Error>)> where M1.MatchedType == Result<BlockNumber?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockNumber?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBlockDuration<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BlockTime, Error>)> where M1.MatchedType == Result<BlockTime, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockTime, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveLeasingPeriod<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<LeasingPeriod, Error>)> where M1.MatchedType == Result<LeasingPeriod, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingPeriod, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMinimumBalance<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BigUInt, Error>)> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveMinimumBalance(result: Result<BigUInt, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMinimumContribution<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BigUInt, Error>)> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveMinimumContribution(result: Result<BigUInt, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RuntimeDispatchInfo, Error>)> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveLeasingOffset<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<LeasingOffset, Error>)> where M1.MatchedType == Result<LeasingOffset, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingOffset, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupInteractorOutputProtocol.self, method:
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionSetupInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceiveCrowdloan<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<Crowdloan, Error>), Void> where M1.MatchedType == Result<Crowdloan, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<Crowdloan, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCrowdloan(result: Result<Crowdloan, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveDisplayInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<CrowdloanDisplayInfo?, Error>), Void> where M1.MatchedType == Result<CrowdloanDisplayInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanDisplayInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>), Void> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBlockNumber<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BlockNumber?, Error>), Void> where M1.MatchedType == Result<BlockNumber?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockNumber?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBlockDuration<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BlockTime, Error>), Void> where M1.MatchedType == Result<BlockTime, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockTime, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveLeasingPeriod<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<LeasingPeriod, Error>), Void> where M1.MatchedType == Result<LeasingPeriod, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingPeriod, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMinimumBalance<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BigUInt, Error>), Void> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMinimumBalance(result: Result<BigUInt, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMinimumContribution<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BigUInt, Error>), Void> where M1.MatchedType == Result<BigUInt, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMinimumContribution(result: Result<BigUInt, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RuntimeDispatchInfo, Error>), Void> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveLeasingOffset<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<LeasingOffset, Error>), Void> where M1.MatchedType == Result<LeasingOffset, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingOffset, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionSetupInteractorOutputProtocolStub: CrowdloanContributionSetupInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceiveCrowdloan(result: Result<Crowdloan, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBlockNumber(result: Result<BlockNumber?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBlockDuration(result: Result<BlockTime, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMinimumBalance(result: Result<BigUInt, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMinimumContribution(result: Result<BigUInt, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanContributionSetupWireframeProtocol: CrowdloanContributionSetupWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanContributionSetupWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanContributionSetupWireframeProtocol
     typealias Verification = __VerificationProxy_CrowdloanContributionSetupWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanContributionSetupWireframeProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanContributionSetupWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showConfirmation(from view: CrowdloanContributionSetupViewProtocol?, paraId: ParaId, inputAmount: Decimal, bonusService: CrowdloanBonusServiceProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showConfirmation(from: CrowdloanContributionSetupViewProtocol?, paraId: ParaId, inputAmount: Decimal, bonusService: CrowdloanBonusServiceProtocol?)
    """,
            parameters: (view, paraId, inputAmount, bonusService),
            escapingParameters: (view, paraId, inputAmount, bonusService),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showConfirmation(from: view, paraId: paraId, inputAmount: inputAmount, bonusService: bonusService))
        
    }
    
    
    
    
    
     func showAdditionalBonus(from view: CrowdloanContributionSetupViewProtocol?, for displayInfo: CrowdloanDisplayInfo, inputAmount: Decimal, delegate: CustomCrowdloanDelegate, existingService: CrowdloanBonusServiceProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showAdditionalBonus(from: CrowdloanContributionSetupViewProtocol?, for: CrowdloanDisplayInfo, inputAmount: Decimal, delegate: CustomCrowdloanDelegate, existingService: CrowdloanBonusServiceProtocol?)
    """,
            parameters: (view, displayInfo, inputAmount, delegate, existingService),
            escapingParameters: (view, displayInfo, inputAmount, delegate, existingService),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showAdditionalBonus(from: view, for: displayInfo, inputAmount: inputAmount, delegate: delegate, existingService: existingService))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    

     struct __StubbingProxy_CrowdloanContributionSetupWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showConfirmation<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(from view: M1, paraId: M2, inputAmount: M3, bonusService: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanContributionSetupViewProtocol?, ParaId, Decimal, CrowdloanBonusServiceProtocol?)> where M1.OptionalMatchedType == CrowdloanContributionSetupViewProtocol, M2.MatchedType == ParaId, M3.MatchedType == Decimal, M4.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributionSetupViewProtocol?, ParaId, Decimal, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: paraId) { $0.1 }, wrap(matchable: inputAmount) { $0.2 }, wrap(matchable: bonusService) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupWireframeProtocol.self, method:
    """
    showConfirmation(from: CrowdloanContributionSetupViewProtocol?, paraId: ParaId, inputAmount: Decimal, bonusService: CrowdloanBonusServiceProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showAdditionalBonus<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable>(from view: M1, for displayInfo: M2, inputAmount: M3, delegate: M4, existingService: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanContributionSetupViewProtocol?, CrowdloanDisplayInfo, Decimal, CustomCrowdloanDelegate, CrowdloanBonusServiceProtocol?)> where M1.OptionalMatchedType == CrowdloanContributionSetupViewProtocol, M2.MatchedType == CrowdloanDisplayInfo, M3.MatchedType == Decimal, M4.MatchedType == CustomCrowdloanDelegate, M5.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributionSetupViewProtocol?, CrowdloanDisplayInfo, Decimal, CustomCrowdloanDelegate, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: displayInfo) { $0.1 }, wrap(matchable: inputAmount) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: existingService) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupWireframeProtocol.self, method:
    """
    showAdditionalBonus(from: CrowdloanContributionSetupViewProtocol?, for: CrowdloanDisplayInfo, inputAmount: Decimal, delegate: CustomCrowdloanDelegate, existingService: CrowdloanBonusServiceProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanContributionSetupWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanContributionSetupWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showConfirmation<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(from view: M1, paraId: M2, inputAmount: M3, bonusService: M4) -> Cuckoo.__DoNotUse<(CrowdloanContributionSetupViewProtocol?, ParaId, Decimal, CrowdloanBonusServiceProtocol?), Void> where M1.OptionalMatchedType == CrowdloanContributionSetupViewProtocol, M2.MatchedType == ParaId, M3.MatchedType == Decimal, M4.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributionSetupViewProtocol?, ParaId, Decimal, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: paraId) { $0.1 }, wrap(matchable: inputAmount) { $0.2 }, wrap(matchable: bonusService) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showConfirmation(from: CrowdloanContributionSetupViewProtocol?, paraId: ParaId, inputAmount: Decimal, bonusService: CrowdloanBonusServiceProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showAdditionalBonus<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable>(from view: M1, for displayInfo: M2, inputAmount: M3, delegate: M4, existingService: M5) -> Cuckoo.__DoNotUse<(CrowdloanContributionSetupViewProtocol?, CrowdloanDisplayInfo, Decimal, CustomCrowdloanDelegate, CrowdloanBonusServiceProtocol?), Void> where M1.OptionalMatchedType == CrowdloanContributionSetupViewProtocol, M2.MatchedType == CrowdloanDisplayInfo, M3.MatchedType == Decimal, M4.MatchedType == CustomCrowdloanDelegate, M5.OptionalMatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanContributionSetupViewProtocol?, CrowdloanDisplayInfo, Decimal, CustomCrowdloanDelegate, CrowdloanBonusServiceProtocol?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: displayInfo) { $0.1 }, wrap(matchable: inputAmount) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: existingService) { $0.4 }]
            return cuckoo_manager.verify(
    """
    showAdditionalBonus(from: CrowdloanContributionSetupViewProtocol?, for: CrowdloanDisplayInfo, inputAmount: Decimal, delegate: CustomCrowdloanDelegate, existingService: CrowdloanBonusServiceProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanContributionSetupWireframeProtocolStub: CrowdloanContributionSetupWireframeProtocol {
    

    

    
    
    
    
     func showConfirmation(from view: CrowdloanContributionSetupViewProtocol?, paraId: ParaId, inputAmount: Decimal, bonusService: CrowdloanBonusServiceProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showAdditionalBonus(from view: CrowdloanContributionSetupViewProtocol?, for displayInfo: CrowdloanDisplayInfo, inputAmount: Decimal, delegate: CustomCrowdloanDelegate, existingService: CrowdloanBonusServiceProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockCrowdloanListViewProtocol: CrowdloanListViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanListViewProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanListViewProtocol
     typealias Verification = __VerificationProxy_CrowdloanListViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanListViewProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanListViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(chainInfo: CrowdloansChainViewModel, wikiCrowdloan: LearnMoreViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceive(chainInfo: CrowdloansChainViewModel, wikiCrowdloan: LearnMoreViewModel)
    """,
            parameters: (chainInfo, wikiCrowdloan),
            escapingParameters: (chainInfo, wikiCrowdloan),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(chainInfo: chainInfo, wikiCrowdloan: wikiCrowdloan))
        
    }
    
    
    
    
    
     func didReceive(listState: CrowdloanListState)  {
        
    return cuckoo_manager.call(
    """
    didReceive(listState: CrowdloanListState)
    """,
            parameters: (listState),
            escapingParameters: (listState),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(listState: listState))
        
    }
    
    

     struct __StubbingProxy_CrowdloanListViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCrowdloanListViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCrowdloanListViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(chainInfo: M1, wikiCrowdloan: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloansChainViewModel, LearnMoreViewModel)> where M1.MatchedType == CrowdloansChainViewModel, M2.MatchedType == LearnMoreViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloansChainViewModel, LearnMoreViewModel)>] = [wrap(matchable: chainInfo) { $0.0 }, wrap(matchable: wikiCrowdloan) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListViewProtocol.self, method:
    """
    didReceive(chainInfo: CrowdloansChainViewModel, wikiCrowdloan: LearnMoreViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(listState: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanListState)> where M1.MatchedType == CrowdloanListState {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanListState)>] = [wrap(matchable: listState) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListViewProtocol.self, method:
    """
    didReceive(listState: CrowdloanListState)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanListViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(chainInfo: M1, wikiCrowdloan: M2) -> Cuckoo.__DoNotUse<(CrowdloansChainViewModel, LearnMoreViewModel), Void> where M1.MatchedType == CrowdloansChainViewModel, M2.MatchedType == LearnMoreViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloansChainViewModel, LearnMoreViewModel)>] = [wrap(matchable: chainInfo) { $0.0 }, wrap(matchable: wikiCrowdloan) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didReceive(chainInfo: CrowdloansChainViewModel, wikiCrowdloan: LearnMoreViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(listState: M1) -> Cuckoo.__DoNotUse<(CrowdloanListState), Void> where M1.MatchedType == CrowdloanListState {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanListState)>] = [wrap(matchable: listState) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(listState: CrowdloanListState)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanListViewProtocolStub: CrowdloanListViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(chainInfo: CrowdloansChainViewModel, wikiCrowdloan: LearnMoreViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(listState: CrowdloanListState)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanListPresenterProtocol: CrowdloanListPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanListPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanListPresenterProtocol
     typealias Verification = __VerificationProxy_CrowdloanListPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanListPresenterProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanListPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func refresh(shouldReset: Bool)  {
        
    return cuckoo_manager.call(
    """
    refresh(shouldReset: Bool)
    """,
            parameters: (shouldReset),
            escapingParameters: (shouldReset),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.refresh(shouldReset: shouldReset))
        
    }
    
    
    
    
    
     func selectViewModel(_ viewModel: CrowdloanSectionItem<ActiveCrowdloanViewModel>)  {
        
    return cuckoo_manager.call(
    """
    selectViewModel(_: CrowdloanSectionItem<ActiveCrowdloanViewModel>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectViewModel(viewModel))
        
    }
    
    
    
    
    
     func becomeOnline()  {
        
    return cuckoo_manager.call(
    """
    becomeOnline()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.becomeOnline())
        
    }
    
    
    
    
    
     func putOffline()  {
        
    return cuckoo_manager.call(
    """
    putOffline()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.putOffline())
        
    }
    
    
    
    
    
     func selectChain()  {
        
    return cuckoo_manager.call(
    """
    selectChain()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectChain())
        
    }
    
    
    
    
    
     func selectWiki()  {
        
    return cuckoo_manager.call(
    """
    selectWiki()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectWiki())
        
    }
    
    

     struct __StubbingProxy_CrowdloanListPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func refresh<M1: Cuckoo.Matchable>(shouldReset: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool)> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: shouldReset) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListPresenterProtocol.self, method:
    """
    refresh(shouldReset: Bool)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectViewModel<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanSectionItem<ActiveCrowdloanViewModel>)> where M1.MatchedType == CrowdloanSectionItem<ActiveCrowdloanViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanSectionItem<ActiveCrowdloanViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListPresenterProtocol.self, method:
    """
    selectViewModel(_: CrowdloanSectionItem<ActiveCrowdloanViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func becomeOnline() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListPresenterProtocol.self, method:
    """
    becomeOnline()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func putOffline() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListPresenterProtocol.self, method:
    """
    putOffline()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectChain() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListPresenterProtocol.self, method:
    """
    selectChain()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectWiki() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListPresenterProtocol.self, method:
    """
    selectWiki()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanListPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func refresh<M1: Cuckoo.Matchable>(shouldReset: M1) -> Cuckoo.__DoNotUse<(Bool), Void> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: shouldReset) { $0 }]
            return cuckoo_manager.verify(
    """
    refresh(shouldReset: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectViewModel<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.__DoNotUse<(CrowdloanSectionItem<ActiveCrowdloanViewModel>), Void> where M1.MatchedType == CrowdloanSectionItem<ActiveCrowdloanViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanSectionItem<ActiveCrowdloanViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    selectViewModel(_: CrowdloanSectionItem<ActiveCrowdloanViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func becomeOnline() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    becomeOnline()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func putOffline() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    putOffline()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectChain() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectChain()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectWiki() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectWiki()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanListPresenterProtocolStub: CrowdloanListPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func refresh(shouldReset: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectViewModel(_ viewModel: CrowdloanSectionItem<ActiveCrowdloanViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func becomeOnline()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func putOffline()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectChain()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectWiki()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanListInteractorInputProtocol: CrowdloanListInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanListInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanListInteractorInputProtocol
     typealias Verification = __VerificationProxy_CrowdloanListInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanListInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanListInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func refresh()  {
        
    return cuckoo_manager.call(
    """
    refresh()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.refresh())
        
    }
    
    
    
    
    
     func saveSelected(chainModel: ChainModel)  {
        
    return cuckoo_manager.call(
    """
    saveSelected(chainModel: ChainModel)
    """,
            parameters: (chainModel),
            escapingParameters: (chainModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.saveSelected(chainModel: chainModel))
        
    }
    
    
    
    
    
     func becomeOnline()  {
        
    return cuckoo_manager.call(
    """
    becomeOnline()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.becomeOnline())
        
    }
    
    
    
    
    
     func putOffline()  {
        
    return cuckoo_manager.call(
    """
    putOffline()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.putOffline())
        
    }
    
    

     struct __StubbingProxy_CrowdloanListInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func refresh() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorInputProtocol.self, method:
    """
    refresh()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func saveSelected<M1: Cuckoo.Matchable>(chainModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainModel)> where M1.MatchedType == ChainModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChainModel)>] = [wrap(matchable: chainModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorInputProtocol.self, method:
    """
    saveSelected(chainModel: ChainModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func becomeOnline() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorInputProtocol.self, method:
    """
    becomeOnline()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func putOffline() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorInputProtocol.self, method:
    """
    putOffline()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanListInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func refresh() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    refresh()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func saveSelected<M1: Cuckoo.Matchable>(chainModel: M1) -> Cuckoo.__DoNotUse<(ChainModel), Void> where M1.MatchedType == ChainModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChainModel)>] = [wrap(matchable: chainModel) { $0 }]
            return cuckoo_manager.verify(
    """
    saveSelected(chainModel: ChainModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func becomeOnline() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    becomeOnline()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func putOffline() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    putOffline()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanListInteractorInputProtocolStub: CrowdloanListInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func refresh()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func saveSelected(chainModel: ChainModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func becomeOnline()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func putOffline()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanListInteractorOutputProtocol: CrowdloanListInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanListInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanListInteractorOutputProtocol
     typealias Verification = __VerificationProxy_CrowdloanListInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanListInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanListInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceiveCrowdloans(result: Result<[Crowdloan], Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCrowdloans(result: Result<[Crowdloan], Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCrowdloans(result: result))
        
    }
    
    
    
    
    
     func didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfoDict, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfoDict, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveDisplayInfo(result: result))
        
    }
    
    
    
    
    
     func didReceiveBlockNumber(result: Result<BlockNumber?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBlockNumber(result: result))
        
    }
    
    
    
    
    
     func didReceiveBlockDuration(result: Result<BlockTime, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBlockDuration(result: result))
        
    }
    
    
    
    
    
     func didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLeasingPeriod(result: result))
        
    }
    
    
    
    
    
     func didReceiveContributions(result: Result<CrowdloanContributionDict, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveContributions(result: Result<CrowdloanContributionDict, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveContributions(result: result))
        
    }
    
    
    
    
    
     func didReceiveLeaseInfo(result: Result<ParachainLeaseInfoDict, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLeaseInfo(result: Result<ParachainLeaseInfoDict, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLeaseInfo(result: result))
        
    }
    
    
    
    
    
     func didReceiveSelectedChain(result: Result<ChainModel, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveSelectedChain(result: Result<ChainModel, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveSelectedChain(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result))
        
    }
    
    
    
    
    
     func didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLeasingOffset(result: result))
        
    }
    
    

     struct __StubbingProxy_CrowdloanListInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceiveCrowdloans<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<[Crowdloan], Error>)> where M1.MatchedType == Result<[Crowdloan], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[Crowdloan], Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveCrowdloans(result: Result<[Crowdloan], Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveDisplayInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<CrowdloanDisplayInfoDict, Error>)> where M1.MatchedType == Result<CrowdloanDisplayInfoDict, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanDisplayInfoDict, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfoDict, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBlockNumber<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BlockNumber?, Error>)> where M1.MatchedType == Result<BlockNumber?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockNumber?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBlockDuration<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BlockTime, Error>)> where M1.MatchedType == Result<BlockTime, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockTime, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveLeasingPeriod<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<LeasingPeriod, Error>)> where M1.MatchedType == Result<LeasingPeriod, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingPeriod, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveContributions<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<CrowdloanContributionDict, Error>)> where M1.MatchedType == Result<CrowdloanContributionDict, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanContributionDict, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveContributions(result: Result<CrowdloanContributionDict, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveLeaseInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ParachainLeaseInfoDict, Error>)> where M1.MatchedType == Result<ParachainLeaseInfoDict, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ParachainLeaseInfoDict, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveLeaseInfo(result: Result<ParachainLeaseInfoDict, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveSelectedChain<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ChainModel, Error>)> where M1.MatchedType == Result<ChainModel, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainModel, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveSelectedChain(result: Result<ChainModel, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>)> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveLeasingOffset<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<LeasingOffset, Error>)> where M1.MatchedType == Result<LeasingOffset, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingOffset, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListInteractorOutputProtocol.self, method:
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanListInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceiveCrowdloans<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<[Crowdloan], Error>), Void> where M1.MatchedType == Result<[Crowdloan], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[Crowdloan], Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCrowdloans(result: Result<[Crowdloan], Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveDisplayInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<CrowdloanDisplayInfoDict, Error>), Void> where M1.MatchedType == Result<CrowdloanDisplayInfoDict, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanDisplayInfoDict, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfoDict, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBlockNumber<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BlockNumber?, Error>), Void> where M1.MatchedType == Result<BlockNumber?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockNumber?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBlockNumber(result: Result<BlockNumber?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBlockDuration<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BlockTime, Error>), Void> where M1.MatchedType == Result<BlockTime, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BlockTime, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBlockDuration(result: Result<BlockTime, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveLeasingPeriod<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<LeasingPeriod, Error>), Void> where M1.MatchedType == Result<LeasingPeriod, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingPeriod, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveContributions<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<CrowdloanContributionDict, Error>), Void> where M1.MatchedType == Result<CrowdloanContributionDict, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<CrowdloanContributionDict, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveContributions(result: Result<CrowdloanContributionDict, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveLeaseInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ParachainLeaseInfoDict, Error>), Void> where M1.MatchedType == Result<ParachainLeaseInfoDict, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ParachainLeaseInfoDict, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLeaseInfo(result: Result<ParachainLeaseInfoDict, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveSelectedChain<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ChainModel, Error>), Void> where M1.MatchedType == Result<ChainModel, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainModel, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveSelectedChain(result: Result<ChainModel, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>), Void> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveLeasingOffset<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<LeasingOffset, Error>), Void> where M1.MatchedType == Result<LeasingOffset, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<LeasingOffset, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanListInteractorOutputProtocolStub: CrowdloanListInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceiveCrowdloans(result: Result<[Crowdloan], Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveDisplayInfo(result: Result<CrowdloanDisplayInfoDict, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBlockNumber(result: Result<BlockNumber?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBlockDuration(result: Result<BlockTime, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveLeasingPeriod(result: Result<LeasingPeriod, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveContributions(result: Result<CrowdloanContributionDict, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveLeaseInfo(result: Result<ParachainLeaseInfoDict, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveSelectedChain(result: Result<ChainModel, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveLeasingOffset(result: Result<LeasingOffset, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCrowdloanListWireframeProtocol: CrowdloanListWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CrowdloanListWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_CrowdloanListWireframeProtocol
     typealias Verification = __VerificationProxy_CrowdloanListWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CrowdloanListWireframeProtocol?

     func enableDefaultImplementation(_ stub: CrowdloanListWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func presentContributionSetup(from view: CrowdloanListViewProtocol?, paraId: ParaId)  {
        
    return cuckoo_manager.call(
    """
    presentContributionSetup(from: CrowdloanListViewProtocol?, paraId: ParaId)
    """,
            parameters: (view, paraId),
            escapingParameters: (view, paraId),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentContributionSetup(from: view, paraId: paraId))
        
    }
    
    
    
    
    
     func selectChain(from view: CrowdloanListViewProtocol?, delegate: ChainSelectionDelegate, selectedChainId: ChainModel.Id?)  {
        
    return cuckoo_manager.call(
    """
    selectChain(from: CrowdloanListViewProtocol?, delegate: ChainSelectionDelegate, selectedChainId: ChainModel.Id?)
    """,
            parameters: (view, delegate, selectedChainId),
            escapingParameters: (view, delegate, selectedChainId),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectChain(from: view, delegate: delegate, selectedChainId: selectedChainId))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    

     struct __StubbingProxy_CrowdloanListWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func presentContributionSetup<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, paraId: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanListViewProtocol?, ParaId)> where M1.OptionalMatchedType == CrowdloanListViewProtocol, M2.MatchedType == ParaId {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanListViewProtocol?, ParaId)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: paraId) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListWireframeProtocol.self, method:
    """
    presentContributionSetup(from: CrowdloanListViewProtocol?, paraId: ParaId)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectChain<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(from view: M1, delegate: M2, selectedChainId: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanListViewProtocol?, ChainSelectionDelegate, ChainModel.Id?)> where M1.OptionalMatchedType == CrowdloanListViewProtocol, M2.MatchedType == ChainSelectionDelegate, M3.OptionalMatchedType == ChainModel.Id {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanListViewProtocol?, ChainSelectionDelegate, ChainModel.Id?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: delegate) { $0.1 }, wrap(matchable: selectedChainId) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListWireframeProtocol.self, method:
    """
    selectChain(from: CrowdloanListViewProtocol?, delegate: ChainSelectionDelegate, selectedChainId: ChainModel.Id?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCrowdloanListWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CrowdloanListWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func presentContributionSetup<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, paraId: M2) -> Cuckoo.__DoNotUse<(CrowdloanListViewProtocol?, ParaId), Void> where M1.OptionalMatchedType == CrowdloanListViewProtocol, M2.MatchedType == ParaId {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanListViewProtocol?, ParaId)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: paraId) { $0.1 }]
            return cuckoo_manager.verify(
    """
    presentContributionSetup(from: CrowdloanListViewProtocol?, paraId: ParaId)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectChain<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(from view: M1, delegate: M2, selectedChainId: M3) -> Cuckoo.__DoNotUse<(CrowdloanListViewProtocol?, ChainSelectionDelegate, ChainModel.Id?), Void> where M1.OptionalMatchedType == CrowdloanListViewProtocol, M2.MatchedType == ChainSelectionDelegate, M3.OptionalMatchedType == ChainModel.Id {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanListViewProtocol?, ChainSelectionDelegate, ChainModel.Id?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: delegate) { $0.1 }, wrap(matchable: selectedChainId) { $0.2 }]
            return cuckoo_manager.verify(
    """
    selectChain(from: CrowdloanListViewProtocol?, delegate: ChainSelectionDelegate, selectedChainId: ChainModel.Id?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CrowdloanListWireframeProtocolStub: CrowdloanListWireframeProtocol {
    

    

    
    
    
    
     func presentContributionSetup(from view: CrowdloanListViewProtocol?, paraId: ParaId)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectChain(from view: CrowdloanListViewProtocol?, delegate: ChainSelectionDelegate, selectedChainId: ChainModel.Id?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation






 class MockCustomCrowdloanDelegate: CustomCrowdloanDelegate, Cuckoo.ProtocolMock {
    
     typealias MocksType = CustomCrowdloanDelegate
    
     typealias Stubbing = __StubbingProxy_CustomCrowdloanDelegate
     typealias Verification = __VerificationProxy_CustomCrowdloanDelegate

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CustomCrowdloanDelegate?

     func enableDefaultImplementation(_ stub: CustomCrowdloanDelegate) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(bonusService: CrowdloanBonusServiceProtocol)  {
        
    return cuckoo_manager.call(
    """
    didReceive(bonusService: CrowdloanBonusServiceProtocol)
    """,
            parameters: (bonusService),
            escapingParameters: (bonusService),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(bonusService: bonusService))
        
    }
    
    

     struct __StubbingProxy_CustomCrowdloanDelegate: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(bonusService: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(CrowdloanBonusServiceProtocol)> where M1.MatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanBonusServiceProtocol)>] = [wrap(matchable: bonusService) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomCrowdloanDelegate.self, method:
    """
    didReceive(bonusService: CrowdloanBonusServiceProtocol)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CustomCrowdloanDelegate: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(bonusService: M1) -> Cuckoo.__DoNotUse<(CrowdloanBonusServiceProtocol), Void> where M1.MatchedType == CrowdloanBonusServiceProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(CrowdloanBonusServiceProtocol)>] = [wrap(matchable: bonusService) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(bonusService: CrowdloanBonusServiceProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CustomCrowdloanDelegateStub: CustomCrowdloanDelegate {
    

    

    
    
    
    
     func didReceive(bonusService: CrowdloanBonusServiceProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockReferralCrowdloanViewProtocol: ReferralCrowdloanViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ReferralCrowdloanViewProtocol
    
     typealias Stubbing = __StubbingProxy_ReferralCrowdloanViewProtocol
     typealias Verification = __VerificationProxy_ReferralCrowdloanViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ReferralCrowdloanViewProtocol?

     func enableDefaultImplementation(_ stub: ReferralCrowdloanViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveLearnMore(viewModel: LearnMoreViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveLearnMore(viewModel: LearnMoreViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveLearnMore(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveReferral(viewModel: ReferralCrowdloanViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveReferral(viewModel: ReferralCrowdloanViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveReferral(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveInput(viewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    didReceiveInput(viewModel: InputViewModelProtocol)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveInput(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveShouldInputCode()  {
        
    return cuckoo_manager.call(
    """
    didReceiveShouldInputCode()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveShouldInputCode())
        
    }
    
    
    
    
    
     func didReceiveShouldAgreeTerms()  {
        
    return cuckoo_manager.call(
    """
    didReceiveShouldAgreeTerms()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveShouldAgreeTerms())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_ReferralCrowdloanViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockReferralCrowdloanViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockReferralCrowdloanViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockReferralCrowdloanViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockReferralCrowdloanViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didReceiveLearnMore<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LearnMoreViewModel)> where M1.MatchedType == LearnMoreViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(LearnMoreViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanViewProtocol.self, method:
    """
    didReceiveLearnMore(viewModel: LearnMoreViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveReferral<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ReferralCrowdloanViewModel)> where M1.MatchedType == ReferralCrowdloanViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ReferralCrowdloanViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanViewProtocol.self, method:
    """
    didReceiveReferral(viewModel: ReferralCrowdloanViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanViewProtocol.self, method:
    """
    didReceiveInput(viewModel: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveShouldInputCode() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanViewProtocol.self, method:
    """
    didReceiveShouldInputCode()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveShouldAgreeTerms() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanViewProtocol.self, method:
    """
    didReceiveShouldAgreeTerms()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ReferralCrowdloanViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveLearnMore<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LearnMoreViewModel), Void> where M1.MatchedType == LearnMoreViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(LearnMoreViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveLearnMore(viewModel: LearnMoreViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveReferral<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(ReferralCrowdloanViewModel), Void> where M1.MatchedType == ReferralCrowdloanViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ReferralCrowdloanViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveReferral(viewModel: ReferralCrowdloanViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveInput(viewModel: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveShouldInputCode() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didReceiveShouldInputCode()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveShouldAgreeTerms() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didReceiveShouldAgreeTerms()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ReferralCrowdloanViewProtocolStub: ReferralCrowdloanViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveLearnMore(viewModel: LearnMoreViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveReferral(viewModel: ReferralCrowdloanViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveInput(viewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveShouldInputCode()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveShouldAgreeTerms()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockReferralCrowdloanPresenterProtocol: ReferralCrowdloanPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ReferralCrowdloanPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_ReferralCrowdloanPresenterProtocol
     typealias Verification = __VerificationProxy_ReferralCrowdloanPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ReferralCrowdloanPresenterProtocol?

     func enableDefaultImplementation(_ stub: ReferralCrowdloanPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func update(referralCode: String)  {
        
    return cuckoo_manager.call(
    """
    update(referralCode: String)
    """,
            parameters: (referralCode),
            escapingParameters: (referralCode),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.update(referralCode: referralCode))
        
    }
    
    
    
    
    
     func applyDefaultCode()  {
        
    return cuckoo_manager.call(
    """
    applyDefaultCode()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyDefaultCode())
        
    }
    
    
    
    
    
     func applyInputCode()  {
        
    return cuckoo_manager.call(
    """
    applyInputCode()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyInputCode())
        
    }
    
    
    
    
    
     func setTermsAgreed(value: Bool)  {
        
    return cuckoo_manager.call(
    """
    setTermsAgreed(value: Bool)
    """,
            parameters: (value),
            escapingParameters: (value),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setTermsAgreed(value: value))
        
    }
    
    
    
    
    
     func presentTerms()  {
        
    return cuckoo_manager.call(
    """
    presentTerms()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentTerms())
        
    }
    
    
    
    
    
     func presentLearnMore()  {
        
    return cuckoo_manager.call(
    """
    presentLearnMore()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentLearnMore())
        
    }
    
    

     struct __StubbingProxy_ReferralCrowdloanPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func update<M1: Cuckoo.Matchable>(referralCode: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String)> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: referralCode) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanPresenterProtocol.self, method:
    """
    update(referralCode: String)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyDefaultCode() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanPresenterProtocol.self, method:
    """
    applyDefaultCode()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyInputCode() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanPresenterProtocol.self, method:
    """
    applyInputCode()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setTermsAgreed<M1: Cuckoo.Matchable>(value: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool)> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: value) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanPresenterProtocol.self, method:
    """
    setTermsAgreed(value: Bool)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentTerms() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanPresenterProtocol.self, method:
    """
    presentTerms()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentLearnMore() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanPresenterProtocol.self, method:
    """
    presentLearnMore()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ReferralCrowdloanPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func update<M1: Cuckoo.Matchable>(referralCode: M1) -> Cuckoo.__DoNotUse<(String), Void> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: referralCode) { $0 }]
            return cuckoo_manager.verify(
    """
    update(referralCode: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyDefaultCode() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyDefaultCode()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyInputCode() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyInputCode()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setTermsAgreed<M1: Cuckoo.Matchable>(value: M1) -> Cuckoo.__DoNotUse<(Bool), Void> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: value) { $0 }]
            return cuckoo_manager.verify(
    """
    setTermsAgreed(value: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentTerms() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentTerms()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentLearnMore() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentLearnMore()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ReferralCrowdloanPresenterProtocolStub: ReferralCrowdloanPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func update(referralCode: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func applyDefaultCode()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func applyInputCode()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setTermsAgreed(value: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentTerms()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentLearnMore()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockReferralCrowdloanWireframeProtocol: ReferralCrowdloanWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ReferralCrowdloanWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ReferralCrowdloanWireframeProtocol
     typealias Verification = __VerificationProxy_ReferralCrowdloanWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ReferralCrowdloanWireframeProtocol?

     func enableDefaultImplementation(_ stub: ReferralCrowdloanWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(on view: ReferralCrowdloanViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    complete(on: ReferralCrowdloanViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(on: view))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_ReferralCrowdloanWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.OptionalMatchable>(on view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ReferralCrowdloanViewProtocol?)> where M1.OptionalMatchedType == ReferralCrowdloanViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ReferralCrowdloanViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanWireframeProtocol.self, method:
    """
    complete(on: ReferralCrowdloanViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockReferralCrowdloanWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ReferralCrowdloanWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.OptionalMatchable>(on view: M1) -> Cuckoo.__DoNotUse<(ReferralCrowdloanViewProtocol?), Void> where M1.OptionalMatchedType == ReferralCrowdloanViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ReferralCrowdloanViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    complete(on: ReferralCrowdloanViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ReferralCrowdloanWireframeProtocolStub: ReferralCrowdloanWireframeProtocol {
    

    

    
    
    
    
     func complete(on view: ReferralCrowdloanViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import SoraFoundation






 class MockAccountExportPasswordViewProtocol: AccountExportPasswordViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountExportPasswordViewProtocol
    
     typealias Stubbing = __StubbingProxy_AccountExportPasswordViewProtocol
     typealias Verification = __VerificationProxy_AccountExportPasswordViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountExportPasswordViewProtocol?

     func enableDefaultImplementation(_ stub: AccountExportPasswordViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func setPasswordInputViewModel(_ viewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    setPasswordInputViewModel(_: InputViewModelProtocol)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setPasswordInputViewModel(viewModel))
        
    }
    
    
    
    
    
     func setPasswordConfirmationViewModel(_ viewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    setPasswordConfirmationViewModel(_: InputViewModelProtocol)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setPasswordConfirmationViewModel(viewModel))
        
    }
    
    
    
    
    
     func set(error: AccountExportPasswordError)  {
        
    return cuckoo_manager.call(
    """
    set(error: AccountExportPasswordError)
    """,
            parameters: (error),
            escapingParameters: (error),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.set(error: error))
        
    }
    
    

     struct __StubbingProxy_AccountExportPasswordViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountExportPasswordViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountExportPasswordViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func setPasswordInputViewModel<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordViewProtocol.self, method:
    """
    setPasswordInputViewModel(_: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setPasswordConfirmationViewModel<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordViewProtocol.self, method:
    """
    setPasswordConfirmationViewModel(_: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func set<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountExportPasswordError)> where M1.MatchedType == AccountExportPasswordError {
            let matchers: [Cuckoo.ParameterMatcher<(AccountExportPasswordError)>] = [wrap(matchable: error) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordViewProtocol.self, method:
    """
    set(error: AccountExportPasswordError)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountExportPasswordViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func setPasswordInputViewModel<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    setPasswordInputViewModel(_: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setPasswordConfirmationViewModel<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    setPasswordConfirmationViewModel(_: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func set<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.__DoNotUse<(AccountExportPasswordError), Void> where M1.MatchedType == AccountExportPasswordError {
            let matchers: [Cuckoo.ParameterMatcher<(AccountExportPasswordError)>] = [wrap(matchable: error) { $0 }]
            return cuckoo_manager.verify(
    """
    set(error: AccountExportPasswordError)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountExportPasswordViewProtocolStub: AccountExportPasswordViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func setPasswordInputViewModel(_ viewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setPasswordConfirmationViewModel(_ viewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func set(error: AccountExportPasswordError)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountExportPasswordPresenterProtocol: AccountExportPasswordPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountExportPasswordPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_AccountExportPasswordPresenterProtocol
     typealias Verification = __VerificationProxy_AccountExportPasswordPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountExportPasswordPresenterProtocol?

     func enableDefaultImplementation(_ stub: AccountExportPasswordPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var flow: ExportFlow {
        get {
            return cuckoo_manager.getter("flow",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.flow)
        }
        
    }
    
    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    

     struct __StubbingProxy_AccountExportPasswordPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var flow: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAccountExportPasswordPresenterProtocol, ExportFlow> {
            return .init(manager: cuckoo_manager, name: "flow")
        }
        
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountExportPasswordPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var flow: Cuckoo.VerifyReadOnlyProperty<ExportFlow> {
            return .init(manager: cuckoo_manager, name: "flow", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountExportPasswordPresenterProtocolStub: AccountExportPasswordPresenterProtocol {
    
    
    
    
     var flow: ExportFlow {
        get {
            return DefaultValueRegistry.defaultValue(for: (ExportFlow).self)
        }
        
    }
    
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountExportPasswordInteractorInputProtocol: AccountExportPasswordInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountExportPasswordInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountExportPasswordInteractorInputProtocol
     typealias Verification = __VerificationProxy_AccountExportPasswordInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountExportPasswordInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: AccountExportPasswordInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func exportWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo], password: String)  {
        
    return cuckoo_manager.call(
    """
    exportWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo], password: String)
    """,
            parameters: (wallet, accounts, password),
            escapingParameters: (wallet, accounts, password),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.exportWallet(wallet: wallet, accounts: accounts, password: password))
        
    }
    
    
    
    
    
     func exportAccount(address: String, password: String, chain: ChainModel, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    exportAccount(address: String, password: String, chain: ChainModel, wallet: MetaAccountModel)
    """,
            parameters: (address, password, chain, wallet),
            escapingParameters: (address, password, chain, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.exportAccount(address: address, password: password, chain: chain, wallet: wallet))
        
    }
    
    

     struct __StubbingProxy_AccountExportPasswordInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func exportWallet<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(wallet: M1, accounts: M2, password: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(MetaAccountModel, [ChainAccountInfo], String)> where M1.MatchedType == MetaAccountModel, M2.MatchedType == [ChainAccountInfo], M3.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel, [ChainAccountInfo], String)>] = [wrap(matchable: wallet) { $0.0 }, wrap(matchable: accounts) { $0.1 }, wrap(matchable: password) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordInteractorInputProtocol.self, method:
    """
    exportWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo], password: String)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func exportAccount<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(address: M1, password: M2, chain: M3, wallet: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(String, String, ChainModel, MetaAccountModel)> where M1.MatchedType == String, M2.MatchedType == String, M3.MatchedType == ChainModel, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(String, String, ChainModel, MetaAccountModel)>] = [wrap(matchable: address) { $0.0 }, wrap(matchable: password) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordInteractorInputProtocol.self, method:
    """
    exportAccount(address: String, password: String, chain: ChainModel, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountExportPasswordInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func exportWallet<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(wallet: M1, accounts: M2, password: M3) -> Cuckoo.__DoNotUse<(MetaAccountModel, [ChainAccountInfo], String), Void> where M1.MatchedType == MetaAccountModel, M2.MatchedType == [ChainAccountInfo], M3.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel, [ChainAccountInfo], String)>] = [wrap(matchable: wallet) { $0.0 }, wrap(matchable: accounts) { $0.1 }, wrap(matchable: password) { $0.2 }]
            return cuckoo_manager.verify(
    """
    exportWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo], password: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func exportAccount<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(address: M1, password: M2, chain: M3, wallet: M4) -> Cuckoo.__DoNotUse<(String, String, ChainModel, MetaAccountModel), Void> where M1.MatchedType == String, M2.MatchedType == String, M3.MatchedType == ChainModel, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(String, String, ChainModel, MetaAccountModel)>] = [wrap(matchable: address) { $0.0 }, wrap(matchable: password) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return cuckoo_manager.verify(
    """
    exportAccount(address: String, password: String, chain: ChainModel, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountExportPasswordInteractorInputProtocolStub: AccountExportPasswordInteractorInputProtocol {
    

    

    
    
    
    
     func exportWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo], password: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func exportAccount(address: String, password: String, chain: ChainModel, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountExportPasswordInteractorOutputProtocol: AccountExportPasswordInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountExportPasswordInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_AccountExportPasswordInteractorOutputProtocol
     typealias Verification = __VerificationProxy_AccountExportPasswordInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountExportPasswordInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: AccountExportPasswordInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didExport(jsons: [RestoreJson])  {
        
    return cuckoo_manager.call(
    """
    didExport(jsons: [RestoreJson])
    """,
            parameters: (jsons),
            escapingParameters: (jsons),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didExport(jsons: jsons))
        
    }
    
    
    
    
    
     func didReceive(error: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(error: Error)
    """,
            parameters: (error),
            escapingParameters: (error),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(error: error))
        
    }
    
    

     struct __StubbingProxy_AccountExportPasswordInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didExport<M1: Cuckoo.Matchable>(jsons: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([RestoreJson])> where M1.MatchedType == [RestoreJson] {
            let matchers: [Cuckoo.ParameterMatcher<([RestoreJson])>] = [wrap(matchable: jsons) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordInteractorOutputProtocol.self, method:
    """
    didExport(jsons: [RestoreJson])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordInteractorOutputProtocol.self, method:
    """
    didReceive(error: Error)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountExportPasswordInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didExport<M1: Cuckoo.Matchable>(jsons: M1) -> Cuckoo.__DoNotUse<([RestoreJson]), Void> where M1.MatchedType == [RestoreJson] {
            let matchers: [Cuckoo.ParameterMatcher<([RestoreJson])>] = [wrap(matchable: jsons) { $0 }]
            return cuckoo_manager.verify(
    """
    didExport(jsons: [RestoreJson])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(error: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountExportPasswordInteractorOutputProtocolStub: AccountExportPasswordInteractorOutputProtocol {
    

    

    
    
    
    
     func didExport(jsons: [RestoreJson])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(error: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAccountExportPasswordWireframeProtocol: AccountExportPasswordWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AccountExportPasswordWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_AccountExportPasswordWireframeProtocol
     typealias Verification = __VerificationProxy_AccountExportPasswordWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AccountExportPasswordWireframeProtocol?

     func enableDefaultImplementation(_ stub: AccountExportPasswordWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showJSONExport(_ jsons: [RestoreJson], flow: ExportFlow, from view: AccountExportPasswordViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showJSONExport(_: [RestoreJson], flow: ExportFlow, from: AccountExportPasswordViewProtocol?)
    """,
            parameters: (jsons, flow, view),
            escapingParameters: (jsons, flow, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showJSONExport(jsons, flow: flow, from: view))
        
    }
    
    
    
    
    
     func back(from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    back(from: ControllerBackedProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.back(from: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_AccountExportPasswordWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showJSONExport<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(_ jsons: M1, flow: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<([RestoreJson], ExportFlow, AccountExportPasswordViewProtocol?)> where M1.MatchedType == [RestoreJson], M2.MatchedType == ExportFlow, M3.OptionalMatchedType == AccountExportPasswordViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<([RestoreJson], ExportFlow, AccountExportPasswordViewProtocol?)>] = [wrap(matchable: jsons) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordWireframeProtocol.self, method:
    """
    showJSONExport(_: [RestoreJson], flow: ExportFlow, from: AccountExportPasswordViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func back<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?)> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordWireframeProtocol.self, method:
    """
    back(from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAccountExportPasswordWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AccountExportPasswordWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showJSONExport<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(_ jsons: M1, flow: M2, from view: M3) -> Cuckoo.__DoNotUse<([RestoreJson], ExportFlow, AccountExportPasswordViewProtocol?), Void> where M1.MatchedType == [RestoreJson], M2.MatchedType == ExportFlow, M3.OptionalMatchedType == AccountExportPasswordViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<([RestoreJson], ExportFlow, AccountExportPasswordViewProtocol?)>] = [wrap(matchable: jsons) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showJSONExport(_: [RestoreJson], flow: ExportFlow, from: AccountExportPasswordViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func back<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    back(from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AccountExportPasswordWireframeProtocolStub: AccountExportPasswordWireframeProtocol {
    

    

    
    
    
    
     func showJSONExport(_ jsons: [RestoreJson], flow: ExportFlow, from view: AccountExportPasswordViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func back(from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import SoraFoundation






 class MockExportGenericViewProtocol: ExportGenericViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ExportGenericViewProtocol
    
     typealias Stubbing = __StubbingProxy_ExportGenericViewProtocol
     typealias Verification = __VerificationProxy_ExportGenericViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ExportGenericViewProtocol?

     func enableDefaultImplementation(_ stub: ExportGenericViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func set(viewModel: MultipleExportGenericViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    set(viewModel: MultipleExportGenericViewModelProtocol)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.set(viewModel: viewModel))
        
    }
    
    

     struct __StubbingProxy_ExportGenericViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockExportGenericViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockExportGenericViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func set<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(MultipleExportGenericViewModelProtocol)> where M1.MatchedType == MultipleExportGenericViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(MultipleExportGenericViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericViewProtocol.self, method:
    """
    set(viewModel: MultipleExportGenericViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ExportGenericViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func set<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(MultipleExportGenericViewModelProtocol), Void> where M1.MatchedType == MultipleExportGenericViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(MultipleExportGenericViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    set(viewModel: MultipleExportGenericViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ExportGenericViewProtocolStub: ExportGenericViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func set(viewModel: MultipleExportGenericViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockExportGenericPresenterProtocol: ExportGenericPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ExportGenericPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_ExportGenericPresenterProtocol
     typealias Verification = __VerificationProxy_ExportGenericPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ExportGenericPresenterProtocol?

     func enableDefaultImplementation(_ stub: ExportGenericPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var flow: ExportFlow {
        get {
            return cuckoo_manager.getter("flow",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.flow)
        }
        
    }
    
    

    

    
    
    
    
     func didLoadView()  {
        
    return cuckoo_manager.call(
    """
    didLoadView()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didLoadView())
        
    }
    
    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func activateExport()  {
        
    return cuckoo_manager.call(
    """
    activateExport()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateExport())
        
    }
    
    
    
    
    
     func activateAccessoryOption()  {
        
    return cuckoo_manager.call(
    """
    activateAccessoryOption()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateAccessoryOption())
        
    }
    
    
    
    
    
     func didTapExportSubstrateButton()  {
        
    return cuckoo_manager.call(
    """
    didTapExportSubstrateButton()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didTapExportSubstrateButton())
        
    }
    
    
    
    
    
     func didTapExportEthereumButton()  {
        
    return cuckoo_manager.call(
    """
    didTapExportEthereumButton()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didTapExportEthereumButton())
        
    }
    
    
    
    
    
     func didTapStringExport(_ value: String?)  {
        
    return cuckoo_manager.call(
    """
    didTapStringExport(_: String?)
    """,
            parameters: (value),
            escapingParameters: (value),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didTapStringExport(value))
        
    }
    
    

     struct __StubbingProxy_ExportGenericPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var flow: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockExportGenericPresenterProtocol, ExportFlow> {
            return .init(manager: cuckoo_manager, name: "flow")
        }
        
        
        
        
        
        func didLoadView() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericPresenterProtocol.self, method:
    """
    didLoadView()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateExport() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericPresenterProtocol.self, method:
    """
    activateExport()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateAccessoryOption() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericPresenterProtocol.self, method:
    """
    activateAccessoryOption()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didTapExportSubstrateButton() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericPresenterProtocol.self, method:
    """
    didTapExportSubstrateButton()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didTapExportEthereumButton() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericPresenterProtocol.self, method:
    """
    didTapExportEthereumButton()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didTapStringExport<M1: Cuckoo.OptionalMatchable>(_ value: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String?)> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: value) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericPresenterProtocol.self, method:
    """
    didTapStringExport(_: String?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ExportGenericPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var flow: Cuckoo.VerifyReadOnlyProperty<ExportFlow> {
            return .init(manager: cuckoo_manager, name: "flow", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didLoadView() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didLoadView()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateExport() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateExport()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateAccessoryOption() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateAccessoryOption()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didTapExportSubstrateButton() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didTapExportSubstrateButton()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didTapExportEthereumButton() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didTapExportEthereumButton()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didTapStringExport<M1: Cuckoo.OptionalMatchable>(_ value: M1) -> Cuckoo.__DoNotUse<(String?), Void> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: value) { $0 }]
            return cuckoo_manager.verify(
    """
    didTapStringExport(_: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ExportGenericPresenterProtocolStub: ExportGenericPresenterProtocol {
    
    
    
    
     var flow: ExportFlow {
        get {
            return DefaultValueRegistry.defaultValue(for: (ExportFlow).self)
        }
        
    }
    
    

    

    
    
    
    
     func didLoadView()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateExport()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateAccessoryOption()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didTapExportSubstrateButton()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didTapExportEthereumButton()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didTapStringExport(_ value: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockExportGenericWireframeProtocol: ExportGenericWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ExportGenericWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ExportGenericWireframeProtocol
     typealias Verification = __VerificationProxy_ExportGenericWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ExportGenericWireframeProtocol?

     func enableDefaultImplementation(_ stub: ExportGenericWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func close(view: ExportGenericViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(view: ExportGenericViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view: view))
        
    }
    
    
    
    
    
     func back(view: ExportGenericViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    back(view: ExportGenericViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.back(view: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    
    
    
    
     func share(source: UIActivityItemSource, from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)  {
        
    return cuckoo_manager.call(
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """,
            parameters: (source, view, completionHandler),
            escapingParameters: (source, view, completionHandler),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.share(source: source, from: view, with: completionHandler))
        
    }
    
    
    
    
    
     func share(sources: [Any], from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)  {
        
    return cuckoo_manager.call(
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """,
            parameters: (sources, view, completionHandler),
            escapingParameters: (sources, view, completionHandler),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.share(sources: sources, from: view, with: completionHandler))
        
    }
    
    

     struct __StubbingProxy_ExportGenericWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExportGenericViewProtocol?)> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericWireframeProtocol.self, method:
    """
    close(view: ExportGenericViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func back<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExportGenericViewProtocol?)> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericWireframeProtocol.self, method:
    """
    back(view: ExportGenericViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(source: M1, from view: M2, with completionHandler: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)> where M1.MatchedType == UIActivityItemSource, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: source) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericWireframeProtocol.self, method:
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(sources: M1, from view: M2, with completionHandler: M3) -> Cuckoo.ProtocolStubNoReturnFunction<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)> where M1.MatchedType == [Any], M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: sources) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportGenericWireframeProtocol.self, method:
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ExportGenericWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(ExportGenericViewProtocol?), Void> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(view: ExportGenericViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func back<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(ExportGenericViewProtocol?), Void> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    back(view: ExportGenericViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(source: M1, from view: M2, with completionHandler: M3) -> Cuckoo.__DoNotUse<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?), Void> where M1.MatchedType == UIActivityItemSource, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: source) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return cuckoo_manager.verify(
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(sources: M1, from view: M2, with completionHandler: M3) -> Cuckoo.__DoNotUse<([Any], ControllerBackedProtocol?, SharingCompletionHandler?), Void> where M1.MatchedType == [Any], M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: sources) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return cuckoo_manager.verify(
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ExportGenericWireframeProtocolStub: ExportGenericWireframeProtocol {
    

    

    
    
    
    
     func close(view: ExportGenericViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func back(view: ExportGenericViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func share(source: UIActivityItemSource, from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func share(sources: [Any], from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import IrohaCrypto






 class MockExportMnemonicInteractorInputProtocol: ExportMnemonicInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ExportMnemonicInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_ExportMnemonicInteractorInputProtocol
     typealias Verification = __VerificationProxy_ExportMnemonicInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ExportMnemonicInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: ExportMnemonicInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func fetchExportDataForWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo])  {
        
    return cuckoo_manager.call(
    """
    fetchExportDataForWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo])
    """,
            parameters: (wallet, accounts),
            escapingParameters: (wallet, accounts),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.fetchExportDataForWallet(wallet: wallet, accounts: accounts))
        
    }
    
    
    
    
    
     func fetchExportDataForAddress(_ address: String, chain: ChainModel, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    fetchExportDataForAddress(_: String, chain: ChainModel, wallet: MetaAccountModel)
    """,
            parameters: (address, chain, wallet),
            escapingParameters: (address, chain, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.fetchExportDataForAddress(address, chain: chain, wallet: wallet))
        
    }
    
    

     struct __StubbingProxy_ExportMnemonicInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func fetchExportDataForWallet<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(wallet: M1, accounts: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(MetaAccountModel, [ChainAccountInfo])> where M1.MatchedType == MetaAccountModel, M2.MatchedType == [ChainAccountInfo] {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel, [ChainAccountInfo])>] = [wrap(matchable: wallet) { $0.0 }, wrap(matchable: accounts) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicInteractorInputProtocol.self, method:
    """
    fetchExportDataForWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func fetchExportDataForAddress<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(_ address: M1, chain: M2, wallet: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String, ChainModel, MetaAccountModel)> where M1.MatchedType == String, M2.MatchedType == ChainModel, M3.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(String, ChainModel, MetaAccountModel)>] = [wrap(matchable: address) { $0.0 }, wrap(matchable: chain) { $0.1 }, wrap(matchable: wallet) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicInteractorInputProtocol.self, method:
    """
    fetchExportDataForAddress(_: String, chain: ChainModel, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ExportMnemonicInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func fetchExportDataForWallet<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(wallet: M1, accounts: M2) -> Cuckoo.__DoNotUse<(MetaAccountModel, [ChainAccountInfo]), Void> where M1.MatchedType == MetaAccountModel, M2.MatchedType == [ChainAccountInfo] {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel, [ChainAccountInfo])>] = [wrap(matchable: wallet) { $0.0 }, wrap(matchable: accounts) { $0.1 }]
            return cuckoo_manager.verify(
    """
    fetchExportDataForWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func fetchExportDataForAddress<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(_ address: M1, chain: M2, wallet: M3) -> Cuckoo.__DoNotUse<(String, ChainModel, MetaAccountModel), Void> where M1.MatchedType == String, M2.MatchedType == ChainModel, M3.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(String, ChainModel, MetaAccountModel)>] = [wrap(matchable: address) { $0.0 }, wrap(matchable: chain) { $0.1 }, wrap(matchable: wallet) { $0.2 }]
            return cuckoo_manager.verify(
    """
    fetchExportDataForAddress(_: String, chain: ChainModel, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ExportMnemonicInteractorInputProtocolStub: ExportMnemonicInteractorInputProtocol {
    

    

    
    
    
    
     func fetchExportDataForWallet(wallet: MetaAccountModel, accounts: [ChainAccountInfo])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func fetchExportDataForAddress(_ address: String, chain: ChainModel, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockExportMnemonicInteractorOutputProtocol: ExportMnemonicInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ExportMnemonicInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_ExportMnemonicInteractorOutputProtocol
     typealias Verification = __VerificationProxy_ExportMnemonicInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ExportMnemonicInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: ExportMnemonicInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(exportDatas: [ExportMnemonicData])  {
        
    return cuckoo_manager.call(
    """
    didReceive(exportDatas: [ExportMnemonicData])
    """,
            parameters: (exportDatas),
            escapingParameters: (exportDatas),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(exportDatas: exportDatas))
        
    }
    
    
    
    
    
     func didReceive(error: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(error: Error)
    """,
            parameters: (error),
            escapingParameters: (error),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(error: error))
        
    }
    
    

     struct __StubbingProxy_ExportMnemonicInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(exportDatas: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([ExportMnemonicData])> where M1.MatchedType == [ExportMnemonicData] {
            let matchers: [Cuckoo.ParameterMatcher<([ExportMnemonicData])>] = [wrap(matchable: exportDatas) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicInteractorOutputProtocol.self, method:
    """
    didReceive(exportDatas: [ExportMnemonicData])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicInteractorOutputProtocol.self, method:
    """
    didReceive(error: Error)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ExportMnemonicInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(exportDatas: M1) -> Cuckoo.__DoNotUse<([ExportMnemonicData]), Void> where M1.MatchedType == [ExportMnemonicData] {
            let matchers: [Cuckoo.ParameterMatcher<([ExportMnemonicData])>] = [wrap(matchable: exportDatas) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(exportDatas: [ExportMnemonicData])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(error: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ExportMnemonicInteractorOutputProtocolStub: ExportMnemonicInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceive(exportDatas: [ExportMnemonicData])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(error: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockExportMnemonicWireframeProtocol: ExportMnemonicWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ExportMnemonicWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ExportMnemonicWireframeProtocol
     typealias Verification = __VerificationProxy_ExportMnemonicWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ExportMnemonicWireframeProtocol?

     func enableDefaultImplementation(_ stub: ExportMnemonicWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func close(view: ExportGenericViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(view: ExportGenericViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view: view))
        
    }
    
    
    
    
    
     func openConfirmationForMnemonic(_ mnemonic: IRMnemonicProtocol, from view: ExportGenericViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    openConfirmationForMnemonic(_: IRMnemonicProtocol, from: ExportGenericViewProtocol?)
    """,
            parameters: (mnemonic, view),
            escapingParameters: (mnemonic, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.openConfirmationForMnemonic(mnemonic, from: view))
        
    }
    
    
    
    
    
     func back(view: ExportGenericViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    back(view: ExportGenericViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.back(view: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    
    
    
    
     func share(source: UIActivityItemSource, from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)  {
        
    return cuckoo_manager.call(
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """,
            parameters: (source, view, completionHandler),
            escapingParameters: (source, view, completionHandler),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.share(source: source, from: view, with: completionHandler))
        
    }
    
    
    
    
    
     func share(sources: [Any], from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)  {
        
    return cuckoo_manager.call(
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """,
            parameters: (sources, view, completionHandler),
            escapingParameters: (sources, view, completionHandler),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.share(sources: sources, from: view, with: completionHandler))
        
    }
    
    

     struct __StubbingProxy_ExportMnemonicWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExportGenericViewProtocol?)> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicWireframeProtocol.self, method:
    """
    close(view: ExportGenericViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func openConfirmationForMnemonic<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(_ mnemonic: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(IRMnemonicProtocol, ExportGenericViewProtocol?)> where M1.MatchedType == IRMnemonicProtocol, M2.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(IRMnemonicProtocol, ExportGenericViewProtocol?)>] = [wrap(matchable: mnemonic) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicWireframeProtocol.self, method:
    """
    openConfirmationForMnemonic(_: IRMnemonicProtocol, from: ExportGenericViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func back<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExportGenericViewProtocol?)> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicWireframeProtocol.self, method:
    """
    back(view: ExportGenericViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(source: M1, from view: M2, with completionHandler: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)> where M1.MatchedType == UIActivityItemSource, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: source) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicWireframeProtocol.self, method:
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(sources: M1, from view: M2, with completionHandler: M3) -> Cuckoo.ProtocolStubNoReturnFunction<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)> where M1.MatchedType == [Any], M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: sources) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportMnemonicWireframeProtocol.self, method:
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ExportMnemonicWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(ExportGenericViewProtocol?), Void> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(view: ExportGenericViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func openConfirmationForMnemonic<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(_ mnemonic: M1, from view: M2) -> Cuckoo.__DoNotUse<(IRMnemonicProtocol, ExportGenericViewProtocol?), Void> where M1.MatchedType == IRMnemonicProtocol, M2.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(IRMnemonicProtocol, ExportGenericViewProtocol?)>] = [wrap(matchable: mnemonic) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    openConfirmationForMnemonic(_: IRMnemonicProtocol, from: ExportGenericViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func back<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(ExportGenericViewProtocol?), Void> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    back(view: ExportGenericViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(source: M1, from view: M2, with completionHandler: M3) -> Cuckoo.__DoNotUse<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?), Void> where M1.MatchedType == UIActivityItemSource, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: source) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return cuckoo_manager.verify(
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(sources: M1, from view: M2, with completionHandler: M3) -> Cuckoo.__DoNotUse<([Any], ControllerBackedProtocol?, SharingCompletionHandler?), Void> where M1.MatchedType == [Any], M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: sources) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return cuckoo_manager.verify(
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ExportMnemonicWireframeProtocolStub: ExportMnemonicWireframeProtocol {
    

    

    
    
    
    
     func close(view: ExportGenericViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func openConfirmationForMnemonic(_ mnemonic: IRMnemonicProtocol, from view: ExportGenericViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func back(view: ExportGenericViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func share(source: UIActivityItemSource, from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func share(sources: [Any], from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation






 class MockExportRestoreJsonWireframeProtocol: ExportRestoreJsonWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ExportRestoreJsonWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ExportRestoreJsonWireframeProtocol
     typealias Verification = __VerificationProxy_ExportRestoreJsonWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ExportRestoreJsonWireframeProtocol?

     func enableDefaultImplementation(_ stub: ExportRestoreJsonWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func close(view: ExportGenericViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(view: ExportGenericViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view: view))
        
    }
    
    
    
    
    
     func showChangePassword(from view: ExportGenericViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showChangePassword(from: ExportGenericViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showChangePassword(from: view))
        
    }
    
    
    
    
    
     func presentExportActionsFlow(from view: ControllerBackedProtocol?, items: [JsonExportAction], callback: @escaping ModalPickerSelectionCallback)  {
        
    return cuckoo_manager.call(
    """
    presentExportActionsFlow(from: ControllerBackedProtocol?, items: [JsonExportAction], callback: @escaping ModalPickerSelectionCallback)
    """,
            parameters: (view, items, callback),
            escapingParameters: (view, items, callback),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentExportActionsFlow(from: view, items: items, callback: callback))
        
    }
    
    
    
    
    
     func back(view: ExportGenericViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    back(view: ExportGenericViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.back(view: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    
    
    
    
     func share(source: UIActivityItemSource, from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)  {
        
    return cuckoo_manager.call(
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """,
            parameters: (source, view, completionHandler),
            escapingParameters: (source, view, completionHandler),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.share(source: source, from: view, with: completionHandler))
        
    }
    
    
    
    
    
     func share(sources: [Any], from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)  {
        
    return cuckoo_manager.call(
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """,
            parameters: (sources, view, completionHandler),
            escapingParameters: (sources, view, completionHandler),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.share(sources: sources, from: view, with: completionHandler))
        
    }
    
    

     struct __StubbingProxy_ExportRestoreJsonWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExportGenericViewProtocol?)> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportRestoreJsonWireframeProtocol.self, method:
    """
    close(view: ExportGenericViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showChangePassword<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExportGenericViewProtocol?)> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportRestoreJsonWireframeProtocol.self, method:
    """
    showChangePassword(from: ExportGenericViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentExportActionsFlow<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, items: M2, callback: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, [JsonExportAction], ModalPickerSelectionCallback)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == [JsonExportAction], M3.MatchedType == ModalPickerSelectionCallback {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, [JsonExportAction], ModalPickerSelectionCallback)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: items) { $0.1 }, wrap(matchable: callback) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportRestoreJsonWireframeProtocol.self, method:
    """
    presentExportActionsFlow(from: ControllerBackedProtocol?, items: [JsonExportAction], callback: @escaping ModalPickerSelectionCallback)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func back<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExportGenericViewProtocol?)> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportRestoreJsonWireframeProtocol.self, method:
    """
    back(view: ExportGenericViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportRestoreJsonWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportRestoreJsonWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportRestoreJsonWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(source: M1, from view: M2, with completionHandler: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)> where M1.MatchedType == UIActivityItemSource, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: source) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportRestoreJsonWireframeProtocol.self, method:
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(sources: M1, from view: M2, with completionHandler: M3) -> Cuckoo.ProtocolStubNoReturnFunction<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)> where M1.MatchedType == [Any], M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: sources) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockExportRestoreJsonWireframeProtocol.self, method:
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ExportRestoreJsonWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(ExportGenericViewProtocol?), Void> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(view: ExportGenericViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showChangePassword<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(ExportGenericViewProtocol?), Void> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showChangePassword(from: ExportGenericViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentExportActionsFlow<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, items: M2, callback: M3) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, [JsonExportAction], ModalPickerSelectionCallback), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == [JsonExportAction], M3.MatchedType == ModalPickerSelectionCallback {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, [JsonExportAction], ModalPickerSelectionCallback)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: items) { $0.1 }, wrap(matchable: callback) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentExportActionsFlow(from: ControllerBackedProtocol?, items: [JsonExportAction], callback: @escaping ModalPickerSelectionCallback)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func back<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(ExportGenericViewProtocol?), Void> where M1.OptionalMatchedType == ExportGenericViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ExportGenericViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    back(view: ExportGenericViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(source: M1, from view: M2, with completionHandler: M3) -> Cuckoo.__DoNotUse<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?), Void> where M1.MatchedType == UIActivityItemSource, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<(UIActivityItemSource, ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: source) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return cuckoo_manager.verify(
    """
    share(source: UIActivityItemSource, from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func share<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(sources: M1, from view: M2, with completionHandler: M3) -> Cuckoo.__DoNotUse<([Any], ControllerBackedProtocol?, SharingCompletionHandler?), Void> where M1.MatchedType == [Any], M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == SharingCompletionHandler {
            let matchers: [Cuckoo.ParameterMatcher<([Any], ControllerBackedProtocol?, SharingCompletionHandler?)>] = [wrap(matchable: sources) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: completionHandler) { $0.2 }]
            return cuckoo_manager.verify(
    """
    share(sources: [Any], from: ControllerBackedProtocol?, with: SharingCompletionHandler?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ExportRestoreJsonWireframeProtocolStub: ExportRestoreJsonWireframeProtocol {
    

    

    
    
    
    
     func close(view: ExportGenericViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showChangePassword(from view: ExportGenericViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentExportActionsFlow(from view: ControllerBackedProtocol?, items: [JsonExportAction], callback: @escaping ModalPickerSelectionCallback)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func back(view: ExportGenericViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func share(source: UIActivityItemSource, from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func share(sources: [Any], from view: ControllerBackedProtocol?, with completionHandler: SharingCompletionHandler?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockNetworkInfoViewProtocol: NetworkInfoViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = NetworkInfoViewProtocol
    
     typealias Stubbing = __StubbingProxy_NetworkInfoViewProtocol
     typealias Verification = __VerificationProxy_NetworkInfoViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: NetworkInfoViewProtocol?

     func enableDefaultImplementation(_ stub: NetworkInfoViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func set(nameViewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    set(nameViewModel: InputViewModelProtocol)
    """,
            parameters: (nameViewModel),
            escapingParameters: (nameViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.set(nameViewModel: nameViewModel))
        
    }
    
    
    
    
    
     func set(nodeViewModel: InputViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    set(nodeViewModel: InputViewModelProtocol)
    """,
            parameters: (nodeViewModel),
            escapingParameters: (nodeViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.set(nodeViewModel: nodeViewModel))
        
    }
    
    
    
    
    
     func set(chain: ChainModel)  {
        
    return cuckoo_manager.call(
    """
    set(chain: ChainModel)
    """,
            parameters: (chain),
            escapingParameters: (chain),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.set(chain: chain))
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_NetworkInfoViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockNetworkInfoViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockNetworkInfoViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockNetworkInfoViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockNetworkInfoViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func set<M1: Cuckoo.Matchable>(nameViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: nameViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoViewProtocol.self, method:
    """
    set(nameViewModel: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func set<M1: Cuckoo.Matchable>(nodeViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(InputViewModelProtocol)> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: nodeViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoViewProtocol.self, method:
    """
    set(nodeViewModel: InputViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func set<M1: Cuckoo.Matchable>(chain: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainModel)> where M1.MatchedType == ChainModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChainModel)>] = [wrap(matchable: chain) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoViewProtocol.self, method:
    """
    set(chain: ChainModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_NetworkInfoViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func set<M1: Cuckoo.Matchable>(nameViewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: nameViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    set(nameViewModel: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func set<M1: Cuckoo.Matchable>(nodeViewModel: M1) -> Cuckoo.__DoNotUse<(InputViewModelProtocol), Void> where M1.MatchedType == InputViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(InputViewModelProtocol)>] = [wrap(matchable: nodeViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    set(nodeViewModel: InputViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func set<M1: Cuckoo.Matchable>(chain: M1) -> Cuckoo.__DoNotUse<(ChainModel), Void> where M1.MatchedType == ChainModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChainModel)>] = [wrap(matchable: chain) { $0 }]
            return cuckoo_manager.verify(
    """
    set(chain: ChainModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class NetworkInfoViewProtocolStub: NetworkInfoViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func set(nameViewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func set(nodeViewModel: InputViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func set(chain: ChainModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockNetworkInfoPresenterProtocol: NetworkInfoPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = NetworkInfoPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_NetworkInfoPresenterProtocol
     typealias Verification = __VerificationProxy_NetworkInfoPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: NetworkInfoPresenterProtocol?

     func enableDefaultImplementation(_ stub: NetworkInfoPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func activateCopy()  {
        
    return cuckoo_manager.call(
    """
    activateCopy()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateCopy())
        
    }
    
    
    
    
    
     func activateClose()  {
        
    return cuckoo_manager.call(
    """
    activateClose()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateClose())
        
    }
    
    
    
    
    
     func activateUpdate()  {
        
    return cuckoo_manager.call(
    """
    activateUpdate()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateUpdate())
        
    }
    
    

     struct __StubbingProxy_NetworkInfoPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateCopy() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoPresenterProtocol.self, method:
    """
    activateCopy()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateClose() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoPresenterProtocol.self, method:
    """
    activateClose()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateUpdate() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoPresenterProtocol.self, method:
    """
    activateUpdate()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_NetworkInfoPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateCopy() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateCopy()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateClose() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateClose()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateUpdate() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateUpdate()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class NetworkInfoPresenterProtocolStub: NetworkInfoPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateCopy()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateClose()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateUpdate()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockNetworkInfoInteractorInputProtocol: NetworkInfoInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = NetworkInfoInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_NetworkInfoInteractorInputProtocol
     typealias Verification = __VerificationProxy_NetworkInfoInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: NetworkInfoInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: NetworkInfoInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func updateNode(_ node: ChainNodeModel, newURL: URL, newName: String)  {
        
    return cuckoo_manager.call(
    """
    updateNode(_: ChainNodeModel, newURL: URL, newName: String)
    """,
            parameters: (node, newURL, newName),
            escapingParameters: (node, newURL, newName),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.updateNode(node, newURL: newURL, newName: newName))
        
    }
    
    

     struct __StubbingProxy_NetworkInfoInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func updateNode<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(_ node: M1, newURL: M2, newName: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainNodeModel, URL, String)> where M1.MatchedType == ChainNodeModel, M2.MatchedType == URL, M3.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ChainNodeModel, URL, String)>] = [wrap(matchable: node) { $0.0 }, wrap(matchable: newURL) { $0.1 }, wrap(matchable: newName) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoInteractorInputProtocol.self, method:
    """
    updateNode(_: ChainNodeModel, newURL: URL, newName: String)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_NetworkInfoInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func updateNode<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(_ node: M1, newURL: M2, newName: M3) -> Cuckoo.__DoNotUse<(ChainNodeModel, URL, String), Void> where M1.MatchedType == ChainNodeModel, M2.MatchedType == URL, M3.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ChainNodeModel, URL, String)>] = [wrap(matchable: node) { $0.0 }, wrap(matchable: newURL) { $0.1 }, wrap(matchable: newName) { $0.2 }]
            return cuckoo_manager.verify(
    """
    updateNode(_: ChainNodeModel, newURL: URL, newName: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class NetworkInfoInteractorInputProtocolStub: NetworkInfoInteractorInputProtocol {
    

    

    
    
    
    
     func updateNode(_ node: ChainNodeModel, newURL: URL, newName: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockNetworkInfoInteractorOutputProtocol: NetworkInfoInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = NetworkInfoInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_NetworkInfoInteractorOutputProtocol
     typealias Verification = __VerificationProxy_NetworkInfoInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: NetworkInfoInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: NetworkInfoInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didStartConnectionUpdate(with url: URL)  {
        
    return cuckoo_manager.call(
    """
    didStartConnectionUpdate(with: URL)
    """,
            parameters: (url),
            escapingParameters: (url),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartConnectionUpdate(with: url))
        
    }
    
    
    
    
    
     func didCompleteConnectionUpdate(with url: URL)  {
        
    return cuckoo_manager.call(
    """
    didCompleteConnectionUpdate(with: URL)
    """,
            parameters: (url),
            escapingParameters: (url),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didCompleteConnectionUpdate(with: url))
        
    }
    
    
    
    
    
     func didReceive(error: Error, for url: URL)  {
        
    return cuckoo_manager.call(
    """
    didReceive(error: Error, for: URL)
    """,
            parameters: (error, url),
            escapingParameters: (error, url),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(error: error, for: url))
        
    }
    
    

     struct __StubbingProxy_NetworkInfoInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didStartConnectionUpdate<M1: Cuckoo.Matchable>(with url: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(URL)> where M1.MatchedType == URL {
            let matchers: [Cuckoo.ParameterMatcher<(URL)>] = [wrap(matchable: url) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoInteractorOutputProtocol.self, method:
    """
    didStartConnectionUpdate(with: URL)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didCompleteConnectionUpdate<M1: Cuckoo.Matchable>(with url: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(URL)> where M1.MatchedType == URL {
            let matchers: [Cuckoo.ParameterMatcher<(URL)>] = [wrap(matchable: url) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoInteractorOutputProtocol.self, method:
    """
    didCompleteConnectionUpdate(with: URL)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(error: M1, for url: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(Error, URL)> where M1.MatchedType == Error, M2.MatchedType == URL {
            let matchers: [Cuckoo.ParameterMatcher<(Error, URL)>] = [wrap(matchable: error) { $0.0 }, wrap(matchable: url) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoInteractorOutputProtocol.self, method:
    """
    didReceive(error: Error, for: URL)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_NetworkInfoInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didStartConnectionUpdate<M1: Cuckoo.Matchable>(with url: M1) -> Cuckoo.__DoNotUse<(URL), Void> where M1.MatchedType == URL {
            let matchers: [Cuckoo.ParameterMatcher<(URL)>] = [wrap(matchable: url) { $0 }]
            return cuckoo_manager.verify(
    """
    didStartConnectionUpdate(with: URL)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didCompleteConnectionUpdate<M1: Cuckoo.Matchable>(with url: M1) -> Cuckoo.__DoNotUse<(URL), Void> where M1.MatchedType == URL {
            let matchers: [Cuckoo.ParameterMatcher<(URL)>] = [wrap(matchable: url) { $0 }]
            return cuckoo_manager.verify(
    """
    didCompleteConnectionUpdate(with: URL)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(error: M1, for url: M2) -> Cuckoo.__DoNotUse<(Error, URL), Void> where M1.MatchedType == Error, M2.MatchedType == URL {
            let matchers: [Cuckoo.ParameterMatcher<(Error, URL)>] = [wrap(matchable: error) { $0.0 }, wrap(matchable: url) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didReceive(error: Error, for: URL)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class NetworkInfoInteractorOutputProtocolStub: NetworkInfoInteractorOutputProtocol {
    

    

    
    
    
    
     func didStartConnectionUpdate(with url: URL)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didCompleteConnectionUpdate(with url: URL)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(error: Error, for url: URL)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockNetworkInfoWireframeProtocol: NetworkInfoWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = NetworkInfoWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_NetworkInfoWireframeProtocol
     typealias Verification = __VerificationProxy_NetworkInfoWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: NetworkInfoWireframeProtocol?

     func enableDefaultImplementation(_ stub: NetworkInfoWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func close(view: NetworkInfoViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(view: NetworkInfoViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    
    
    
    
     func presentSuccessNotification(_ title: String, from view: ControllerBackedProtocol?, completion closure: (() -> Void)?)  {
        
    return cuckoo_manager.call(
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """,
            parameters: (title, view, closure),
            escapingParameters: (title, view, closure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentSuccessNotification(title, from: view, completion: closure))
        
    }
    
    

     struct __StubbingProxy_NetworkInfoWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(NetworkInfoViewProtocol?)> where M1.OptionalMatchedType == NetworkInfoViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(NetworkInfoViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoWireframeProtocol.self, method:
    """
    close(view: NetworkInfoViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentSuccessNotification<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(_ title: M1, from view: M2, completion closure: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String, ControllerBackedProtocol?, (() -> Void)?)> where M1.MatchedType == String, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == (() -> Void) {
            let matchers: [Cuckoo.ParameterMatcher<(String, ControllerBackedProtocol?, (() -> Void)?)>] = [wrap(matchable: title) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: closure) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockNetworkInfoWireframeProtocol.self, method:
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_NetworkInfoWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(NetworkInfoViewProtocol?), Void> where M1.OptionalMatchedType == NetworkInfoViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(NetworkInfoViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(view: NetworkInfoViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentSuccessNotification<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(_ title: M1, from view: M2, completion closure: M3) -> Cuckoo.__DoNotUse<(String, ControllerBackedProtocol?, (() -> Void)?), Void> where M1.MatchedType == String, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == (() -> Void) {
            let matchers: [Cuckoo.ParameterMatcher<(String, ControllerBackedProtocol?, (() -> Void)?)>] = [wrap(matchable: title) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: closure) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class NetworkInfoWireframeProtocolStub: NetworkInfoWireframeProtocol {
    

    

    
    
    
    
     func close(view: NetworkInfoViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentSuccessNotification(_ title: String, from view: ControllerBackedProtocol?, completion closure: (() -> Void)?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation






 class MockOnboardingMainViewProtocol: OnboardingMainViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = OnboardingMainViewProtocol
    
     typealias Stubbing = __StubbingProxy_OnboardingMainViewProtocol
     typealias Verification = __VerificationProxy_OnboardingMainViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: OnboardingMainViewProtocol?

     func enableDefaultImplementation(_ stub: OnboardingMainViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    

     struct __StubbingProxy_OnboardingMainViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockOnboardingMainViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockOnboardingMainViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
    }

     struct __VerificationProxy_OnboardingMainViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
    }
}


 class OnboardingMainViewProtocolStub: OnboardingMainViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
}










 class MockOnboardingMainPresenterProtocol: OnboardingMainPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = OnboardingMainPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_OnboardingMainPresenterProtocol
     typealias Verification = __VerificationProxy_OnboardingMainPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: OnboardingMainPresenterProtocol?

     func enableDefaultImplementation(_ stub: OnboardingMainPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func activateSignup()  {
        
    return cuckoo_manager.call(
    """
    activateSignup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateSignup())
        
    }
    
    
    
    
    
     func activateAccountRestore()  {
        
    return cuckoo_manager.call(
    """
    activateAccountRestore()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateAccountRestore())
        
    }
    
    
    
    
    
     func activateTerms()  {
        
    return cuckoo_manager.call(
    """
    activateTerms()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateTerms())
        
    }
    
    
    
    
    
     func activatePrivacy()  {
        
    return cuckoo_manager.call(
    """
    activatePrivacy()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activatePrivacy())
        
    }
    
    

     struct __StubbingProxy_OnboardingMainPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateSignup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainPresenterProtocol.self, method:
    """
    activateSignup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateAccountRestore() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainPresenterProtocol.self, method:
    """
    activateAccountRestore()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateTerms() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainPresenterProtocol.self, method:
    """
    activateTerms()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activatePrivacy() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainPresenterProtocol.self, method:
    """
    activatePrivacy()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_OnboardingMainPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateSignup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateSignup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateAccountRestore() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateAccountRestore()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateTerms() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateTerms()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activatePrivacy() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activatePrivacy()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class OnboardingMainPresenterProtocolStub: OnboardingMainPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateSignup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateAccountRestore()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateTerms()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activatePrivacy()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockOnboardingMainWireframeProtocol: OnboardingMainWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = OnboardingMainWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_OnboardingMainWireframeProtocol
     typealias Verification = __VerificationProxy_OnboardingMainWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: OnboardingMainWireframeProtocol?

     func enableDefaultImplementation(_ stub: OnboardingMainWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showSignup(from view: OnboardingMainViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showSignup(from: OnboardingMainViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showSignup(from: view))
        
    }
    
    
    
    
    
     func showAccountRestore(from view: OnboardingMainViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showAccountRestore(from: OnboardingMainViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showAccountRestore(from: view))
        
    }
    
    
    
    
    
     func showKeystoreImport(from view: OnboardingMainViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showKeystoreImport(from: OnboardingMainViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showKeystoreImport(from: view))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_OnboardingMainWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showSignup<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(OnboardingMainViewProtocol?)> where M1.OptionalMatchedType == OnboardingMainViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(OnboardingMainViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainWireframeProtocol.self, method:
    """
    showSignup(from: OnboardingMainViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showAccountRestore<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(OnboardingMainViewProtocol?)> where M1.OptionalMatchedType == OnboardingMainViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(OnboardingMainViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainWireframeProtocol.self, method:
    """
    showAccountRestore(from: OnboardingMainViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showKeystoreImport<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(OnboardingMainViewProtocol?)> where M1.OptionalMatchedType == OnboardingMainViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(OnboardingMainViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainWireframeProtocol.self, method:
    """
    showKeystoreImport(from: OnboardingMainViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_OnboardingMainWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showSignup<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(OnboardingMainViewProtocol?), Void> where M1.OptionalMatchedType == OnboardingMainViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(OnboardingMainViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showSignup(from: OnboardingMainViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showAccountRestore<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(OnboardingMainViewProtocol?), Void> where M1.OptionalMatchedType == OnboardingMainViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(OnboardingMainViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showAccountRestore(from: OnboardingMainViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showKeystoreImport<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(OnboardingMainViewProtocol?), Void> where M1.OptionalMatchedType == OnboardingMainViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(OnboardingMainViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showKeystoreImport(from: OnboardingMainViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class OnboardingMainWireframeProtocolStub: OnboardingMainWireframeProtocol {
    

    

    
    
    
    
     func showSignup(from view: OnboardingMainViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showAccountRestore(from view: OnboardingMainViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showKeystoreImport(from view: OnboardingMainViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockOnboardingMainInteractorInputProtocol: OnboardingMainInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = OnboardingMainInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_OnboardingMainInteractorInputProtocol
     typealias Verification = __VerificationProxy_OnboardingMainInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: OnboardingMainInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: OnboardingMainInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    

     struct __StubbingProxy_OnboardingMainInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_OnboardingMainInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class OnboardingMainInteractorInputProtocolStub: OnboardingMainInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockOnboardingMainInteractorOutputProtocol: OnboardingMainInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = OnboardingMainInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_OnboardingMainInteractorOutputProtocol
     typealias Verification = __VerificationProxy_OnboardingMainInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: OnboardingMainInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: OnboardingMainInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didSuggestKeystoreImport()  {
        
    return cuckoo_manager.call(
    """
    didSuggestKeystoreImport()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSuggestKeystoreImport())
        
    }
    
    

     struct __StubbingProxy_OnboardingMainInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didSuggestKeystoreImport() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockOnboardingMainInteractorOutputProtocol.self, method:
    """
    didSuggestKeystoreImport()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_OnboardingMainInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didSuggestKeystoreImport() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didSuggestKeystoreImport()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class OnboardingMainInteractorOutputProtocolStub: OnboardingMainInteractorOutputProtocol {
    

    

    
    
    
    
     func didSuggestKeystoreImport()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import UIKit






 class MockPinSetupViewProtocol: PinSetupViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = PinSetupViewProtocol
    
     typealias Stubbing = __StubbingProxy_PinSetupViewProtocol
     typealias Verification = __VerificationProxy_PinSetupViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: PinSetupViewProtocol?

     func enableDefaultImplementation(_ stub: PinSetupViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didRequestBiometryUsage(biometryType: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)  {
        
    return cuckoo_manager.call(
    """
    didRequestBiometryUsage(biometryType: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)
    """,
            parameters: (biometryType, completionBlock),
            escapingParameters: (biometryType, completionBlock),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRequestBiometryUsage(biometryType: biometryType, completionBlock: completionBlock))
        
    }
    
    
    
    
    
     func didChangeAccessoryState(enabled: Bool, availableBiometryType: AvailableBiometryType)  {
        
    return cuckoo_manager.call(
    """
    didChangeAccessoryState(enabled: Bool, availableBiometryType: AvailableBiometryType)
    """,
            parameters: (enabled, availableBiometryType),
            escapingParameters: (enabled, availableBiometryType),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didChangeAccessoryState(enabled: enabled, availableBiometryType: availableBiometryType))
        
    }
    
    
    
    
    
     func didReceiveWrongPincode()  {
        
    return cuckoo_manager.call(
    """
    didReceiveWrongPincode()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveWrongPincode())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_PinSetupViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockPinSetupViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockPinSetupViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockPinSetupViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockPinSetupViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didRequestBiometryUsage<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(biometryType: M1, completionBlock: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(AvailableBiometryType, (Bool) -> Void)> where M1.MatchedType == AvailableBiometryType, M2.MatchedType == (Bool) -> Void {
            let matchers: [Cuckoo.ParameterMatcher<(AvailableBiometryType, (Bool) -> Void)>] = [wrap(matchable: biometryType) { $0.0 }, wrap(matchable: completionBlock) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupViewProtocol.self, method:
    """
    didRequestBiometryUsage(biometryType: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didChangeAccessoryState<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(enabled: M1, availableBiometryType: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool, AvailableBiometryType)> where M1.MatchedType == Bool, M2.MatchedType == AvailableBiometryType {
            let matchers: [Cuckoo.ParameterMatcher<(Bool, AvailableBiometryType)>] = [wrap(matchable: enabled) { $0.0 }, wrap(matchable: availableBiometryType) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupViewProtocol.self, method:
    """
    didChangeAccessoryState(enabled: Bool, availableBiometryType: AvailableBiometryType)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveWrongPincode() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupViewProtocol.self, method:
    """
    didReceiveWrongPincode()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_PinSetupViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didRequestBiometryUsage<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(biometryType: M1, completionBlock: M2) -> Cuckoo.__DoNotUse<(AvailableBiometryType, (Bool) -> Void), Void> where M1.MatchedType == AvailableBiometryType, M2.MatchedType == (Bool) -> Void {
            let matchers: [Cuckoo.ParameterMatcher<(AvailableBiometryType, (Bool) -> Void)>] = [wrap(matchable: biometryType) { $0.0 }, wrap(matchable: completionBlock) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didRequestBiometryUsage(biometryType: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didChangeAccessoryState<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(enabled: M1, availableBiometryType: M2) -> Cuckoo.__DoNotUse<(Bool, AvailableBiometryType), Void> where M1.MatchedType == Bool, M2.MatchedType == AvailableBiometryType {
            let matchers: [Cuckoo.ParameterMatcher<(Bool, AvailableBiometryType)>] = [wrap(matchable: enabled) { $0.0 }, wrap(matchable: availableBiometryType) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didChangeAccessoryState(enabled: Bool, availableBiometryType: AvailableBiometryType)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveWrongPincode() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didReceiveWrongPincode()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class PinSetupViewProtocolStub: PinSetupViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didRequestBiometryUsage(biometryType: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didChangeAccessoryState(enabled: Bool, availableBiometryType: AvailableBiometryType)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveWrongPincode()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockPinSetupPresenterProtocol: PinSetupPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = PinSetupPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_PinSetupPresenterProtocol
     typealias Verification = __VerificationProxy_PinSetupPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: PinSetupPresenterProtocol?

     func enableDefaultImplementation(_ stub: PinSetupPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didLoad(view: PinSetupViewProtocol)  {
        
    return cuckoo_manager.call(
    """
    didLoad(view: PinSetupViewProtocol)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didLoad(view: view))
        
    }
    
    
    
    
    
     func cancel()  {
        
    return cuckoo_manager.call(
    """
    cancel()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.cancel())
        
    }
    
    
    
    
    
     func activateBiometricAuth()  {
        
    return cuckoo_manager.call(
    """
    activateBiometricAuth()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateBiometricAuth())
        
    }
    
    
    
    
    
     func submit(pin: String)  {
        
    return cuckoo_manager.call(
    """
    submit(pin: String)
    """,
            parameters: (pin),
            escapingParameters: (pin),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.submit(pin: pin))
        
    }
    
    

     struct __StubbingProxy_PinSetupPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(PinSetupViewProtocol)> where M1.MatchedType == PinSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(PinSetupViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupPresenterProtocol.self, method:
    """
    didLoad(view: PinSetupViewProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func cancel() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupPresenterProtocol.self, method:
    """
    cancel()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateBiometricAuth() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupPresenterProtocol.self, method:
    """
    activateBiometricAuth()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func submit<M1: Cuckoo.Matchable>(pin: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String)> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: pin) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupPresenterProtocol.self, method:
    """
    submit(pin: String)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_PinSetupPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.__DoNotUse<(PinSetupViewProtocol), Void> where M1.MatchedType == PinSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(PinSetupViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    didLoad(view: PinSetupViewProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func cancel() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    cancel()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateBiometricAuth() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateBiometricAuth()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func submit<M1: Cuckoo.Matchable>(pin: M1) -> Cuckoo.__DoNotUse<(String), Void> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: pin) { $0 }]
            return cuckoo_manager.verify(
    """
    submit(pin: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class PinSetupPresenterProtocolStub: PinSetupPresenterProtocol {
    

    

    
    
    
    
     func didLoad(view: PinSetupViewProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func cancel()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateBiometricAuth()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func submit(pin: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockPinSetupInteractorInputProtocol: PinSetupInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = PinSetupInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_PinSetupInteractorInputProtocol
     typealias Verification = __VerificationProxy_PinSetupInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: PinSetupInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: PinSetupInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func process(pin: String)  {
        
    return cuckoo_manager.call(
    """
    process(pin: String)
    """,
            parameters: (pin),
            escapingParameters: (pin),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.process(pin: pin))
        
    }
    
    

     struct __StubbingProxy_PinSetupInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func process<M1: Cuckoo.Matchable>(pin: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String)> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: pin) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupInteractorInputProtocol.self, method:
    """
    process(pin: String)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_PinSetupInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func process<M1: Cuckoo.Matchable>(pin: M1) -> Cuckoo.__DoNotUse<(String), Void> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: pin) { $0 }]
            return cuckoo_manager.verify(
    """
    process(pin: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class PinSetupInteractorInputProtocolStub: PinSetupInteractorInputProtocol {
    

    

    
    
    
    
     func process(pin: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockPinSetupInteractorOutputProtocol: PinSetupInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = PinSetupInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_PinSetupInteractorOutputProtocol
     typealias Verification = __VerificationProxy_PinSetupInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: PinSetupInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: PinSetupInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didSavePin()  {
        
    return cuckoo_manager.call(
    """
    didSavePin()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSavePin())
        
    }
    
    
    
    
    
     func didStartWaitingBiometryDecision(type: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)  {
        
    return cuckoo_manager.call(
    """
    didStartWaitingBiometryDecision(type: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)
    """,
            parameters: (type, completionBlock),
            escapingParameters: (type, completionBlock),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartWaitingBiometryDecision(type: type, completionBlock: completionBlock))
        
    }
    
    
    
    
    
     func didChangeState(to state: PinSetupInteractor.PinSetupState)  {
        
    return cuckoo_manager.call(
    """
    didChangeState(to: PinSetupInteractor.PinSetupState)
    """,
            parameters: (state),
            escapingParameters: (state),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didChangeState(to: state))
        
    }
    
    

     struct __StubbingProxy_PinSetupInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didSavePin() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupInteractorOutputProtocol.self, method:
    """
    didSavePin()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartWaitingBiometryDecision<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(type: M1, completionBlock: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(AvailableBiometryType, (Bool) -> Void)> where M1.MatchedType == AvailableBiometryType, M2.MatchedType == (Bool) -> Void {
            let matchers: [Cuckoo.ParameterMatcher<(AvailableBiometryType, (Bool) -> Void)>] = [wrap(matchable: type) { $0.0 }, wrap(matchable: completionBlock) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupInteractorOutputProtocol.self, method:
    """
    didStartWaitingBiometryDecision(type: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didChangeState<M1: Cuckoo.Matchable>(to state: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(PinSetupInteractor.PinSetupState)> where M1.MatchedType == PinSetupInteractor.PinSetupState {
            let matchers: [Cuckoo.ParameterMatcher<(PinSetupInteractor.PinSetupState)>] = [wrap(matchable: state) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupInteractorOutputProtocol.self, method:
    """
    didChangeState(to: PinSetupInteractor.PinSetupState)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_PinSetupInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didSavePin() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didSavePin()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartWaitingBiometryDecision<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(type: M1, completionBlock: M2) -> Cuckoo.__DoNotUse<(AvailableBiometryType, (Bool) -> Void), Void> where M1.MatchedType == AvailableBiometryType, M2.MatchedType == (Bool) -> Void {
            let matchers: [Cuckoo.ParameterMatcher<(AvailableBiometryType, (Bool) -> Void)>] = [wrap(matchable: type) { $0.0 }, wrap(matchable: completionBlock) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didStartWaitingBiometryDecision(type: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didChangeState<M1: Cuckoo.Matchable>(to state: M1) -> Cuckoo.__DoNotUse<(PinSetupInteractor.PinSetupState), Void> where M1.MatchedType == PinSetupInteractor.PinSetupState {
            let matchers: [Cuckoo.ParameterMatcher<(PinSetupInteractor.PinSetupState)>] = [wrap(matchable: state) { $0 }]
            return cuckoo_manager.verify(
    """
    didChangeState(to: PinSetupInteractor.PinSetupState)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class PinSetupInteractorOutputProtocolStub: PinSetupInteractorOutputProtocol {
    

    

    
    
    
    
     func didSavePin()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartWaitingBiometryDecision(type: AvailableBiometryType, completionBlock: @escaping (Bool) -> Void)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didChangeState(to state: PinSetupInteractor.PinSetupState)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockPinSetupWireframeProtocol: PinSetupWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = PinSetupWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_PinSetupWireframeProtocol
     typealias Verification = __VerificationProxy_PinSetupWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: PinSetupWireframeProtocol?

     func enableDefaultImplementation(_ stub: PinSetupWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showMain(from view: PinSetupViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showMain(from: PinSetupViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showMain(from: view))
        
    }
    
    
    
    
    
     func showSignup(from view: PinSetupViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showSignup(from: PinSetupViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showSignup(from: view))
        
    }
    
    

     struct __StubbingProxy_PinSetupWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showMain<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(PinSetupViewProtocol?)> where M1.OptionalMatchedType == PinSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(PinSetupViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupWireframeProtocol.self, method:
    """
    showMain(from: PinSetupViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showSignup<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(PinSetupViewProtocol?)> where M1.OptionalMatchedType == PinSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(PinSetupViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockPinSetupWireframeProtocol.self, method:
    """
    showSignup(from: PinSetupViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_PinSetupWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showMain<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(PinSetupViewProtocol?), Void> where M1.OptionalMatchedType == PinSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(PinSetupViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showMain(from: PinSetupViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showSignup<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(PinSetupViewProtocol?), Void> where M1.OptionalMatchedType == PinSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(PinSetupViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showSignup(from: PinSetupViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class PinSetupWireframeProtocolStub: PinSetupWireframeProtocol {
    

    

    
    
    
    
     func showMain(from view: PinSetupViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showSignup(from view: PinSetupViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation






 class MockProfileViewProtocol: ProfileViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ProfileViewProtocol
    
     typealias Stubbing = __StubbingProxy_ProfileViewProtocol
     typealias Verification = __VerificationProxy_ProfileViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ProfileViewProtocol?

     func enableDefaultImplementation(_ stub: ProfileViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(state: ProfileViewState)  {
        
    return cuckoo_manager.call(
    """
    didReceive(state: ProfileViewState)
    """,
            parameters: (state),
            escapingParameters: (state),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(state: state))
        
    }
    
    

     struct __StubbingProxy_ProfileViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockProfileViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockProfileViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(state: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewState)> where M1.MatchedType == ProfileViewState {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewState)>] = [wrap(matchable: state) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileViewProtocol.self, method:
    """
    didReceive(state: ProfileViewState)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ProfileViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(state: M1) -> Cuckoo.__DoNotUse<(ProfileViewState), Void> where M1.MatchedType == ProfileViewState {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewState)>] = [wrap(matchable: state) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(state: ProfileViewState)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ProfileViewProtocolStub: ProfileViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(state: ProfileViewState)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockProfilePresenterProtocol: ProfilePresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ProfilePresenterProtocol
    
     typealias Stubbing = __StubbingProxy_ProfilePresenterProtocol
     typealias Verification = __VerificationProxy_ProfilePresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ProfilePresenterProtocol?

     func enableDefaultImplementation(_ stub: ProfilePresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didLoad(view: ProfileViewProtocol)  {
        
    return cuckoo_manager.call(
    """
    didLoad(view: ProfileViewProtocol)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didLoad(view: view))
        
    }
    
    
    
    
    
     func activateAccountDetails()  {
        
    return cuckoo_manager.call(
    """
    activateAccountDetails()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateAccountDetails())
        
    }
    
    
    
    
    
     func activateOption(_ option: ProfileOption)  {
        
    return cuckoo_manager.call(
    """
    activateOption(_: ProfileOption)
    """,
            parameters: (option),
            escapingParameters: (option),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateOption(option))
        
    }
    
    
    
    
    
     func logout()  {
        
    return cuckoo_manager.call(
    """
    logout()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.logout())
        
    }
    
    
    
    
    
     func switcherValueChanged(isOn: Bool, index: Int)  {
        
    return cuckoo_manager.call(
    """
    switcherValueChanged(isOn: Bool, index: Int)
    """,
            parameters: (isOn, index),
            escapingParameters: (isOn, index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.switcherValueChanged(isOn: isOn, index: index))
        
    }
    
    

     struct __StubbingProxy_ProfilePresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewProtocol)> where M1.MatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfilePresenterProtocol.self, method:
    """
    didLoad(view: ProfileViewProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateAccountDetails() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockProfilePresenterProtocol.self, method:
    """
    activateAccountDetails()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateOption<M1: Cuckoo.Matchable>(_ option: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileOption)> where M1.MatchedType == ProfileOption {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileOption)>] = [wrap(matchable: option) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfilePresenterProtocol.self, method:
    """
    activateOption(_: ProfileOption)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func logout() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockProfilePresenterProtocol.self, method:
    """
    logout()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func switcherValueChanged<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(isOn: M1, index: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool, Int)> where M1.MatchedType == Bool, M2.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Bool, Int)>] = [wrap(matchable: isOn) { $0.0 }, wrap(matchable: index) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfilePresenterProtocol.self, method:
    """
    switcherValueChanged(isOn: Bool, index: Int)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ProfilePresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.__DoNotUse<(ProfileViewProtocol), Void> where M1.MatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    didLoad(view: ProfileViewProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateAccountDetails() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateAccountDetails()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateOption<M1: Cuckoo.Matchable>(_ option: M1) -> Cuckoo.__DoNotUse<(ProfileOption), Void> where M1.MatchedType == ProfileOption {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileOption)>] = [wrap(matchable: option) { $0 }]
            return cuckoo_manager.verify(
    """
    activateOption(_: ProfileOption)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func logout() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    logout()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func switcherValueChanged<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(isOn: M1, index: M2) -> Cuckoo.__DoNotUse<(Bool, Int), Void> where M1.MatchedType == Bool, M2.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Bool, Int)>] = [wrap(matchable: isOn) { $0.0 }, wrap(matchable: index) { $0.1 }]
            return cuckoo_manager.verify(
    """
    switcherValueChanged(isOn: Bool, index: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ProfilePresenterProtocolStub: ProfilePresenterProtocol {
    

    

    
    
    
    
     func didLoad(view: ProfileViewProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateAccountDetails()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateOption(_ option: ProfileOption)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func logout()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func switcherValueChanged(isOn: Bool, index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockProfileInteractorInputProtocol: ProfileInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ProfileInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_ProfileInteractorInputProtocol
     typealias Verification = __VerificationProxy_ProfileInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ProfileInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: ProfileInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup(with output: ProfileInteractorOutputProtocol)  {
        
    return cuckoo_manager.call(
    """
    setup(with: ProfileInteractorOutputProtocol)
    """,
            parameters: (output),
            escapingParameters: (output),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup(with: output))
        
    }
    
    
    
    
    
     func updateWallet(_ wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    updateWallet(_: MetaAccountModel)
    """,
            parameters: (wallet),
            escapingParameters: (wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.updateWallet(wallet))
        
    }
    
    
    
    
    
     func logout(completion: @escaping () -> Void)  {
        
    return cuckoo_manager.call(
    """
    logout(completion: @escaping () -> Void)
    """,
            parameters: (completion),
            escapingParameters: (completion),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.logout(completion: completion))
        
    }
    
    
    
    
    
     func update(currency: Currency)  {
        
    return cuckoo_manager.call(
    """
    update(currency: Currency)
    """,
            parameters: (currency),
            escapingParameters: (currency),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.update(currency: currency))
        
    }
    
    

     struct __StubbingProxy_ProfileInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup<M1: Cuckoo.Matchable>(with output: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileInteractorOutputProtocol)> where M1.MatchedType == ProfileInteractorOutputProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileInteractorOutputProtocol)>] = [wrap(matchable: output) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileInteractorInputProtocol.self, method:
    """
    setup(with: ProfileInteractorOutputProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func updateWallet<M1: Cuckoo.Matchable>(_ wallet: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(MetaAccountModel)> where M1.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel)>] = [wrap(matchable: wallet) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileInteractorInputProtocol.self, method:
    """
    updateWallet(_: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func logout<M1: Cuckoo.Matchable>(completion: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(() -> Void)> where M1.MatchedType == () -> Void {
            let matchers: [Cuckoo.ParameterMatcher<(() -> Void)>] = [wrap(matchable: completion) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileInteractorInputProtocol.self, method:
    """
    logout(completion: @escaping () -> Void)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func update<M1: Cuckoo.Matchable>(currency: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Currency)> where M1.MatchedType == Currency {
            let matchers: [Cuckoo.ParameterMatcher<(Currency)>] = [wrap(matchable: currency) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileInteractorInputProtocol.self, method:
    """
    update(currency: Currency)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ProfileInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup<M1: Cuckoo.Matchable>(with output: M1) -> Cuckoo.__DoNotUse<(ProfileInteractorOutputProtocol), Void> where M1.MatchedType == ProfileInteractorOutputProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileInteractorOutputProtocol)>] = [wrap(matchable: output) { $0 }]
            return cuckoo_manager.verify(
    """
    setup(with: ProfileInteractorOutputProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func updateWallet<M1: Cuckoo.Matchable>(_ wallet: M1) -> Cuckoo.__DoNotUse<(MetaAccountModel), Void> where M1.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel)>] = [wrap(matchable: wallet) { $0 }]
            return cuckoo_manager.verify(
    """
    updateWallet(_: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func logout<M1: Cuckoo.Matchable>(completion: M1) -> Cuckoo.__DoNotUse<(() -> Void), Void> where M1.MatchedType == () -> Void {
            let matchers: [Cuckoo.ParameterMatcher<(() -> Void)>] = [wrap(matchable: completion) { $0 }]
            return cuckoo_manager.verify(
    """
    logout(completion: @escaping () -> Void)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func update<M1: Cuckoo.Matchable>(currency: M1) -> Cuckoo.__DoNotUse<(Currency), Void> where M1.MatchedType == Currency {
            let matchers: [Cuckoo.ParameterMatcher<(Currency)>] = [wrap(matchable: currency) { $0 }]
            return cuckoo_manager.verify(
    """
    update(currency: Currency)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ProfileInteractorInputProtocolStub: ProfileInteractorInputProtocol {
    

    

    
    
    
    
     func setup(with output: ProfileInteractorOutputProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func updateWallet(_ wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func logout(completion: @escaping () -> Void)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func update(currency: Currency)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockProfileInteractorOutputProtocol: ProfileInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ProfileInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_ProfileInteractorOutputProtocol
     typealias Verification = __VerificationProxy_ProfileInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ProfileInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: ProfileInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    didReceive(wallet: MetaAccountModel)
    """,
            parameters: (wallet),
            escapingParameters: (wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(wallet: wallet))
        
    }
    
    
    
    
    
     func didReceiveUserDataProvider(error: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceiveUserDataProvider(error: Error)
    """,
            parameters: (error),
            escapingParameters: (error),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveUserDataProvider(error: error))
        
    }
    
    
    
    
    
     func didRecieve(selectedCurrency: Currency)  {
        
    return cuckoo_manager.call(
    """
    didRecieve(selectedCurrency: Currency)
    """,
            parameters: (selectedCurrency),
            escapingParameters: (selectedCurrency),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRecieve(selectedCurrency: selectedCurrency))
        
    }
    
    
    
    
    
     func didReceiveWalletBalances(_ balances: Result<[MetaAccountId: WalletBalanceInfo], Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveWalletBalances(_: Result<[MetaAccountId: WalletBalanceInfo], Error>)
    """,
            parameters: (balances),
            escapingParameters: (balances),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveWalletBalances(balances))
        
    }
    
    

     struct __StubbingProxy_ProfileInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(wallet: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(MetaAccountModel)> where M1.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel)>] = [wrap(matchable: wallet) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileInteractorOutputProtocol.self, method:
    """
    didReceive(wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveUserDataProvider<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileInteractorOutputProtocol.self, method:
    """
    didReceiveUserDataProvider(error: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didRecieve<M1: Cuckoo.Matchable>(selectedCurrency: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Currency)> where M1.MatchedType == Currency {
            let matchers: [Cuckoo.ParameterMatcher<(Currency)>] = [wrap(matchable: selectedCurrency) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileInteractorOutputProtocol.self, method:
    """
    didRecieve(selectedCurrency: Currency)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveWalletBalances<M1: Cuckoo.Matchable>(_ balances: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<[MetaAccountId: WalletBalanceInfo], Error>)> where M1.MatchedType == Result<[MetaAccountId: WalletBalanceInfo], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[MetaAccountId: WalletBalanceInfo], Error>)>] = [wrap(matchable: balances) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileInteractorOutputProtocol.self, method:
    """
    didReceiveWalletBalances(_: Result<[MetaAccountId: WalletBalanceInfo], Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ProfileInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(wallet: M1) -> Cuckoo.__DoNotUse<(MetaAccountModel), Void> where M1.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(MetaAccountModel)>] = [wrap(matchable: wallet) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveUserDataProvider<M1: Cuckoo.Matchable>(error: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: error) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveUserDataProvider(error: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didRecieve<M1: Cuckoo.Matchable>(selectedCurrency: M1) -> Cuckoo.__DoNotUse<(Currency), Void> where M1.MatchedType == Currency {
            let matchers: [Cuckoo.ParameterMatcher<(Currency)>] = [wrap(matchable: selectedCurrency) { $0 }]
            return cuckoo_manager.verify(
    """
    didRecieve(selectedCurrency: Currency)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveWalletBalances<M1: Cuckoo.Matchable>(_ balances: M1) -> Cuckoo.__DoNotUse<(Result<[MetaAccountId: WalletBalanceInfo], Error>), Void> where M1.MatchedType == Result<[MetaAccountId: WalletBalanceInfo], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[MetaAccountId: WalletBalanceInfo], Error>)>] = [wrap(matchable: balances) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveWalletBalances(_: Result<[MetaAccountId: WalletBalanceInfo], Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ProfileInteractorOutputProtocolStub: ProfileInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceive(wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveUserDataProvider(error: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didRecieve(selectedCurrency: Currency)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveWalletBalances(_ balances: Result<[MetaAccountId: WalletBalanceInfo], Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockProfileWireframeProtocol: ProfileWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ProfileWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ProfileWireframeProtocol
     typealias Verification = __VerificationProxy_ProfileWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ProfileWireframeProtocol?

     func enableDefaultImplementation(_ stub: ProfileWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showAccountDetails(from view: ProfileViewProtocol?, metaAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showAccountDetails(from: ProfileViewProtocol?, metaAccount: MetaAccountModel)
    """,
            parameters: (view, metaAccount),
            escapingParameters: (view, metaAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showAccountDetails(from: view, metaAccount: metaAccount))
        
    }
    
    
    
    
    
     func showAccountSelection(from view: ProfileViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)  {
        
    return cuckoo_manager.call(
    """
    showAccountSelection(from: ProfileViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)
    """,
            parameters: (view, moduleOutput),
            escapingParameters: (view, moduleOutput),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showAccountSelection(from: view, moduleOutput: moduleOutput))
        
    }
    
    
    
    
    
     func showLanguageSelection(from view: ProfileViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showLanguageSelection(from: ProfileViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showLanguageSelection(from: view))
        
    }
    
    
    
    
    
     func showPincodeChange(from view: ProfileViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showPincodeChange(from: ProfileViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showPincodeChange(from: view))
        
    }
    
    
    
    
    
     func showAbout(from view: ProfileViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showAbout(from: ProfileViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showAbout(from: view))
        
    }
    
    
    
    
    
     func logout(from view: ProfileViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    logout(from: ProfileViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.logout(from: view))
        
    }
    
    
    
    
    
     func showCheckPincode(from view: ProfileViewProtocol?, output: CheckPincodeModuleOutput)  {
        
    return cuckoo_manager.call(
    """
    showCheckPincode(from: ProfileViewProtocol?, output: CheckPincodeModuleOutput)
    """,
            parameters: (view, output),
            escapingParameters: (view, output),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showCheckPincode(from: view, output: output))
        
    }
    
    
    
    
    
     func showSelectCurrency(from view: ProfileViewProtocol?, with: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showSelectCurrency(from: ProfileViewProtocol?, with: MetaAccountModel)
    """,
            parameters: (view, with),
            escapingParameters: (view, with),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showSelectCurrency(from: view, with: with))
        
    }
    
    
    
    
    
     func close(view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(view: ControllerBackedProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view: view))
        
    }
    
    
    
    
    
     func showPolkaswapDisclaimer(from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showPolkaswapDisclaimer(from: ControllerBackedProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showPolkaswapDisclaimer(from: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    
    
    
    
     func presentSuccessNotification(_ title: String, from view: ControllerBackedProtocol?, completion closure: (() -> Void)?)  {
        
    return cuckoo_manager.call(
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """,
            parameters: (title, view, closure),
            escapingParameters: (title, view, closure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentSuccessNotification(title, from: view, completion: closure))
        
    }
    
    

     struct __StubbingProxy_ProfileWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showAccountDetails<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, metaAccount: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewProtocol?, MetaAccountModel)> where M1.OptionalMatchedType == ProfileViewProtocol, M2.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: metaAccount) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    showAccountDetails(from: ProfileViewProtocol?, metaAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showAccountSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, moduleOutput: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewProtocol?, WalletsManagmentModuleOutput)> where M1.OptionalMatchedType == ProfileViewProtocol, M2.MatchedType == WalletsManagmentModuleOutput {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?, WalletsManagmentModuleOutput)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: moduleOutput) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    showAccountSelection(from: ProfileViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showLanguageSelection<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewProtocol?)> where M1.OptionalMatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    showLanguageSelection(from: ProfileViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showPincodeChange<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewProtocol?)> where M1.OptionalMatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    showPincodeChange(from: ProfileViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showAbout<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewProtocol?)> where M1.OptionalMatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    showAbout(from: ProfileViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func logout<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewProtocol?)> where M1.OptionalMatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    logout(from: ProfileViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showCheckPincode<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, output: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewProtocol?, CheckPincodeModuleOutput)> where M1.OptionalMatchedType == ProfileViewProtocol, M2.MatchedType == CheckPincodeModuleOutput {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?, CheckPincodeModuleOutput)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: output) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    showCheckPincode(from: ProfileViewProtocol?, output: CheckPincodeModuleOutput)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showSelectCurrency<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, with: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ProfileViewProtocol?, MetaAccountModel)> where M1.OptionalMatchedType == ProfileViewProtocol, M2.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: with) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    showSelectCurrency(from: ProfileViewProtocol?, with: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?)> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    close(view: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showPolkaswapDisclaimer<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?)> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    showPolkaswapDisclaimer(from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentSuccessNotification<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(_ title: M1, from view: M2, completion closure: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String, ControllerBackedProtocol?, (() -> Void)?)> where M1.MatchedType == String, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == (() -> Void) {
            let matchers: [Cuckoo.ParameterMatcher<(String, ControllerBackedProtocol?, (() -> Void)?)>] = [wrap(matchable: title) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: closure) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockProfileWireframeProtocol.self, method:
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ProfileWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showAccountDetails<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, metaAccount: M2) -> Cuckoo.__DoNotUse<(ProfileViewProtocol?, MetaAccountModel), Void> where M1.OptionalMatchedType == ProfileViewProtocol, M2.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: metaAccount) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showAccountDetails(from: ProfileViewProtocol?, metaAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showAccountSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, moduleOutput: M2) -> Cuckoo.__DoNotUse<(ProfileViewProtocol?, WalletsManagmentModuleOutput), Void> where M1.OptionalMatchedType == ProfileViewProtocol, M2.MatchedType == WalletsManagmentModuleOutput {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?, WalletsManagmentModuleOutput)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: moduleOutput) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showAccountSelection(from: ProfileViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showLanguageSelection<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(ProfileViewProtocol?), Void> where M1.OptionalMatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showLanguageSelection(from: ProfileViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showPincodeChange<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(ProfileViewProtocol?), Void> where M1.OptionalMatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showPincodeChange(from: ProfileViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showAbout<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(ProfileViewProtocol?), Void> where M1.OptionalMatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showAbout(from: ProfileViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func logout<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(ProfileViewProtocol?), Void> where M1.OptionalMatchedType == ProfileViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    logout(from: ProfileViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showCheckPincode<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, output: M2) -> Cuckoo.__DoNotUse<(ProfileViewProtocol?, CheckPincodeModuleOutput), Void> where M1.OptionalMatchedType == ProfileViewProtocol, M2.MatchedType == CheckPincodeModuleOutput {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?, CheckPincodeModuleOutput)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: output) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showCheckPincode(from: ProfileViewProtocol?, output: CheckPincodeModuleOutput)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showSelectCurrency<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, with: M2) -> Cuckoo.__DoNotUse<(ProfileViewProtocol?, MetaAccountModel), Void> where M1.OptionalMatchedType == ProfileViewProtocol, M2.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ProfileViewProtocol?, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: with) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showSelectCurrency(from: ProfileViewProtocol?, with: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(view: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showPolkaswapDisclaimer<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    showPolkaswapDisclaimer(from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentSuccessNotification<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(_ title: M1, from view: M2, completion closure: M3) -> Cuckoo.__DoNotUse<(String, ControllerBackedProtocol?, (() -> Void)?), Void> where M1.MatchedType == String, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == (() -> Void) {
            let matchers: [Cuckoo.ParameterMatcher<(String, ControllerBackedProtocol?, (() -> Void)?)>] = [wrap(matchable: title) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: closure) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ProfileWireframeProtocolStub: ProfileWireframeProtocol {
    

    

    
    
    
    
     func showAccountDetails(from view: ProfileViewProtocol?, metaAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showAccountSelection(from view: ProfileViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showLanguageSelection(from view: ProfileViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showPincodeChange(from view: ProfileViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showAbout(from view: ProfileViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func logout(from view: ProfileViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showCheckPincode(from view: ProfileViewProtocol?, output: CheckPincodeModuleOutput)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showSelectCurrency(from view: ProfileViewProtocol?, with: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func close(view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showPolkaswapDisclaimer(from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentSuccessNotification(_ title: String, from view: ControllerBackedProtocol?, completion closure: (() -> Void)?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import UIKit






 class MockRootViewProtocol: RootViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = RootViewProtocol
    
     typealias Stubbing = __StubbingProxy_RootViewProtocol
     typealias Verification = __VerificationProxy_RootViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: RootViewProtocol?

     func enableDefaultImplementation(_ stub: RootViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(state: RootViewState)  {
        
    return cuckoo_manager.call(
    """
    didReceive(state: RootViewState)
    """,
            parameters: (state),
            escapingParameters: (state),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(state: state))
        
    }
    
    

     struct __StubbingProxy_RootViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockRootViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockRootViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(state: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(RootViewState)> where M1.MatchedType == RootViewState {
            let matchers: [Cuckoo.ParameterMatcher<(RootViewState)>] = [wrap(matchable: state) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRootViewProtocol.self, method:
    """
    didReceive(state: RootViewState)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_RootViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(state: M1) -> Cuckoo.__DoNotUse<(RootViewState), Void> where M1.MatchedType == RootViewState {
            let matchers: [Cuckoo.ParameterMatcher<(RootViewState)>] = [wrap(matchable: state) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(state: RootViewState)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class RootViewProtocolStub: RootViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(state: RootViewState)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockRootPresenterProtocol: RootPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = RootPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_RootPresenterProtocol
     typealias Verification = __VerificationProxy_RootPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: RootPresenterProtocol?

     func enableDefaultImplementation(_ stub: RootPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func loadOnLaunch()  {
        
    return cuckoo_manager.call(
    """
    loadOnLaunch()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.loadOnLaunch())
        
    }
    
    
    
    
    
     func reload()  {
        
    return cuckoo_manager.call(
    """
    reload()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload())
        
    }
    
    

     struct __StubbingProxy_RootPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func loadOnLaunch() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockRootPresenterProtocol.self, method:
    """
    loadOnLaunch()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func reload() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockRootPresenterProtocol.self, method:
    """
    reload()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_RootPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func loadOnLaunch() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    loadOnLaunch()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func reload() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    reload()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class RootPresenterProtocolStub: RootPresenterProtocol {
    

    

    
    
    
    
     func loadOnLaunch()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func reload()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockRootWireframeProtocol: RootWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = RootWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_RootWireframeProtocol
     typealias Verification = __VerificationProxy_RootWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: RootWireframeProtocol?

     func enableDefaultImplementation(_ stub: RootWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showSplash(splashView: ControllerBackedProtocol?, on window: UIWindow)  {
        
    return cuckoo_manager.call(
    """
    showSplash(splashView: ControllerBackedProtocol?, on: UIWindow)
    """,
            parameters: (splashView, window),
            escapingParameters: (splashView, window),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showSplash(splashView: splashView, on: window))
        
    }
    
    
    
    
    
     func showLocalAuthentication(on window: UIWindow)  {
        
    return cuckoo_manager.call(
    """
    showLocalAuthentication(on: UIWindow)
    """,
            parameters: (window),
            escapingParameters: (window),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showLocalAuthentication(on: window))
        
    }
    
    
    
    
    
     func showOnboarding(on window: UIWindow)  {
        
    return cuckoo_manager.call(
    """
    showOnboarding(on: UIWindow)
    """,
            parameters: (window),
            escapingParameters: (window),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showOnboarding(on: window))
        
    }
    
    
    
    
    
     func showPincodeSetup(on window: UIWindow)  {
        
    return cuckoo_manager.call(
    """
    showPincodeSetup(on: UIWindow)
    """,
            parameters: (window),
            escapingParameters: (window),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showPincodeSetup(on: window))
        
    }
    
    
    
    
    
     func showBroken(on window: UIWindow)  {
        
    return cuckoo_manager.call(
    """
    showBroken(on: UIWindow)
    """,
            parameters: (window),
            escapingParameters: (window),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showBroken(on: window))
        
    }
    
    
    
    
    
     func showEducationStories(on window: UIWindow)  {
        
    return cuckoo_manager.call(
    """
    showEducationStories(on: UIWindow)
    """,
            parameters: (window),
            escapingParameters: (window),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showEducationStories(on: window))
        
    }
    
    

     struct __StubbingProxy_RootWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showSplash<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(splashView: M1, on window: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, UIWindow)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, UIWindow)>] = [wrap(matchable: splashView) { $0.0 }, wrap(matchable: window) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRootWireframeProtocol.self, method:
    """
    showSplash(splashView: ControllerBackedProtocol?, on: UIWindow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showLocalAuthentication<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UIWindow)> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRootWireframeProtocol.self, method:
    """
    showLocalAuthentication(on: UIWindow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showOnboarding<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UIWindow)> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRootWireframeProtocol.self, method:
    """
    showOnboarding(on: UIWindow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showPincodeSetup<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UIWindow)> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRootWireframeProtocol.self, method:
    """
    showPincodeSetup(on: UIWindow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showBroken<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UIWindow)> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRootWireframeProtocol.self, method:
    """
    showBroken(on: UIWindow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showEducationStories<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UIWindow)> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRootWireframeProtocol.self, method:
    """
    showEducationStories(on: UIWindow)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_RootWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showSplash<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(splashView: M1, on window: M2) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, UIWindow), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, UIWindow)>] = [wrap(matchable: splashView) { $0.0 }, wrap(matchable: window) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showSplash(splashView: ControllerBackedProtocol?, on: UIWindow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showLocalAuthentication<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.__DoNotUse<(UIWindow), Void> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return cuckoo_manager.verify(
    """
    showLocalAuthentication(on: UIWindow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showOnboarding<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.__DoNotUse<(UIWindow), Void> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return cuckoo_manager.verify(
    """
    showOnboarding(on: UIWindow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showPincodeSetup<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.__DoNotUse<(UIWindow), Void> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return cuckoo_manager.verify(
    """
    showPincodeSetup(on: UIWindow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showBroken<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.__DoNotUse<(UIWindow), Void> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return cuckoo_manager.verify(
    """
    showBroken(on: UIWindow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showEducationStories<M1: Cuckoo.Matchable>(on window: M1) -> Cuckoo.__DoNotUse<(UIWindow), Void> where M1.MatchedType == UIWindow {
            let matchers: [Cuckoo.ParameterMatcher<(UIWindow)>] = [wrap(matchable: window) { $0 }]
            return cuckoo_manager.verify(
    """
    showEducationStories(on: UIWindow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class RootWireframeProtocolStub: RootWireframeProtocol {
    

    

    
    
    
    
     func showSplash(splashView: ControllerBackedProtocol?, on window: UIWindow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showLocalAuthentication(on window: UIWindow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showOnboarding(on window: UIWindow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showPincodeSetup(on window: UIWindow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showBroken(on window: UIWindow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showEducationStories(on window: UIWindow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockRootInteractorInputProtocol: RootInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = RootInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_RootInteractorInputProtocol
     typealias Verification = __VerificationProxy_RootInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: RootInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: RootInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup(runMigrations: Bool)  {
        
    return cuckoo_manager.call(
    """
    setup(runMigrations: Bool)
    """,
            parameters: (runMigrations),
            escapingParameters: (runMigrations),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup(runMigrations: runMigrations))
        
    }
    
    

     struct __StubbingProxy_RootInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup<M1: Cuckoo.Matchable>(runMigrations: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool)> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: runMigrations) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRootInteractorInputProtocol.self, method:
    """
    setup(runMigrations: Bool)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_RootInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup<M1: Cuckoo.Matchable>(runMigrations: M1) -> Cuckoo.__DoNotUse<(Bool), Void> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: runMigrations) { $0 }]
            return cuckoo_manager.verify(
    """
    setup(runMigrations: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class RootInteractorInputProtocolStub: RootInteractorInputProtocol {
    

    

    
    
    
    
     func setup(runMigrations: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockRootInteractorOutputProtocol: RootInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = RootInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_RootInteractorOutputProtocol
     typealias Verification = __VerificationProxy_RootInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: RootInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: RootInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    

     struct __StubbingProxy_RootInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
    }

     struct __VerificationProxy_RootInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
    }
}


 class RootInteractorOutputProtocolStub: RootInteractorOutputProtocol {
    

    

    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockAnalyticsRewardDetailsViewProtocol: AnalyticsRewardDetailsViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AnalyticsRewardDetailsViewProtocol
    
     typealias Stubbing = __StubbingProxy_AnalyticsRewardDetailsViewProtocol
     typealias Verification = __VerificationProxy_AnalyticsRewardDetailsViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AnalyticsRewardDetailsViewProtocol?

     func enableDefaultImplementation(_ stub: AnalyticsRewardDetailsViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func bind(viewModel: LocalizableResource<AnalyticsRewardDetailsViewModel>)  {
        
    return cuckoo_manager.call(
    """
    bind(viewModel: LocalizableResource<AnalyticsRewardDetailsViewModel>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.bind(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_AnalyticsRewardDetailsViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAnalyticsRewardDetailsViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockAnalyticsRewardDetailsViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockAnalyticsRewardDetailsViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func bind<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<AnalyticsRewardDetailsViewModel>)> where M1.MatchedType == LocalizableResource<AnalyticsRewardDetailsViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AnalyticsRewardDetailsViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsViewProtocol.self, method:
    """
    bind(viewModel: LocalizableResource<AnalyticsRewardDetailsViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AnalyticsRewardDetailsViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func bind<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<AnalyticsRewardDetailsViewModel>), Void> where M1.MatchedType == LocalizableResource<AnalyticsRewardDetailsViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AnalyticsRewardDetailsViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    bind(viewModel: LocalizableResource<AnalyticsRewardDetailsViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AnalyticsRewardDetailsViewProtocolStub: AnalyticsRewardDetailsViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func bind(viewModel: LocalizableResource<AnalyticsRewardDetailsViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAnalyticsRewardDetailsPresenterProtocol: AnalyticsRewardDetailsPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AnalyticsRewardDetailsPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_AnalyticsRewardDetailsPresenterProtocol
     typealias Verification = __VerificationProxy_AnalyticsRewardDetailsPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AnalyticsRewardDetailsPresenterProtocol?

     func enableDefaultImplementation(_ stub: AnalyticsRewardDetailsPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func handleEventIdAction()  {
        
    return cuckoo_manager.call(
    """
    handleEventIdAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handleEventIdAction())
        
    }
    
    

     struct __StubbingProxy_AnalyticsRewardDetailsPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handleEventIdAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsPresenterProtocol.self, method:
    """
    handleEventIdAction()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AnalyticsRewardDetailsPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handleEventIdAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    handleEventIdAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AnalyticsRewardDetailsPresenterProtocolStub: AnalyticsRewardDetailsPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handleEventIdAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAnalyticsRewardDetailsInteractorInputProtocol: AnalyticsRewardDetailsInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AnalyticsRewardDetailsInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_AnalyticsRewardDetailsInteractorInputProtocol
     typealias Verification = __VerificationProxy_AnalyticsRewardDetailsInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AnalyticsRewardDetailsInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: AnalyticsRewardDetailsInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    

     struct __StubbingProxy_AnalyticsRewardDetailsInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
    }

     struct __VerificationProxy_AnalyticsRewardDetailsInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
    }
}


 class AnalyticsRewardDetailsInteractorInputProtocolStub: AnalyticsRewardDetailsInteractorInputProtocol {
    

    

    
}










 class MockAnalyticsRewardDetailsInteractorOutputProtocol: AnalyticsRewardDetailsInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AnalyticsRewardDetailsInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_AnalyticsRewardDetailsInteractorOutputProtocol
     typealias Verification = __VerificationProxy_AnalyticsRewardDetailsInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AnalyticsRewardDetailsInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: AnalyticsRewardDetailsInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    

     struct __StubbingProxy_AnalyticsRewardDetailsInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
    }

     struct __VerificationProxy_AnalyticsRewardDetailsInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
    }
}


 class AnalyticsRewardDetailsInteractorOutputProtocolStub: AnalyticsRewardDetailsInteractorOutputProtocol {
    

    

    
}










 class MockAnalyticsRewardDetailsWireframeProtocol: AnalyticsRewardDetailsWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AnalyticsRewardDetailsWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_AnalyticsRewardDetailsWireframeProtocol
     typealias Verification = __VerificationProxy_AnalyticsRewardDetailsWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AnalyticsRewardDetailsWireframeProtocol?

     func enableDefaultImplementation(_ stub: AnalyticsRewardDetailsWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func presentSuccessNotification(_ title: String, from view: ControllerBackedProtocol?, completion closure: (() -> Void)?)  {
        
    return cuckoo_manager.call(
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """,
            parameters: (title, view, closure),
            escapingParameters: (title, view, closure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentSuccessNotification(title, from: view, completion: closure))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    

     struct __StubbingProxy_AnalyticsRewardDetailsWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func presentSuccessNotification<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(_ title: M1, from view: M2, completion closure: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String, ControllerBackedProtocol?, (() -> Void)?)> where M1.MatchedType == String, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == (() -> Void) {
            let matchers: [Cuckoo.ParameterMatcher<(String, ControllerBackedProtocol?, (() -> Void)?)>] = [wrap(matchable: title) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: closure) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsWireframeProtocol.self, method:
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AnalyticsRewardDetailsWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func presentSuccessNotification<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(_ title: M1, from view: M2, completion closure: M3) -> Cuckoo.__DoNotUse<(String, ControllerBackedProtocol?, (() -> Void)?), Void> where M1.MatchedType == String, M2.OptionalMatchedType == ControllerBackedProtocol, M3.OptionalMatchedType == (() -> Void) {
            let matchers: [Cuckoo.ParameterMatcher<(String, ControllerBackedProtocol?, (() -> Void)?)>] = [wrap(matchable: title) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: closure) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentSuccessNotification(_: String, from: ControllerBackedProtocol?, completion: (() -> Void)?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AnalyticsRewardDetailsWireframeProtocolStub: AnalyticsRewardDetailsWireframeProtocol {
    

    

    
    
    
    
     func presentSuccessNotification(_ title: String, from view: ControllerBackedProtocol?, completion closure: (() -> Void)?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockAnalyticsRewardDetailsViewModelFactoryProtocol: AnalyticsRewardDetailsViewModelFactoryProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = AnalyticsRewardDetailsViewModelFactoryProtocol
    
     typealias Stubbing = __StubbingProxy_AnalyticsRewardDetailsViewModelFactoryProtocol
     typealias Verification = __VerificationProxy_AnalyticsRewardDetailsViewModelFactoryProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: AnalyticsRewardDetailsViewModelFactoryProtocol?

     func enableDefaultImplementation(_ stub: AnalyticsRewardDetailsViewModelFactoryProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func createViweModel(rewardModel: AnalyticsRewardDetailsModel) -> LocalizableResource<AnalyticsRewardDetailsViewModel> {
        
    return cuckoo_manager.call(
    """
    createViweModel(rewardModel: AnalyticsRewardDetailsModel) -> LocalizableResource<AnalyticsRewardDetailsViewModel>
    """,
            parameters: (rewardModel),
            escapingParameters: (rewardModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.createViweModel(rewardModel: rewardModel))
        
    }
    
    

     struct __StubbingProxy_AnalyticsRewardDetailsViewModelFactoryProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func createViweModel<M1: Cuckoo.Matchable>(rewardModel: M1) -> Cuckoo.ProtocolStubFunction<(AnalyticsRewardDetailsModel), LocalizableResource<AnalyticsRewardDetailsViewModel>> where M1.MatchedType == AnalyticsRewardDetailsModel {
            let matchers: [Cuckoo.ParameterMatcher<(AnalyticsRewardDetailsModel)>] = [wrap(matchable: rewardModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockAnalyticsRewardDetailsViewModelFactoryProtocol.self, method:
    """
    createViweModel(rewardModel: AnalyticsRewardDetailsModel) -> LocalizableResource<AnalyticsRewardDetailsViewModel>
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_AnalyticsRewardDetailsViewModelFactoryProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func createViweModel<M1: Cuckoo.Matchable>(rewardModel: M1) -> Cuckoo.__DoNotUse<(AnalyticsRewardDetailsModel), LocalizableResource<AnalyticsRewardDetailsViewModel>> where M1.MatchedType == AnalyticsRewardDetailsModel {
            let matchers: [Cuckoo.ParameterMatcher<(AnalyticsRewardDetailsModel)>] = [wrap(matchable: rewardModel) { $0 }]
            return cuckoo_manager.verify(
    """
    createViweModel(rewardModel: AnalyticsRewardDetailsModel) -> LocalizableResource<AnalyticsRewardDetailsViewModel>
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class AnalyticsRewardDetailsViewModelFactoryProtocolStub: AnalyticsRewardDetailsViewModelFactoryProtocol {
    

    

    
    
    
    
     func createViweModel(rewardModel: AnalyticsRewardDetailsModel) -> LocalizableResource<AnalyticsRewardDetailsViewModel>  {
        return DefaultValueRegistry.defaultValue(for: (LocalizableResource<AnalyticsRewardDetailsViewModel>).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockControllerAccountViewProtocol: ControllerAccountViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ControllerAccountViewProtocol
    
     typealias Stubbing = __StubbingProxy_ControllerAccountViewProtocol
     typealias Verification = __VerificationProxy_ControllerAccountViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ControllerAccountViewProtocol?

     func enableDefaultImplementation(_ stub: ControllerAccountViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func reload(with viewModel: ControllerAccountViewModel)  {
        
    return cuckoo_manager.call(
    """
    reload(with: ControllerAccountViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload(with: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_ControllerAccountViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockControllerAccountViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockControllerAccountViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockControllerAccountViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func reload<M1: Cuckoo.Matchable>(with viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerAccountViewModel)> where M1.MatchedType == ControllerAccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerAccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountViewProtocol.self, method:
    """
    reload(with: ControllerAccountViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ControllerAccountViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func reload<M1: Cuckoo.Matchable>(with viewModel: M1) -> Cuckoo.__DoNotUse<(ControllerAccountViewModel), Void> where M1.MatchedType == ControllerAccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerAccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    reload(with: ControllerAccountViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ControllerAccountViewProtocolStub: ControllerAccountViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func reload(with viewModel: ControllerAccountViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockControllerAccountViewModelFactoryProtocol: ControllerAccountViewModelFactoryProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ControllerAccountViewModelFactoryProtocol
    
     typealias Stubbing = __StubbingProxy_ControllerAccountViewModelFactoryProtocol
     typealias Verification = __VerificationProxy_ControllerAccountViewModelFactoryProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ControllerAccountViewModelFactoryProtocol?

     func enableDefaultImplementation(_ stub: ControllerAccountViewModelFactoryProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func createViewModel(stashItem: StashItem, stashAccountItem: ChainAccountResponse?, chosenAccountItem: ChainAccountResponse?) -> ControllerAccountViewModel {
        
    return cuckoo_manager.call(
    """
    createViewModel(stashItem: StashItem, stashAccountItem: ChainAccountResponse?, chosenAccountItem: ChainAccountResponse?) -> ControllerAccountViewModel
    """,
            parameters: (stashItem, stashAccountItem, chosenAccountItem),
            escapingParameters: (stashItem, stashAccountItem, chosenAccountItem),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.createViewModel(stashItem: stashItem, stashAccountItem: stashAccountItem, chosenAccountItem: chosenAccountItem))
        
    }
    
    

     struct __StubbingProxy_ControllerAccountViewModelFactoryProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func createViewModel<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(stashItem: M1, stashAccountItem: M2, chosenAccountItem: M3) -> Cuckoo.ProtocolStubFunction<(StashItem, ChainAccountResponse?, ChainAccountResponse?), ControllerAccountViewModel> where M1.MatchedType == StashItem, M2.OptionalMatchedType == ChainAccountResponse, M3.OptionalMatchedType == ChainAccountResponse {
            let matchers: [Cuckoo.ParameterMatcher<(StashItem, ChainAccountResponse?, ChainAccountResponse?)>] = [wrap(matchable: stashItem) { $0.0 }, wrap(matchable: stashAccountItem) { $0.1 }, wrap(matchable: chosenAccountItem) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountViewModelFactoryProtocol.self, method:
    """
    createViewModel(stashItem: StashItem, stashAccountItem: ChainAccountResponse?, chosenAccountItem: ChainAccountResponse?) -> ControllerAccountViewModel
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ControllerAccountViewModelFactoryProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func createViewModel<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable>(stashItem: M1, stashAccountItem: M2, chosenAccountItem: M3) -> Cuckoo.__DoNotUse<(StashItem, ChainAccountResponse?, ChainAccountResponse?), ControllerAccountViewModel> where M1.MatchedType == StashItem, M2.OptionalMatchedType == ChainAccountResponse, M3.OptionalMatchedType == ChainAccountResponse {
            let matchers: [Cuckoo.ParameterMatcher<(StashItem, ChainAccountResponse?, ChainAccountResponse?)>] = [wrap(matchable: stashItem) { $0.0 }, wrap(matchable: stashAccountItem) { $0.1 }, wrap(matchable: chosenAccountItem) { $0.2 }]
            return cuckoo_manager.verify(
    """
    createViewModel(stashItem: StashItem, stashAccountItem: ChainAccountResponse?, chosenAccountItem: ChainAccountResponse?) -> ControllerAccountViewModel
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ControllerAccountViewModelFactoryProtocolStub: ControllerAccountViewModelFactoryProtocol {
    

    

    
    
    
    
     func createViewModel(stashItem: StashItem, stashAccountItem: ChainAccountResponse?, chosenAccountItem: ChainAccountResponse?) -> ControllerAccountViewModel  {
        return DefaultValueRegistry.defaultValue(for: (ControllerAccountViewModel).self)
    }
    
    
}










 class MockControllerAccountPresenterProtocol: ControllerAccountPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ControllerAccountPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_ControllerAccountPresenterProtocol
     typealias Verification = __VerificationProxy_ControllerAccountPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ControllerAccountPresenterProtocol?

     func enableDefaultImplementation(_ stub: ControllerAccountPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func handleStashAction()  {
        
    return cuckoo_manager.call(
    """
    handleStashAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handleStashAction())
        
    }
    
    
    
    
    
     func handleControllerAction()  {
        
    return cuckoo_manager.call(
    """
    handleControllerAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handleControllerAction())
        
    }
    
    
    
    
    
     func selectLearnMore()  {
        
    return cuckoo_manager.call(
    """
    selectLearnMore()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectLearnMore())
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    

     struct __StubbingProxy_ControllerAccountPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handleStashAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountPresenterProtocol.self, method:
    """
    handleStashAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handleControllerAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountPresenterProtocol.self, method:
    """
    handleControllerAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectLearnMore() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountPresenterProtocol.self, method:
    """
    selectLearnMore()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ControllerAccountPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handleStashAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    handleStashAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handleControllerAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    handleControllerAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectLearnMore() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectLearnMore()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ControllerAccountPresenterProtocolStub: ControllerAccountPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handleStashAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handleControllerAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectLearnMore()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockControllerAccountInteractorInputProtocol: ControllerAccountInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ControllerAccountInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_ControllerAccountInteractorInputProtocol
     typealias Verification = __VerificationProxy_ControllerAccountInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ControllerAccountInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: ControllerAccountInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(for account: ChainAccountResponse)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(for: ChainAccountResponse)
    """,
            parameters: (account),
            escapingParameters: (account),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(for: account))
        
    }
    
    
    
    
    
     func fetchLedger(controllerAddress: AccountAddress)  {
        
    return cuckoo_manager.call(
    """
    fetchLedger(controllerAddress: AccountAddress)
    """,
            parameters: (controllerAddress),
            escapingParameters: (controllerAddress),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.fetchLedger(controllerAddress: controllerAddress))
        
    }
    
    
    
    
    
     func fetchControllerAccountInfo(controllerAddress: AccountAddress)  {
        
    return cuckoo_manager.call(
    """
    fetchControllerAccountInfo(controllerAddress: AccountAddress)
    """,
            parameters: (controllerAddress),
            escapingParameters: (controllerAddress),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.fetchControllerAccountInfo(controllerAddress: controllerAddress))
        
    }
    
    

     struct __StubbingProxy_ControllerAccountInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.Matchable>(for account: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainAccountResponse)> where M1.MatchedType == ChainAccountResponse {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAccountResponse)>] = [wrap(matchable: account) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorInputProtocol.self, method:
    """
    estimateFee(for: ChainAccountResponse)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func fetchLedger<M1: Cuckoo.Matchable>(controllerAddress: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountAddress)> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: controllerAddress) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorInputProtocol.self, method:
    """
    fetchLedger(controllerAddress: AccountAddress)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func fetchControllerAccountInfo<M1: Cuckoo.Matchable>(controllerAddress: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountAddress)> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: controllerAddress) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorInputProtocol.self, method:
    """
    fetchControllerAccountInfo(controllerAddress: AccountAddress)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ControllerAccountInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.Matchable>(for account: M1) -> Cuckoo.__DoNotUse<(ChainAccountResponse), Void> where M1.MatchedType == ChainAccountResponse {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAccountResponse)>] = [wrap(matchable: account) { $0 }]
            return cuckoo_manager.verify(
    """
    estimateFee(for: ChainAccountResponse)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func fetchLedger<M1: Cuckoo.Matchable>(controllerAddress: M1) -> Cuckoo.__DoNotUse<(AccountAddress), Void> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: controllerAddress) { $0 }]
            return cuckoo_manager.verify(
    """
    fetchLedger(controllerAddress: AccountAddress)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func fetchControllerAccountInfo<M1: Cuckoo.Matchable>(controllerAddress: M1) -> Cuckoo.__DoNotUse<(AccountAddress), Void> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: controllerAddress) { $0 }]
            return cuckoo_manager.verify(
    """
    fetchControllerAccountInfo(controllerAddress: AccountAddress)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ControllerAccountInteractorInputProtocolStub: ControllerAccountInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(for account: ChainAccountResponse)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func fetchLedger(controllerAddress: AccountAddress)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func fetchControllerAccountInfo(controllerAddress: AccountAddress)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockControllerAccountInteractorOutputProtocol: ControllerAccountInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ControllerAccountInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_ControllerAccountInteractorOutputProtocol
     typealias Verification = __VerificationProxy_ControllerAccountInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ControllerAccountInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: ControllerAccountInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceiveStashItem(result: Result<StashItem?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStashItem(result: result))
        
    }
    
    
    
    
    
     func didReceiveStashAccount(result: Result<ChainAccountResponse?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStashAccount(result: Result<ChainAccountResponse?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStashAccount(result: result))
        
    }
    
    
    
    
    
     func didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveControllerAccount(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccounts(result: result))
        
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>, address: AccountAddress)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>, address: AccountAddress)
    """,
            parameters: (result, address),
            escapingParameters: (result, address),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result, address: address))
        
    }
    
    
    
    
    
     func didReceiveStakingLedger(result: Result<StakingLedger?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStakingLedger(result: Result<StakingLedger?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStakingLedger(result: result))
        
    }
    
    

     struct __StubbingProxy_ControllerAccountInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceiveStashItem<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<StashItem?, Error>)> where M1.MatchedType == Result<StashItem?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StashItem?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorOutputProtocol.self, method:
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveStashAccount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ChainAccountResponse?, Error>)> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorOutputProtocol.self, method:
    """
    didReceiveStashAccount(result: Result<ChainAccountResponse?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveControllerAccount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ChainAccountResponse?, Error>)> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorOutputProtocol.self, method:
    """
    didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccounts<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<[ChainAccountResponse], Error>)> where M1.MatchedType == Result<[ChainAccountResponse], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[ChainAccountResponse], Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorOutputProtocol.self, method:
    """
    didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RuntimeDispatchInfo, Error>)> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorOutputProtocol.self, method:
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(result: M1, address: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>, AccountAddress)> where M1.MatchedType == Result<AccountInfo?, Error>, M2.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>, AccountAddress)>] = [wrap(matchable: result) { $0.0 }, wrap(matchable: address) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>, address: AccountAddress)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveStakingLedger<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<StakingLedger?, Error>)> where M1.MatchedType == Result<StakingLedger?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StakingLedger?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountInteractorOutputProtocol.self, method:
    """
    didReceiveStakingLedger(result: Result<StakingLedger?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ControllerAccountInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceiveStashItem<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<StashItem?, Error>), Void> where M1.MatchedType == Result<StashItem?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StashItem?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveStashAccount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ChainAccountResponse?, Error>), Void> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStashAccount(result: Result<ChainAccountResponse?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveControllerAccount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ChainAccountResponse?, Error>), Void> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccounts<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<[ChainAccountResponse], Error>), Void> where M1.MatchedType == Result<[ChainAccountResponse], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[ChainAccountResponse], Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RuntimeDispatchInfo, Error>), Void> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(result: M1, address: M2) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>, AccountAddress), Void> where M1.MatchedType == Result<AccountInfo?, Error>, M2.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>, AccountAddress)>] = [wrap(matchable: result) { $0.0 }, wrap(matchable: address) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>, address: AccountAddress)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveStakingLedger<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<StakingLedger?, Error>), Void> where M1.MatchedType == Result<StakingLedger?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StakingLedger?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStakingLedger(result: Result<StakingLedger?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ControllerAccountInteractorOutputProtocolStub: ControllerAccountInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceiveStashItem(result: Result<StashItem?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveStashAccount(result: Result<ChainAccountResponse?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>, address: AccountAddress)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveStakingLedger(result: Result<StakingLedger?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockControllerAccountWireframeProtocol: ControllerAccountWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ControllerAccountWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ControllerAccountWireframeProtocol
     typealias Verification = __VerificationProxy_ControllerAccountWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ControllerAccountWireframeProtocol?

     func enableDefaultImplementation(_ stub: ControllerAccountWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showConfirmation(from view: ControllerBackedProtocol?, controllerAccountItem: ChainAccountResponse, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showConfirmation(from: ControllerBackedProtocol?, controllerAccountItem: ChainAccountResponse, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, controllerAccountItem, asset, chain, selectedAccount),
            escapingParameters: (view, controllerAccountItem, asset, chain, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showConfirmation(from: view, controllerAccountItem: controllerAccountItem, asset: asset, chain: chain, selectedAccount: selectedAccount))
        
    }
    
    
    
    
    
     func close(view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(view: ControllerBackedProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view: view))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    
    
    
    
     func presentAccountSelection(_ accounts: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from view: ControllerBackedProtocol?, context: AnyObject?)  {
        
    return cuckoo_manager.call(
    """
    presentAccountSelection(_: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from: ControllerBackedProtocol?, context: AnyObject?)
    """,
            parameters: (accounts, selectedAccountItem, title, delegate, view, context),
            escapingParameters: (accounts, selectedAccountItem, title, delegate, view, context),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentAccountSelection(accounts, selectedAccountItem: selectedAccountItem, title: title, delegate: delegate, from: view, context: context))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_ControllerAccountWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showConfirmation<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, controllerAccountItem: M2, asset: M3, chain: M4, selectedAccount: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAccountResponse, AssetModel, ChainModel, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAccountResponse, M3.MatchedType == AssetModel, M4.MatchedType == ChainModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAccountResponse, AssetModel, ChainModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: controllerAccountItem) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: chain) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountWireframeProtocol.self, method:
    """
    showConfirmation(from: ControllerBackedProtocol?, controllerAccountItem: ChainAccountResponse, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?)> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountWireframeProtocol.self, method:
    """
    close(view: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentAccountSelection<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable, M6: Cuckoo.OptionalMatchable>(_ accounts: M1, selectedAccountItem: M2, title: M3, delegate: M4, from view: M5, context: M6) -> Cuckoo.ProtocolStubNoReturnFunction<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?)> where M1.MatchedType == [ChainAccountResponse], M2.OptionalMatchedType == ChainAccountResponse, M3.MatchedType == LocalizableResource<String>, M4.MatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == ControllerBackedProtocol, M6.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?)>] = [wrap(matchable: accounts) { $0.0 }, wrap(matchable: selectedAccountItem) { $0.1 }, wrap(matchable: title) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: view) { $0.4 }, wrap(matchable: context) { $0.5 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountWireframeProtocol.self, method:
    """
    presentAccountSelection(_: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from: ControllerBackedProtocol?, context: AnyObject?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockControllerAccountWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ControllerAccountWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showConfirmation<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, controllerAccountItem: M2, asset: M3, chain: M4, selectedAccount: M5) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAccountResponse, AssetModel, ChainModel, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAccountResponse, M3.MatchedType == AssetModel, M4.MatchedType == ChainModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAccountResponse, AssetModel, ChainModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: controllerAccountItem) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: chain) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return cuckoo_manager.verify(
    """
    showConfirmation(from: ControllerBackedProtocol?, controllerAccountItem: ChainAccountResponse, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(view: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentAccountSelection<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable, M6: Cuckoo.OptionalMatchable>(_ accounts: M1, selectedAccountItem: M2, title: M3, delegate: M4, from view: M5, context: M6) -> Cuckoo.__DoNotUse<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?), Void> where M1.MatchedType == [ChainAccountResponse], M2.OptionalMatchedType == ChainAccountResponse, M3.MatchedType == LocalizableResource<String>, M4.MatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == ControllerBackedProtocol, M6.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?)>] = [wrap(matchable: accounts) { $0.0 }, wrap(matchable: selectedAccountItem) { $0.1 }, wrap(matchable: title) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: view) { $0.4 }, wrap(matchable: context) { $0.5 }]
            return cuckoo_manager.verify(
    """
    presentAccountSelection(_: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from: ControllerBackedProtocol?, context: AnyObject?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ControllerAccountWireframeProtocolStub: ControllerAccountWireframeProtocol {
    

    

    
    
    
    
     func showConfirmation(from view: ControllerBackedProtocol?, controllerAccountItem: ChainAccountResponse, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func close(view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentAccountSelection(_ accounts: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from view: ControllerBackedProtocol?, context: AnyObject?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import RobinHood






 class MockValidatorOperationFactoryProtocol: ValidatorOperationFactoryProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorOperationFactoryProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorOperationFactoryProtocol
     typealias Verification = __VerificationProxy_ValidatorOperationFactoryProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorOperationFactoryProtocol?

     func enableDefaultImplementation(_ stub: ValidatorOperationFactoryProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func nomination(accountId: AccountId) -> CompoundOperationWrapper<Nomination?> {
        
    return cuckoo_manager.call(
    """
    nomination(accountId: AccountId) -> CompoundOperationWrapper<Nomination?>
    """,
            parameters: (accountId),
            escapingParameters: (accountId),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.nomination(accountId: accountId))
        
    }
    
    
    
    
    
     func allElectedOperation() -> CompoundOperationWrapper<[ElectedValidatorInfo]> {
        
    return cuckoo_manager.call(
    """
    allElectedOperation() -> CompoundOperationWrapper<[ElectedValidatorInfo]>
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.allElectedOperation())
        
    }
    
    
    
    
    
     func allSelectedOperation(by nomination: Nomination, nominatorAddress: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]> {
        
    return cuckoo_manager.call(
    """
    allSelectedOperation(by: Nomination, nominatorAddress: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """,
            parameters: (nomination, nominatorAddress),
            escapingParameters: (nomination, nominatorAddress),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.allSelectedOperation(by: nomination, nominatorAddress: nominatorAddress))
        
    }
    
    
    
    
    
     func activeValidatorsOperation(for nominatorAddress: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]> {
        
    return cuckoo_manager.call(
    """
    activeValidatorsOperation(for: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """,
            parameters: (nominatorAddress),
            escapingParameters: (nominatorAddress),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activeValidatorsOperation(for: nominatorAddress))
        
    }
    
    
    
    
    
     func pendingValidatorsOperation(for accountIds: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]> {
        
    return cuckoo_manager.call(
    """
    pendingValidatorsOperation(for: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """,
            parameters: (accountIds),
            escapingParameters: (accountIds),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.pendingValidatorsOperation(for: accountIds))
        
    }
    
    
    
    
    
     func wannabeValidatorsOperation(for accountIdList: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]> {
        
    return cuckoo_manager.call(
    """
    wannabeValidatorsOperation(for: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """,
            parameters: (accountIdList),
            escapingParameters: (accountIdList),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.wannabeValidatorsOperation(for: accountIdList))
        
    }
    
    

     struct __StubbingProxy_ValidatorOperationFactoryProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func nomination<M1: Cuckoo.Matchable>(accountId: M1) -> Cuckoo.ProtocolStubFunction<(AccountId), CompoundOperationWrapper<Nomination?>> where M1.MatchedType == AccountId {
            let matchers: [Cuckoo.ParameterMatcher<(AccountId)>] = [wrap(matchable: accountId) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorOperationFactoryProtocol.self, method:
    """
    nomination(accountId: AccountId) -> CompoundOperationWrapper<Nomination?>
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func allElectedOperation() -> Cuckoo.ProtocolStubFunction<(), CompoundOperationWrapper<[ElectedValidatorInfo]>> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorOperationFactoryProtocol.self, method:
    """
    allElectedOperation() -> CompoundOperationWrapper<[ElectedValidatorInfo]>
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func allSelectedOperation<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(by nomination: M1, nominatorAddress: M2) -> Cuckoo.ProtocolStubFunction<(Nomination, AccountAddress), CompoundOperationWrapper<[SelectedValidatorInfo]>> where M1.MatchedType == Nomination, M2.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(Nomination, AccountAddress)>] = [wrap(matchable: nomination) { $0.0 }, wrap(matchable: nominatorAddress) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorOperationFactoryProtocol.self, method:
    """
    allSelectedOperation(by: Nomination, nominatorAddress: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activeValidatorsOperation<M1: Cuckoo.Matchable>(for nominatorAddress: M1) -> Cuckoo.ProtocolStubFunction<(AccountAddress), CompoundOperationWrapper<[SelectedValidatorInfo]>> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: nominatorAddress) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorOperationFactoryProtocol.self, method:
    """
    activeValidatorsOperation(for: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func pendingValidatorsOperation<M1: Cuckoo.Matchable>(for accountIds: M1) -> Cuckoo.ProtocolStubFunction<([AccountId]), CompoundOperationWrapper<[SelectedValidatorInfo]>> where M1.MatchedType == [AccountId] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountId])>] = [wrap(matchable: accountIds) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorOperationFactoryProtocol.self, method:
    """
    pendingValidatorsOperation(for: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func wannabeValidatorsOperation<M1: Cuckoo.Matchable>(for accountIdList: M1) -> Cuckoo.ProtocolStubFunction<([AccountId]), CompoundOperationWrapper<[SelectedValidatorInfo]>> where M1.MatchedType == [AccountId] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountId])>] = [wrap(matchable: accountIdList) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorOperationFactoryProtocol.self, method:
    """
    wannabeValidatorsOperation(for: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorOperationFactoryProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func nomination<M1: Cuckoo.Matchable>(accountId: M1) -> Cuckoo.__DoNotUse<(AccountId), CompoundOperationWrapper<Nomination?>> where M1.MatchedType == AccountId {
            let matchers: [Cuckoo.ParameterMatcher<(AccountId)>] = [wrap(matchable: accountId) { $0 }]
            return cuckoo_manager.verify(
    """
    nomination(accountId: AccountId) -> CompoundOperationWrapper<Nomination?>
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func allElectedOperation() -> Cuckoo.__DoNotUse<(), CompoundOperationWrapper<[ElectedValidatorInfo]>> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    allElectedOperation() -> CompoundOperationWrapper<[ElectedValidatorInfo]>
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func allSelectedOperation<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(by nomination: M1, nominatorAddress: M2) -> Cuckoo.__DoNotUse<(Nomination, AccountAddress), CompoundOperationWrapper<[SelectedValidatorInfo]>> where M1.MatchedType == Nomination, M2.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(Nomination, AccountAddress)>] = [wrap(matchable: nomination) { $0.0 }, wrap(matchable: nominatorAddress) { $0.1 }]
            return cuckoo_manager.verify(
    """
    allSelectedOperation(by: Nomination, nominatorAddress: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activeValidatorsOperation<M1: Cuckoo.Matchable>(for nominatorAddress: M1) -> Cuckoo.__DoNotUse<(AccountAddress), CompoundOperationWrapper<[SelectedValidatorInfo]>> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: nominatorAddress) { $0 }]
            return cuckoo_manager.verify(
    """
    activeValidatorsOperation(for: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func pendingValidatorsOperation<M1: Cuckoo.Matchable>(for accountIds: M1) -> Cuckoo.__DoNotUse<([AccountId]), CompoundOperationWrapper<[SelectedValidatorInfo]>> where M1.MatchedType == [AccountId] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountId])>] = [wrap(matchable: accountIds) { $0 }]
            return cuckoo_manager.verify(
    """
    pendingValidatorsOperation(for: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func wannabeValidatorsOperation<M1: Cuckoo.Matchable>(for accountIdList: M1) -> Cuckoo.__DoNotUse<([AccountId]), CompoundOperationWrapper<[SelectedValidatorInfo]>> where M1.MatchedType == [AccountId] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountId])>] = [wrap(matchable: accountIdList) { $0 }]
            return cuckoo_manager.verify(
    """
    wannabeValidatorsOperation(for: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]>
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorOperationFactoryProtocolStub: ValidatorOperationFactoryProtocol {
    

    

    
    
    
    
     func nomination(accountId: AccountId) -> CompoundOperationWrapper<Nomination?>  {
        return DefaultValueRegistry.defaultValue(for: (CompoundOperationWrapper<Nomination?>).self)
    }
    
    
    
    
    
     func allElectedOperation() -> CompoundOperationWrapper<[ElectedValidatorInfo]>  {
        return DefaultValueRegistry.defaultValue(for: (CompoundOperationWrapper<[ElectedValidatorInfo]>).self)
    }
    
    
    
    
    
     func allSelectedOperation(by nomination: Nomination, nominatorAddress: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]>  {
        return DefaultValueRegistry.defaultValue(for: (CompoundOperationWrapper<[SelectedValidatorInfo]>).self)
    }
    
    
    
    
    
     func activeValidatorsOperation(for nominatorAddress: AccountAddress) -> CompoundOperationWrapper<[SelectedValidatorInfo]>  {
        return DefaultValueRegistry.defaultValue(for: (CompoundOperationWrapper<[SelectedValidatorInfo]>).self)
    }
    
    
    
    
    
     func pendingValidatorsOperation(for accountIds: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]>  {
        return DefaultValueRegistry.defaultValue(for: (CompoundOperationWrapper<[SelectedValidatorInfo]>).self)
    }
    
    
    
    
    
     func wannabeValidatorsOperation(for accountIdList: [AccountId]) -> CompoundOperationWrapper<[SelectedValidatorInfo]>  {
        return DefaultValueRegistry.defaultValue(for: (CompoundOperationWrapper<[SelectedValidatorInfo]>).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockCustomValidatorListViewProtocol: CustomValidatorListViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CustomValidatorListViewProtocol
    
     typealias Stubbing = __StubbingProxy_CustomValidatorListViewProtocol
     typealias Verification = __VerificationProxy_CustomValidatorListViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CustomValidatorListViewProtocol?

     func enableDefaultImplementation(_ stub: CustomValidatorListViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func reload(_ viewModel: CustomValidatorListViewModel, at indexes: [Int]?)  {
        
    return cuckoo_manager.call(
    """
    reload(_: CustomValidatorListViewModel, at: [Int]?)
    """,
            parameters: (viewModel, indexes),
            escapingParameters: (viewModel, indexes),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload(viewModel, at: indexes))
        
    }
    
    
    
    
    
     func setFilterAppliedState(to state: Bool)  {
        
    return cuckoo_manager.call(
    """
    setFilterAppliedState(to: Bool)
    """,
            parameters: (state),
            escapingParameters: (state),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setFilterAppliedState(to: state))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_CustomValidatorListViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCustomValidatorListViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockCustomValidatorListViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockCustomValidatorListViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func reload<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(_ viewModel: M1, at indexes: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(CustomValidatorListViewModel, [Int]?)> where M1.MatchedType == CustomValidatorListViewModel, M2.OptionalMatchedType == [Int] {
            let matchers: [Cuckoo.ParameterMatcher<(CustomValidatorListViewModel, [Int]?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: indexes) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListViewProtocol.self, method:
    """
    reload(_: CustomValidatorListViewModel, at: [Int]?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func setFilterAppliedState<M1: Cuckoo.Matchable>(to state: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool)> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: state) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListViewProtocol.self, method:
    """
    setFilterAppliedState(to: Bool)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CustomValidatorListViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func reload<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(_ viewModel: M1, at indexes: M2) -> Cuckoo.__DoNotUse<(CustomValidatorListViewModel, [Int]?), Void> where M1.MatchedType == CustomValidatorListViewModel, M2.OptionalMatchedType == [Int] {
            let matchers: [Cuckoo.ParameterMatcher<(CustomValidatorListViewModel, [Int]?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: indexes) { $0.1 }]
            return cuckoo_manager.verify(
    """
    reload(_: CustomValidatorListViewModel, at: [Int]?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func setFilterAppliedState<M1: Cuckoo.Matchable>(to state: M1) -> Cuckoo.__DoNotUse<(Bool), Void> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: state) { $0 }]
            return cuckoo_manager.verify(
    """
    setFilterAppliedState(to: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CustomValidatorListViewProtocolStub: CustomValidatorListViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func reload(_ viewModel: CustomValidatorListViewModel, at indexes: [Int]?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func setFilterAppliedState(to state: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCustomValidatorListPresenterProtocol: CustomValidatorListPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CustomValidatorListPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_CustomValidatorListPresenterProtocol
     typealias Verification = __VerificationProxy_CustomValidatorListPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CustomValidatorListPresenterProtocol?

     func enableDefaultImplementation(_ stub: CustomValidatorListPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func fillWithRecommended()  {
        
    return cuckoo_manager.call(
    """
    fillWithRecommended()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.fillWithRecommended())
        
    }
    
    
    
    
    
     func clearFilter()  {
        
    return cuckoo_manager.call(
    """
    clearFilter()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.clearFilter())
        
    }
    
    
    
    
    
     func deselectAll()  {
        
    return cuckoo_manager.call(
    """
    deselectAll()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.deselectAll())
        
    }
    
    
    
    
    
     func changeValidatorSelection(address: String)  {
        
    return cuckoo_manager.call(
    """
    changeValidatorSelection(address: String)
    """,
            parameters: (address),
            escapingParameters: (address),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.changeValidatorSelection(address: address))
        
    }
    
    
    
    
    
     func didSelectValidator(address: String)  {
        
    return cuckoo_manager.call(
    """
    didSelectValidator(address: String)
    """,
            parameters: (address),
            escapingParameters: (address),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSelectValidator(address: address))
        
    }
    
    
    
    
    
     func presentFilter()  {
        
    return cuckoo_manager.call(
    """
    presentFilter()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentFilter())
        
    }
    
    
    
    
    
     func presentSearch()  {
        
    return cuckoo_manager.call(
    """
    presentSearch()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentSearch())
        
    }
    
    
    
    
    
     func changeIdentityFilterValue()  {
        
    return cuckoo_manager.call(
    """
    changeIdentityFilterValue()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.changeIdentityFilterValue())
        
    }
    
    
    
    
    
     func changeMinBondFilterValue()  {
        
    return cuckoo_manager.call(
    """
    changeMinBondFilterValue()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.changeMinBondFilterValue())
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    
    
    
    
     func searchTextDidChange(_ text: String?)  {
        
    return cuckoo_manager.call(
    """
    searchTextDidChange(_: String?)
    """,
            parameters: (text),
            escapingParameters: (text),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.searchTextDidChange(text))
        
    }
    
    
    
    
    
     func didRemove(validatorAddress: AccountAddress)  {
        
    return cuckoo_manager.call(
    """
    didRemove(validatorAddress: AccountAddress)
    """,
            parameters: (validatorAddress),
            escapingParameters: (validatorAddress),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRemove(validatorAddress: validatorAddress))
        
    }
    
    
    
    
    
     func didRemove(_ validator: SelectedValidatorInfo)  {
        
    return cuckoo_manager.call(
    """
    didRemove(_: SelectedValidatorInfo)
    """,
            parameters: (validator),
            escapingParameters: (validator),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRemove(validator))
        
    }
    
    

     struct __StubbingProxy_CustomValidatorListPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func fillWithRecommended() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    fillWithRecommended()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func clearFilter() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    clearFilter()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func deselectAll() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    deselectAll()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func changeValidatorSelection<M1: Cuckoo.Matchable>(address: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String)> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: address) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    changeValidatorSelection(address: String)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didSelectValidator<M1: Cuckoo.Matchable>(address: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String)> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: address) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    didSelectValidator(address: String)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentFilter() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    presentFilter()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentSearch() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    presentSearch()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func changeIdentityFilterValue() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    changeIdentityFilterValue()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func changeMinBondFilterValue() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    changeMinBondFilterValue()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func searchTextDidChange<M1: Cuckoo.OptionalMatchable>(_ text: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String?)> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: text) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    searchTextDidChange(_: String?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didRemove<M1: Cuckoo.Matchable>(validatorAddress: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountAddress)> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: validatorAddress) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    didRemove(validatorAddress: AccountAddress)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didRemove<M1: Cuckoo.Matchable>(_ validator: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectedValidatorInfo)> where M1.MatchedType == SelectedValidatorInfo {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorInfo)>] = [wrap(matchable: validator) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListPresenterProtocol.self, method:
    """
    didRemove(_: SelectedValidatorInfo)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CustomValidatorListPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func fillWithRecommended() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    fillWithRecommended()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func clearFilter() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    clearFilter()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func deselectAll() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    deselectAll()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func changeValidatorSelection<M1: Cuckoo.Matchable>(address: M1) -> Cuckoo.__DoNotUse<(String), Void> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: address) { $0 }]
            return cuckoo_manager.verify(
    """
    changeValidatorSelection(address: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didSelectValidator<M1: Cuckoo.Matchable>(address: M1) -> Cuckoo.__DoNotUse<(String), Void> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: address) { $0 }]
            return cuckoo_manager.verify(
    """
    didSelectValidator(address: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentFilter() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentFilter()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentSearch() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentSearch()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func changeIdentityFilterValue() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    changeIdentityFilterValue()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func changeMinBondFilterValue() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    changeMinBondFilterValue()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func searchTextDidChange<M1: Cuckoo.OptionalMatchable>(_ text: M1) -> Cuckoo.__DoNotUse<(String?), Void> where M1.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String?)>] = [wrap(matchable: text) { $0 }]
            return cuckoo_manager.verify(
    """
    searchTextDidChange(_: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didRemove<M1: Cuckoo.Matchable>(validatorAddress: M1) -> Cuckoo.__DoNotUse<(AccountAddress), Void> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: validatorAddress) { $0 }]
            return cuckoo_manager.verify(
    """
    didRemove(validatorAddress: AccountAddress)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didRemove<M1: Cuckoo.Matchable>(_ validator: M1) -> Cuckoo.__DoNotUse<(SelectedValidatorInfo), Void> where M1.MatchedType == SelectedValidatorInfo {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorInfo)>] = [wrap(matchable: validator) { $0 }]
            return cuckoo_manager.verify(
    """
    didRemove(_: SelectedValidatorInfo)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CustomValidatorListPresenterProtocolStub: CustomValidatorListPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func fillWithRecommended()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func clearFilter()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func deselectAll()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func changeValidatorSelection(address: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didSelectValidator(address: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentFilter()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentSearch()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func changeIdentityFilterValue()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func changeMinBondFilterValue()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func searchTextDidChange(_ text: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didRemove(validatorAddress: AccountAddress)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didRemove(_ validator: SelectedValidatorInfo)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCustomValidatorListInteractorInputProtocol: CustomValidatorListInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CustomValidatorListInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_CustomValidatorListInteractorInputProtocol
     typealias Verification = __VerificationProxy_CustomValidatorListInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CustomValidatorListInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: CustomValidatorListInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    

     struct __StubbingProxy_CustomValidatorListInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CustomValidatorListInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CustomValidatorListInteractorInputProtocolStub: CustomValidatorListInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCustomValidatorListInteractorOutputProtocol: CustomValidatorListInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CustomValidatorListInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_CustomValidatorListInteractorOutputProtocol
     typealias Verification = __VerificationProxy_CustomValidatorListInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CustomValidatorListInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: CustomValidatorListInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    

     struct __StubbingProxy_CustomValidatorListInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CustomValidatorListInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CustomValidatorListInteractorOutputProtocolStub: CustomValidatorListInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockCustomValidatorListWireframeProtocol: CustomValidatorListWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = CustomValidatorListWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_CustomValidatorListWireframeProtocol
     typealias Verification = __VerificationProxy_CustomValidatorListWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: CustomValidatorListWireframeProtocol?

     func enableDefaultImplementation(_ stub: CustomValidatorListWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func present(chainAsset: ChainAsset, wallet: MetaAccountModel, flow: ValidatorInfoFlow, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(chainAsset: ChainAsset, wallet: MetaAccountModel, flow: ValidatorInfoFlow, from: ControllerBackedProtocol?)
    """,
            parameters: (chainAsset, wallet, flow, view),
            escapingParameters: (chainAsset, wallet, flow, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(chainAsset: chainAsset, wallet: wallet, flow: flow, from: view))
        
    }
    
    
    
    
    
     func presentFilters(from view: ControllerBackedProtocol?, flow: ValidatorListFilterFlow, delegate: ValidatorListFilterDelegate?, asset: AssetModel)  {
        
    return cuckoo_manager.call(
    """
    presentFilters(from: ControllerBackedProtocol?, flow: ValidatorListFilterFlow, delegate: ValidatorListFilterDelegate?, asset: AssetModel)
    """,
            parameters: (view, flow, delegate, asset),
            escapingParameters: (view, flow, delegate, asset),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentFilters(from: view, flow: flow, delegate: delegate, asset: asset))
        
    }
    
    
    
    
    
     func presentSearch(from view: ControllerBackedProtocol?, flow: ValidatorSearchFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    presentSearch(from: ControllerBackedProtocol?, flow: ValidatorSearchFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """,
            parameters: (view, flow, chainAsset, wallet),
            escapingParameters: (view, flow, chainAsset, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentSearch(from: view, flow: flow, chainAsset: chainAsset, wallet: wallet))
        
    }
    
    
    
    
    
     func proceed(from view: ControllerBackedProtocol?, flow: SelectedValidatorListFlow, delegate: SelectedValidatorListDelegate, chainAsset: ChainAsset, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    proceed(from: ControllerBackedProtocol?, flow: SelectedValidatorListFlow, delegate: SelectedValidatorListDelegate, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """,
            parameters: (view, flow, delegate, chainAsset, wallet),
            escapingParameters: (view, flow, delegate, chainAsset, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(from: view, flow: flow, delegate: delegate, chainAsset: chainAsset, wallet: wallet))
        
    }
    
    
    
    
    
     func confirm(from view: ControllerBackedProtocol?, flow: SelectValidatorsConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    confirm(from: ControllerBackedProtocol?, flow: SelectValidatorsConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """,
            parameters: (view, flow, chainAsset, wallet),
            escapingParameters: (view, flow, chainAsset, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm(from: view, flow: flow, chainAsset: chainAsset, wallet: wallet))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_CustomValidatorListWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(chainAsset: M1, wallet: M2, flow: M3, from view: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainAsset, MetaAccountModel, ValidatorInfoFlow, ControllerBackedProtocol?)> where M1.MatchedType == ChainAsset, M2.MatchedType == MetaAccountModel, M3.MatchedType == ValidatorInfoFlow, M4.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset, MetaAccountModel, ValidatorInfoFlow, ControllerBackedProtocol?)>] = [wrap(matchable: chainAsset) { $0.0 }, wrap(matchable: wallet) { $0.1 }, wrap(matchable: flow) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListWireframeProtocol.self, method:
    """
    present(chainAsset: ChainAsset, wallet: MetaAccountModel, flow: ValidatorInfoFlow, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentFilters<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, delegate: M3, asset: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ValidatorListFilterFlow, ValidatorListFilterDelegate?, AssetModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ValidatorListFilterFlow, M3.OptionalMatchedType == ValidatorListFilterDelegate, M4.MatchedType == AssetModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ValidatorListFilterFlow, ValidatorListFilterDelegate?, AssetModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: delegate) { $0.2 }, wrap(matchable: asset) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListWireframeProtocol.self, method:
    """
    presentFilters(from: ControllerBackedProtocol?, flow: ValidatorListFilterFlow, delegate: ValidatorListFilterDelegate?, asset: AssetModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentSearch<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ValidatorSearchFlow, ChainAsset, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ValidatorSearchFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ValidatorSearchFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListWireframeProtocol.self, method:
    """
    presentSearch(from: ControllerBackedProtocol?, flow: ValidatorSearchFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, flow: M2, delegate: M3, chainAsset: M4, wallet: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, SelectedValidatorListFlow, SelectedValidatorListDelegate, ChainAsset, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == SelectedValidatorListFlow, M3.MatchedType == SelectedValidatorListDelegate, M4.MatchedType == ChainAsset, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, SelectedValidatorListFlow, SelectedValidatorListDelegate, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: delegate) { $0.2 }, wrap(matchable: chainAsset) { $0.3 }, wrap(matchable: wallet) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListWireframeProtocol.self, method:
    """
    proceed(from: ControllerBackedProtocol?, flow: SelectedValidatorListFlow, delegate: SelectedValidatorListDelegate, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func confirm<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, SelectValidatorsConfirmFlow, ChainAsset, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == SelectValidatorsConfirmFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, SelectValidatorsConfirmFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListWireframeProtocol.self, method:
    """
    confirm(from: ControllerBackedProtocol?, flow: SelectValidatorsConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockCustomValidatorListWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_CustomValidatorListWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(chainAsset: M1, wallet: M2, flow: M3, from view: M4) -> Cuckoo.__DoNotUse<(ChainAsset, MetaAccountModel, ValidatorInfoFlow, ControllerBackedProtocol?), Void> where M1.MatchedType == ChainAsset, M2.MatchedType == MetaAccountModel, M3.MatchedType == ValidatorInfoFlow, M4.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset, MetaAccountModel, ValidatorInfoFlow, ControllerBackedProtocol?)>] = [wrap(matchable: chainAsset) { $0.0 }, wrap(matchable: wallet) { $0.1 }, wrap(matchable: flow) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return cuckoo_manager.verify(
    """
    present(chainAsset: ChainAsset, wallet: MetaAccountModel, flow: ValidatorInfoFlow, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentFilters<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, delegate: M3, asset: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ValidatorListFilterFlow, ValidatorListFilterDelegate?, AssetModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ValidatorListFilterFlow, M3.OptionalMatchedType == ValidatorListFilterDelegate, M4.MatchedType == AssetModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ValidatorListFilterFlow, ValidatorListFilterDelegate?, AssetModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: delegate) { $0.2 }, wrap(matchable: asset) { $0.3 }]
            return cuckoo_manager.verify(
    """
    presentFilters(from: ControllerBackedProtocol?, flow: ValidatorListFilterFlow, delegate: ValidatorListFilterDelegate?, asset: AssetModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentSearch<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ValidatorSearchFlow, ChainAsset, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ValidatorSearchFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ValidatorSearchFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return cuckoo_manager.verify(
    """
    presentSearch(from: ControllerBackedProtocol?, flow: ValidatorSearchFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, flow: M2, delegate: M3, chainAsset: M4, wallet: M5) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, SelectedValidatorListFlow, SelectedValidatorListDelegate, ChainAsset, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == SelectedValidatorListFlow, M3.MatchedType == SelectedValidatorListDelegate, M4.MatchedType == ChainAsset, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, SelectedValidatorListFlow, SelectedValidatorListDelegate, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: delegate) { $0.2 }, wrap(matchable: chainAsset) { $0.3 }, wrap(matchable: wallet) { $0.4 }]
            return cuckoo_manager.verify(
    """
    proceed(from: ControllerBackedProtocol?, flow: SelectedValidatorListFlow, delegate: SelectedValidatorListDelegate, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func confirm<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, SelectValidatorsConfirmFlow, ChainAsset, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == SelectValidatorsConfirmFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, SelectValidatorsConfirmFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return cuckoo_manager.verify(
    """
    confirm(from: ControllerBackedProtocol?, flow: SelectValidatorsConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class CustomValidatorListWireframeProtocolStub: CustomValidatorListWireframeProtocol {
    

    

    
    
    
    
     func present(chainAsset: ChainAsset, wallet: MetaAccountModel, flow: ValidatorInfoFlow, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentFilters(from view: ControllerBackedProtocol?, flow: ValidatorListFilterFlow, delegate: ValidatorListFilterDelegate?, asset: AssetModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentSearch(from view: ControllerBackedProtocol?, flow: ValidatorSearchFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed(from view: ControllerBackedProtocol?, flow: SelectedValidatorListFlow, delegate: SelectedValidatorListDelegate, chainAsset: ChainAsset, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func confirm(from view: ControllerBackedProtocol?, flow: SelectValidatorsConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockRecommendedValidatorListViewProtocol: RecommendedValidatorListViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = RecommendedValidatorListViewProtocol
    
     typealias Stubbing = __StubbingProxy_RecommendedValidatorListViewProtocol
     typealias Verification = __VerificationProxy_RecommendedValidatorListViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: RecommendedValidatorListViewProtocol?

     func enableDefaultImplementation(_ stub: RecommendedValidatorListViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(viewModel: RecommendedValidatorListViewModelProtocol)  {
        
    return cuckoo_manager.call(
    """
    didReceive(viewModel: RecommendedValidatorListViewModelProtocol)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_RecommendedValidatorListViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockRecommendedValidatorListViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockRecommendedValidatorListViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockRecommendedValidatorListViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(RecommendedValidatorListViewModelProtocol)> where M1.MatchedType == RecommendedValidatorListViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(RecommendedValidatorListViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRecommendedValidatorListViewProtocol.self, method:
    """
    didReceive(viewModel: RecommendedValidatorListViewModelProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockRecommendedValidatorListViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_RecommendedValidatorListViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(RecommendedValidatorListViewModelProtocol), Void> where M1.MatchedType == RecommendedValidatorListViewModelProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(RecommendedValidatorListViewModelProtocol)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(viewModel: RecommendedValidatorListViewModelProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class RecommendedValidatorListViewProtocolStub: RecommendedValidatorListViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didReceive(viewModel: RecommendedValidatorListViewModelProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockRecommendedValidatorListPresenterProtocol: RecommendedValidatorListPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = RecommendedValidatorListPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_RecommendedValidatorListPresenterProtocol
     typealias Verification = __VerificationProxy_RecommendedValidatorListPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: RecommendedValidatorListPresenterProtocol?

     func enableDefaultImplementation(_ stub: RecommendedValidatorListPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func selectedValidatorAt(index: Int)  {
        
    return cuckoo_manager.call(
    """
    selectedValidatorAt(index: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectedValidatorAt(index: index))
        
    }
    
    
    
    
    
     func showValidatorInfoAt(index: Int)  {
        
    return cuckoo_manager.call(
    """
    showValidatorInfoAt(index: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showValidatorInfoAt(index: index))
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    

     struct __StubbingProxy_RecommendedValidatorListPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockRecommendedValidatorListPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectedValidatorAt<M1: Cuckoo.Matchable>(index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRecommendedValidatorListPresenterProtocol.self, method:
    """
    selectedValidatorAt(index: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showValidatorInfoAt<M1: Cuckoo.Matchable>(index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRecommendedValidatorListPresenterProtocol.self, method:
    """
    showValidatorInfoAt(index: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockRecommendedValidatorListPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_RecommendedValidatorListPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectedValidatorAt<M1: Cuckoo.Matchable>(index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    selectedValidatorAt(index: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showValidatorInfoAt<M1: Cuckoo.Matchable>(index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    showValidatorInfoAt(index: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class RecommendedValidatorListPresenterProtocolStub: RecommendedValidatorListPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectedValidatorAt(index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showValidatorInfoAt(index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockRecommendedValidatorListWireframeProtocol: RecommendedValidatorListWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = RecommendedValidatorListWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_RecommendedValidatorListWireframeProtocol
     typealias Verification = __VerificationProxy_RecommendedValidatorListWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: RecommendedValidatorListWireframeProtocol?

     func enableDefaultImplementation(_ stub: RecommendedValidatorListWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from view: RecommendedValidatorListViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: RecommendedValidatorListViewProtocol?)
    """,
            parameters: (flow, chainAsset, wallet, view),
            escapingParameters: (flow, chainAsset, wallet, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(flow: flow, chainAsset: chainAsset, wallet: wallet, from: view))
        
    }
    
    
    
    
    
     func proceed(from parameter0: RecommendedValidatorListViewProtocol?, flow parameter1: SelectValidatorsConfirmFlow, wallet parameter2: MetaAccountModel, chainAsset parameter3: ChainAsset)  {
        
    return cuckoo_manager.call(
    """
    proceed(from: RecommendedValidatorListViewProtocol?, flow: SelectValidatorsConfirmFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)
    """,
            parameters: (parameter0, parameter1, parameter2, parameter3),
            escapingParameters: (parameter0, parameter1, parameter2, parameter3),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(from: parameter0, flow: parameter1, wallet: parameter2, chainAsset: parameter3))
        
    }
    
    

     struct __StubbingProxy_RecommendedValidatorListWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(flow: M1, chainAsset: M2, wallet: M3, from view: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, RecommendedValidatorListViewProtocol?)> where M1.MatchedType == ValidatorInfoFlow, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.OptionalMatchedType == RecommendedValidatorListViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, RecommendedValidatorListViewProtocol?)>] = [wrap(matchable: flow) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRecommendedValidatorListWireframeProtocol.self, method:
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: RecommendedValidatorListViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from parameter0: M1, flow parameter1: M2, wallet parameter2: M3, chainAsset parameter3: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(RecommendedValidatorListViewProtocol?, SelectValidatorsConfirmFlow, MetaAccountModel, ChainAsset)> where M1.OptionalMatchedType == RecommendedValidatorListViewProtocol, M2.MatchedType == SelectValidatorsConfirmFlow, M3.MatchedType == MetaAccountModel, M4.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(RecommendedValidatorListViewProtocol?, SelectValidatorsConfirmFlow, MetaAccountModel, ChainAsset)>] = [wrap(matchable: parameter0) { $0.0 }, wrap(matchable: parameter1) { $0.1 }, wrap(matchable: parameter2) { $0.2 }, wrap(matchable: parameter3) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockRecommendedValidatorListWireframeProtocol.self, method:
    """
    proceed(from: RecommendedValidatorListViewProtocol?, flow: SelectValidatorsConfirmFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_RecommendedValidatorListWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(flow: M1, chainAsset: M2, wallet: M3, from view: M4) -> Cuckoo.__DoNotUse<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, RecommendedValidatorListViewProtocol?), Void> where M1.MatchedType == ValidatorInfoFlow, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.OptionalMatchedType == RecommendedValidatorListViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, RecommendedValidatorListViewProtocol?)>] = [wrap(matchable: flow) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return cuckoo_manager.verify(
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: RecommendedValidatorListViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from parameter0: M1, flow parameter1: M2, wallet parameter2: M3, chainAsset parameter3: M4) -> Cuckoo.__DoNotUse<(RecommendedValidatorListViewProtocol?, SelectValidatorsConfirmFlow, MetaAccountModel, ChainAsset), Void> where M1.OptionalMatchedType == RecommendedValidatorListViewProtocol, M2.MatchedType == SelectValidatorsConfirmFlow, M3.MatchedType == MetaAccountModel, M4.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(RecommendedValidatorListViewProtocol?, SelectValidatorsConfirmFlow, MetaAccountModel, ChainAsset)>] = [wrap(matchable: parameter0) { $0.0 }, wrap(matchable: parameter1) { $0.1 }, wrap(matchable: parameter2) { $0.2 }, wrap(matchable: parameter3) { $0.3 }]
            return cuckoo_manager.verify(
    """
    proceed(from: RecommendedValidatorListViewProtocol?, flow: SelectValidatorsConfirmFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class RecommendedValidatorListWireframeProtocolStub: RecommendedValidatorListWireframeProtocol {
    

    

    
    
    
    
     func present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from view: RecommendedValidatorListViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed(from parameter0: RecommendedValidatorListViewProtocol?, flow parameter1: SelectValidatorsConfirmFlow, wallet parameter2: MetaAccountModel, chainAsset parameter3: ChainAsset)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import Foundation
import SoraFoundation






 class MockSelectValidatorsConfirmViewProtocol: SelectValidatorsConfirmViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsConfirmViewProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsConfirmViewProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsConfirmViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsConfirmViewProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsConfirmViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(confirmationViewModel: LocalizableResource<SelectValidatorsConfirmViewModel>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(confirmationViewModel: LocalizableResource<SelectValidatorsConfirmViewModel>)
    """,
            parameters: (confirmationViewModel),
            escapingParameters: (confirmationViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(confirmationViewModel: confirmationViewModel))
        
    }
    
    
    
    
    
     func didReceive(hintsViewModel: LocalizableResource<[TitleIconViewModel]>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(hintsViewModel: LocalizableResource<[TitleIconViewModel]>)
    """,
            parameters: (hintsViewModel),
            escapingParameters: (hintsViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(hintsViewModel: hintsViewModel))
        
    }
    
    
    
    
    
     func didReceive(assetViewModel: LocalizableResource<AssetBalanceViewModelProtocol>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(assetViewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """,
            parameters: (assetViewModel),
            escapingParameters: (assetViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(assetViewModel: assetViewModel))
        
    }
    
    
    
    
    
     func didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """,
            parameters: (feeViewModel),
            escapingParameters: (feeViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(feeViewModel: feeViewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_SelectValidatorsConfirmViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectValidatorsConfirmViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectValidatorsConfirmViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockSelectValidatorsConfirmViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectValidatorsConfirmViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectValidatorsConfirmViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(confirmationViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<SelectValidatorsConfirmViewModel>)> where M1.MatchedType == LocalizableResource<SelectValidatorsConfirmViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<SelectValidatorsConfirmViewModel>)>] = [wrap(matchable: confirmationViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmViewProtocol.self, method:
    """
    didReceive(confirmationViewModel: LocalizableResource<SelectValidatorsConfirmViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(hintsViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<[TitleIconViewModel]>)> where M1.MatchedType == LocalizableResource<[TitleIconViewModel]> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<[TitleIconViewModel]>)>] = [wrap(matchable: hintsViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmViewProtocol.self, method:
    """
    didReceive(hintsViewModel: LocalizableResource<[TitleIconViewModel]>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(assetViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<AssetBalanceViewModelProtocol>)> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: assetViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmViewProtocol.self, method:
    """
    didReceive(assetViewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(feeViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<BalanceViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: feeViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmViewProtocol.self, method:
    """
    didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsConfirmViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(confirmationViewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<SelectValidatorsConfirmViewModel>), Void> where M1.MatchedType == LocalizableResource<SelectValidatorsConfirmViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<SelectValidatorsConfirmViewModel>)>] = [wrap(matchable: confirmationViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(confirmationViewModel: LocalizableResource<SelectValidatorsConfirmViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(hintsViewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<[TitleIconViewModel]>), Void> where M1.MatchedType == LocalizableResource<[TitleIconViewModel]> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<[TitleIconViewModel]>)>] = [wrap(matchable: hintsViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(hintsViewModel: LocalizableResource<[TitleIconViewModel]>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(assetViewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<AssetBalanceViewModelProtocol>), Void> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: assetViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(assetViewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(feeViewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<BalanceViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: feeViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectValidatorsConfirmViewProtocolStub: SelectValidatorsConfirmViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(confirmationViewModel: LocalizableResource<SelectValidatorsConfirmViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(hintsViewModel: LocalizableResource<[TitleIconViewModel]>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(assetViewModel: LocalizableResource<AssetBalanceViewModelProtocol>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectValidatorsConfirmPresenterProtocol: SelectValidatorsConfirmPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsConfirmPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsConfirmPresenterProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsConfirmPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsConfirmPresenterProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsConfirmPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func selectWalletAccount()  {
        
    return cuckoo_manager.call(
    """
    selectWalletAccount()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectWalletAccount())
        
    }
    
    
    
    
    
     func selectPayoutAccount()  {
        
    return cuckoo_manager.call(
    """
    selectPayoutAccount()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectPayoutAccount())
        
    }
    
    
    
    
    
     func selectCollatorAccount()  {
        
    return cuckoo_manager.call(
    """
    selectCollatorAccount()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectCollatorAccount())
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    

     struct __StubbingProxy_SelectValidatorsConfirmPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectWalletAccount() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmPresenterProtocol.self, method:
    """
    selectWalletAccount()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectPayoutAccount() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmPresenterProtocol.self, method:
    """
    selectPayoutAccount()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectCollatorAccount() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmPresenterProtocol.self, method:
    """
    selectCollatorAccount()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsConfirmPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectWalletAccount() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectWalletAccount()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectPayoutAccount() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectPayoutAccount()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectCollatorAccount() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectCollatorAccount()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectValidatorsConfirmPresenterProtocolStub: SelectValidatorsConfirmPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectWalletAccount()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectPayoutAccount()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectCollatorAccount()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectValidatorsConfirmInteractorInputProtocol: SelectValidatorsConfirmInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsConfirmInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsConfirmInteractorInputProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsConfirmInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsConfirmInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsConfirmInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func submitNomination(closure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    submitNomination(closure: ExtrinsicBuilderClosure?)
    """,
            parameters: (closure),
            escapingParameters: (closure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.submitNomination(closure: closure))
        
    }
    
    
    
    
    
     func estimateFee(closure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(closure: ExtrinsicBuilderClosure?)
    """,
            parameters: (closure),
            escapingParameters: (closure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(closure: closure))
        
    }
    
    

     struct __StubbingProxy_SelectValidatorsConfirmInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func submitNomination<M1: Cuckoo.OptionalMatchable>(closure: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: closure) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmInteractorInputProtocol.self, method:
    """
    submitNomination(closure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.OptionalMatchable>(closure: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: closure) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmInteractorInputProtocol.self, method:
    """
    estimateFee(closure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsConfirmInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func submitNomination<M1: Cuckoo.OptionalMatchable>(closure: M1) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: closure) { $0 }]
            return cuckoo_manager.verify(
    """
    submitNomination(closure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.OptionalMatchable>(closure: M1) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: closure) { $0 }]
            return cuckoo_manager.verify(
    """
    estimateFee(closure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectValidatorsConfirmInteractorInputProtocolStub: SelectValidatorsConfirmInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func submitNomination(closure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(closure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectValidatorsConfirmInteractorOutputProtocol: SelectValidatorsConfirmInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsConfirmInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsConfirmInteractorOutputProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsConfirmInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsConfirmInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsConfirmInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePrice(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePrice(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePrice(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result))
        
    }
    
    

     struct __StubbingProxy_SelectValidatorsConfirmInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePrice<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmInteractorOutputProtocol.self, method:
    """
    didReceivePrice(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>)> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsConfirmInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePrice<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePrice(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>), Void> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectValidatorsConfirmInteractorOutputProtocolStub: SelectValidatorsConfirmInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceivePrice(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectValidatorsConfirmWireframeProtocol: SelectValidatorsConfirmWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsConfirmWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsConfirmWireframeProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsConfirmWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsConfirmWireframeProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsConfirmWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(chainAsset: ChainAsset, txHash: String, from view: SelectValidatorsConfirmViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    complete(chainAsset: ChainAsset, txHash: String, from: SelectValidatorsConfirmViewProtocol?)
    """,
            parameters: (chainAsset, txHash, view),
            escapingParameters: (chainAsset, txHash, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(chainAsset: chainAsset, txHash: txHash, from: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_SelectValidatorsConfirmWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(chainAsset: M1, txHash: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainAsset, String, SelectValidatorsConfirmViewProtocol?)> where M1.MatchedType == ChainAsset, M2.MatchedType == String, M3.OptionalMatchedType == SelectValidatorsConfirmViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset, String, SelectValidatorsConfirmViewProtocol?)>] = [wrap(matchable: chainAsset) { $0.0 }, wrap(matchable: txHash) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmWireframeProtocol.self, method:
    """
    complete(chainAsset: ChainAsset, txHash: String, from: SelectValidatorsConfirmViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsConfirmWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsConfirmWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(chainAsset: M1, txHash: M2, from view: M3) -> Cuckoo.__DoNotUse<(ChainAsset, String, SelectValidatorsConfirmViewProtocol?), Void> where M1.MatchedType == ChainAsset, M2.MatchedType == String, M3.OptionalMatchedType == SelectValidatorsConfirmViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset, String, SelectValidatorsConfirmViewProtocol?)>] = [wrap(matchable: chainAsset) { $0.0 }, wrap(matchable: txHash) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    complete(chainAsset: ChainAsset, txHash: String, from: SelectValidatorsConfirmViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectValidatorsConfirmWireframeProtocolStub: SelectValidatorsConfirmWireframeProtocol {
    

    

    
    
    
    
     func complete(chainAsset: ChainAsset, txHash: String, from view: SelectValidatorsConfirmViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import SoraFoundation






 class MockSelectValidatorsStartViewProtocol: SelectValidatorsStartViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsStartViewProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsStartViewProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsStartViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsStartViewProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsStartViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(viewModel: SelectValidatorsStartViewModel?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(viewModel: SelectValidatorsStartViewModel?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceive(textsViewModel: SelectValidatorsStartTextsViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceive(textsViewModel: SelectValidatorsStartTextsViewModel)
    """,
            parameters: (textsViewModel),
            escapingParameters: (textsViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(textsViewModel: textsViewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_SelectValidatorsStartViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectValidatorsStartViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectValidatorsStartViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockSelectValidatorsStartViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectValidatorsStartViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectValidatorsStartViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectValidatorsStartViewModel?)> where M1.OptionalMatchedType == SelectValidatorsStartViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(SelectValidatorsStartViewModel?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartViewProtocol.self, method:
    """
    didReceive(viewModel: SelectValidatorsStartViewModel?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(textsViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectValidatorsStartTextsViewModel)> where M1.MatchedType == SelectValidatorsStartTextsViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(SelectValidatorsStartTextsViewModel)>] = [wrap(matchable: textsViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartViewProtocol.self, method:
    """
    didReceive(textsViewModel: SelectValidatorsStartTextsViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsStartViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(SelectValidatorsStartViewModel?), Void> where M1.OptionalMatchedType == SelectValidatorsStartViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(SelectValidatorsStartViewModel?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(viewModel: SelectValidatorsStartViewModel?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(textsViewModel: M1) -> Cuckoo.__DoNotUse<(SelectValidatorsStartTextsViewModel), Void> where M1.MatchedType == SelectValidatorsStartTextsViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(SelectValidatorsStartTextsViewModel)>] = [wrap(matchable: textsViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(textsViewModel: SelectValidatorsStartTextsViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectValidatorsStartViewProtocolStub: SelectValidatorsStartViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(viewModel: SelectValidatorsStartViewModel?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(textsViewModel: SelectValidatorsStartTextsViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectValidatorsStartPresenterProtocol: SelectValidatorsStartPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsStartPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsStartPresenterProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsStartPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsStartPresenterProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsStartPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func updateOnAppearance()  {
        
    return cuckoo_manager.call(
    """
    updateOnAppearance()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.updateOnAppearance())
        
    }
    
    
    
    
    
     func selectRecommendedValidators()  {
        
    return cuckoo_manager.call(
    """
    selectRecommendedValidators()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectRecommendedValidators())
        
    }
    
    
    
    
    
     func selectCustomValidators()  {
        
    return cuckoo_manager.call(
    """
    selectCustomValidators()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectCustomValidators())
        
    }
    
    

     struct __StubbingProxy_SelectValidatorsStartPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func updateOnAppearance() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartPresenterProtocol.self, method:
    """
    updateOnAppearance()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectRecommendedValidators() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartPresenterProtocol.self, method:
    """
    selectRecommendedValidators()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectCustomValidators() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartPresenterProtocol.self, method:
    """
    selectCustomValidators()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsStartPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func updateOnAppearance() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    updateOnAppearance()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectRecommendedValidators() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectRecommendedValidators()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectCustomValidators() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectCustomValidators()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectValidatorsStartPresenterProtocolStub: SelectValidatorsStartPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func updateOnAppearance()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectRecommendedValidators()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectCustomValidators()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectValidatorsStartInteractorInputProtocol: SelectValidatorsStartInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsStartInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsStartInteractorInputProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsStartInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsStartInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsStartInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    

     struct __StubbingProxy_SelectValidatorsStartInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsStartInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectValidatorsStartInteractorInputProtocolStub: SelectValidatorsStartInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectValidatorsStartInteractorOutputProtocol: SelectValidatorsStartInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsStartInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsStartInteractorOutputProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsStartInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsStartInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsStartInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    

     struct __StubbingProxy_SelectValidatorsStartInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsStartInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
    }
}


 class SelectValidatorsStartInteractorOutputProtocolStub: SelectValidatorsStartInteractorOutputProtocol {
    

    

    
}










 class MockSelectValidatorsStartWireframeProtocol: SelectValidatorsStartWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectValidatorsStartWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_SelectValidatorsStartWireframeProtocol
     typealias Verification = __VerificationProxy_SelectValidatorsStartWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectValidatorsStartWireframeProtocol?

     func enableDefaultImplementation(_ stub: SelectValidatorsStartWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func proceedToCustomList(from view: ControllerBackedProtocol?, flow: CustomValidatorListFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    proceedToCustomList(from: ControllerBackedProtocol?, flow: CustomValidatorListFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """,
            parameters: (view, flow, chainAsset, wallet),
            escapingParameters: (view, flow, chainAsset, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceedToCustomList(from: view, flow: flow, chainAsset: chainAsset, wallet: wallet))
        
    }
    
    
    
    
    
     func proceedToRecommendedList(from view: SelectValidatorsStartViewProtocol?, flow: RecommendedValidatorListFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)  {
        
    return cuckoo_manager.call(
    """
    proceedToRecommendedList(from: SelectValidatorsStartViewProtocol?, flow: RecommendedValidatorListFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)
    """,
            parameters: (view, flow, wallet, chainAsset),
            escapingParameters: (view, flow, wallet, chainAsset),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceedToRecommendedList(from: view, flow: flow, wallet: wallet, chainAsset: chainAsset))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_SelectValidatorsStartWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func proceedToCustomList<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, CustomValidatorListFlow, ChainAsset, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == CustomValidatorListFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, CustomValidatorListFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartWireframeProtocol.self, method:
    """
    proceedToCustomList(from: ControllerBackedProtocol?, flow: CustomValidatorListFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceedToRecommendedList<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, wallet: M3, chainAsset: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectValidatorsStartViewProtocol?, RecommendedValidatorListFlow, MetaAccountModel, ChainAsset)> where M1.OptionalMatchedType == SelectValidatorsStartViewProtocol, M2.MatchedType == RecommendedValidatorListFlow, M3.MatchedType == MetaAccountModel, M4.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(SelectValidatorsStartViewProtocol?, RecommendedValidatorListFlow, MetaAccountModel, ChainAsset)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: chainAsset) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartWireframeProtocol.self, method:
    """
    proceedToRecommendedList(from: SelectValidatorsStartViewProtocol?, flow: RecommendedValidatorListFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectValidatorsStartWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectValidatorsStartWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func proceedToCustomList<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, CustomValidatorListFlow, ChainAsset, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == CustomValidatorListFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, CustomValidatorListFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return cuckoo_manager.verify(
    """
    proceedToCustomList(from: ControllerBackedProtocol?, flow: CustomValidatorListFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceedToRecommendedList<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, wallet: M3, chainAsset: M4) -> Cuckoo.__DoNotUse<(SelectValidatorsStartViewProtocol?, RecommendedValidatorListFlow, MetaAccountModel, ChainAsset), Void> where M1.OptionalMatchedType == SelectValidatorsStartViewProtocol, M2.MatchedType == RecommendedValidatorListFlow, M3.MatchedType == MetaAccountModel, M4.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(SelectValidatorsStartViewProtocol?, RecommendedValidatorListFlow, MetaAccountModel, ChainAsset)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: chainAsset) { $0.3 }]
            return cuckoo_manager.verify(
    """
    proceedToRecommendedList(from: SelectValidatorsStartViewProtocol?, flow: RecommendedValidatorListFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectValidatorsStartWireframeProtocolStub: SelectValidatorsStartWireframeProtocol {
    

    

    
    
    
    
     func proceedToCustomList(from view: ControllerBackedProtocol?, flow: CustomValidatorListFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceedToRecommendedList(from view: SelectValidatorsStartViewProtocol?, flow: RecommendedValidatorListFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockSelectedValidatorListViewProtocol: SelectedValidatorListViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectedValidatorListViewProtocol
    
     typealias Stubbing = __StubbingProxy_SelectedValidatorListViewProtocol
     typealias Verification = __VerificationProxy_SelectedValidatorListViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectedValidatorListViewProtocol?

     func enableDefaultImplementation(_ stub: SelectedValidatorListViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didReload(_ viewModel: SelectedValidatorListViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReload(_: SelectedValidatorListViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReload(viewModel))
        
    }
    
    
    
    
    
     func didChangeViewModel(_ viewModel: SelectedValidatorListViewModel, byRemovingItemAt index: Int)  {
        
    return cuckoo_manager.call(
    """
    didChangeViewModel(_: SelectedValidatorListViewModel, byRemovingItemAt: Int)
    """,
            parameters: (viewModel, index),
            escapingParameters: (viewModel, index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didChangeViewModel(viewModel, byRemovingItemAt: index))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_SelectedValidatorListViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectedValidatorListViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockSelectedValidatorListViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockSelectedValidatorListViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didReload<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectedValidatorListViewModel)> where M1.MatchedType == SelectedValidatorListViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorListViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListViewProtocol.self, method:
    """
    didReload(_: SelectedValidatorListViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didChangeViewModel<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(_ viewModel: M1, byRemovingItemAt index: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectedValidatorListViewModel, Int)> where M1.MatchedType == SelectedValidatorListViewModel, M2.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorListViewModel, Int)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: index) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListViewProtocol.self, method:
    """
    didChangeViewModel(_: SelectedValidatorListViewModel, byRemovingItemAt: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectedValidatorListViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReload<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.__DoNotUse<(SelectedValidatorListViewModel), Void> where M1.MatchedType == SelectedValidatorListViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorListViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReload(_: SelectedValidatorListViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didChangeViewModel<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(_ viewModel: M1, byRemovingItemAt index: M2) -> Cuckoo.__DoNotUse<(SelectedValidatorListViewModel, Int), Void> where M1.MatchedType == SelectedValidatorListViewModel, M2.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorListViewModel, Int)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: index) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didChangeViewModel(_: SelectedValidatorListViewModel, byRemovingItemAt: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectedValidatorListViewProtocolStub: SelectedValidatorListViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didReload(_ viewModel: SelectedValidatorListViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didChangeViewModel(_ viewModel: SelectedValidatorListViewModel, byRemovingItemAt index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectedValidatorListDelegate: SelectedValidatorListDelegate, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectedValidatorListDelegate
    
     typealias Stubbing = __StubbingProxy_SelectedValidatorListDelegate
     typealias Verification = __VerificationProxy_SelectedValidatorListDelegate

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectedValidatorListDelegate?

     func enableDefaultImplementation(_ stub: SelectedValidatorListDelegate) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didRemove(validatorAddress: AccountAddress)  {
        
    return cuckoo_manager.call(
    """
    didRemove(validatorAddress: AccountAddress)
    """,
            parameters: (validatorAddress),
            escapingParameters: (validatorAddress),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRemove(validatorAddress: validatorAddress))
        
    }
    
    
    
    
    
     func didRemove(_ validator: SelectedValidatorInfo)  {
        
    return cuckoo_manager.call(
    """
    didRemove(_: SelectedValidatorInfo)
    """,
            parameters: (validator),
            escapingParameters: (validator),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRemove(validator))
        
    }
    
    

     struct __StubbingProxy_SelectedValidatorListDelegate: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didRemove<M1: Cuckoo.Matchable>(validatorAddress: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountAddress)> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: validatorAddress) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListDelegate.self, method:
    """
    didRemove(validatorAddress: AccountAddress)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didRemove<M1: Cuckoo.Matchable>(_ validator: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectedValidatorInfo)> where M1.MatchedType == SelectedValidatorInfo {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorInfo)>] = [wrap(matchable: validator) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListDelegate.self, method:
    """
    didRemove(_: SelectedValidatorInfo)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectedValidatorListDelegate: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didRemove<M1: Cuckoo.Matchable>(validatorAddress: M1) -> Cuckoo.__DoNotUse<(AccountAddress), Void> where M1.MatchedType == AccountAddress {
            let matchers: [Cuckoo.ParameterMatcher<(AccountAddress)>] = [wrap(matchable: validatorAddress) { $0 }]
            return cuckoo_manager.verify(
    """
    didRemove(validatorAddress: AccountAddress)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didRemove<M1: Cuckoo.Matchable>(_ validator: M1) -> Cuckoo.__DoNotUse<(SelectedValidatorInfo), Void> where M1.MatchedType == SelectedValidatorInfo {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorInfo)>] = [wrap(matchable: validator) { $0 }]
            return cuckoo_manager.verify(
    """
    didRemove(_: SelectedValidatorInfo)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectedValidatorListDelegateStub: SelectedValidatorListDelegate {
    

    

    
    
    
    
     func didRemove(validatorAddress: AccountAddress)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didRemove(_ validator: SelectedValidatorInfo)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectedValidatorListPresenterProtocol: SelectedValidatorListPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectedValidatorListPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_SelectedValidatorListPresenterProtocol
     typealias Verification = __VerificationProxy_SelectedValidatorListPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectedValidatorListPresenterProtocol?

     func enableDefaultImplementation(_ stub: SelectedValidatorListPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func didSelectValidator(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    didSelectValidator(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSelectValidator(at: index))
        
    }
    
    
    
    
    
     func removeItem(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    removeItem(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.removeItem(at: index))
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    
    
    
    
     func dismiss()  {
        
    return cuckoo_manager.call(
    """
    dismiss()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.dismiss())
        
    }
    
    

     struct __StubbingProxy_SelectedValidatorListPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didSelectValidator<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListPresenterProtocol.self, method:
    """
    didSelectValidator(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func removeItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListPresenterProtocol.self, method:
    """
    removeItem(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func dismiss() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListPresenterProtocol.self, method:
    """
    dismiss()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectedValidatorListPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didSelectValidator<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    didSelectValidator(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func removeItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    removeItem(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func dismiss() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    dismiss()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectedValidatorListPresenterProtocolStub: SelectedValidatorListPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didSelectValidator(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func removeItem(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func dismiss()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockSelectedValidatorListWireframeProtocol: SelectedValidatorListWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = SelectedValidatorListWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_SelectedValidatorListWireframeProtocol
     typealias Verification = __VerificationProxy_SelectedValidatorListWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: SelectedValidatorListWireframeProtocol?

     func enableDefaultImplementation(_ stub: SelectedValidatorListWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: ControllerBackedProtocol?)
    """,
            parameters: (flow, chainAsset, wallet, view),
            escapingParameters: (flow, chainAsset, wallet, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(flow: flow, chainAsset: chainAsset, wallet: wallet, from: view))
        
    }
    
    
    
    
    
     func proceed(from parameter0: SelectedValidatorListViewProtocol?, flow parameter1: SelectValidatorsConfirmFlow, wallet parameter2: MetaAccountModel, chainAsset parameter3: ChainAsset)  {
        
    return cuckoo_manager.call(
    """
    proceed(from: SelectedValidatorListViewProtocol?, flow: SelectValidatorsConfirmFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)
    """,
            parameters: (parameter0, parameter1, parameter2, parameter3),
            escapingParameters: (parameter0, parameter1, parameter2, parameter3),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(from: parameter0, flow: parameter1, wallet: parameter2, chainAsset: parameter3))
        
    }
    
    
    
    
    
     func dismiss(_ view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    dismiss(_: ControllerBackedProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.dismiss(view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_SelectedValidatorListWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(flow: M1, chainAsset: M2, wallet: M3, from view: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, ControllerBackedProtocol?)> where M1.MatchedType == ValidatorInfoFlow, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, ControllerBackedProtocol?)>] = [wrap(matchable: flow) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListWireframeProtocol.self, method:
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from parameter0: M1, flow parameter1: M2, wallet parameter2: M3, chainAsset parameter3: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectedValidatorListViewProtocol?, SelectValidatorsConfirmFlow, MetaAccountModel, ChainAsset)> where M1.OptionalMatchedType == SelectedValidatorListViewProtocol, M2.MatchedType == SelectValidatorsConfirmFlow, M3.MatchedType == MetaAccountModel, M4.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorListViewProtocol?, SelectValidatorsConfirmFlow, MetaAccountModel, ChainAsset)>] = [wrap(matchable: parameter0) { $0.0 }, wrap(matchable: parameter1) { $0.1 }, wrap(matchable: parameter2) { $0.2 }, wrap(matchable: parameter3) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListWireframeProtocol.self, method:
    """
    proceed(from: SelectedValidatorListViewProtocol?, flow: SelectValidatorsConfirmFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func dismiss<M1: Cuckoo.OptionalMatchable>(_ view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?)> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListWireframeProtocol.self, method:
    """
    dismiss(_: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockSelectedValidatorListWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_SelectedValidatorListWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(flow: M1, chainAsset: M2, wallet: M3, from view: M4) -> Cuckoo.__DoNotUse<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, ControllerBackedProtocol?), Void> where M1.MatchedType == ValidatorInfoFlow, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, ControllerBackedProtocol?)>] = [wrap(matchable: flow) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return cuckoo_manager.verify(
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from parameter0: M1, flow parameter1: M2, wallet parameter2: M3, chainAsset parameter3: M4) -> Cuckoo.__DoNotUse<(SelectedValidatorListViewProtocol?, SelectValidatorsConfirmFlow, MetaAccountModel, ChainAsset), Void> where M1.OptionalMatchedType == SelectedValidatorListViewProtocol, M2.MatchedType == SelectValidatorsConfirmFlow, M3.MatchedType == MetaAccountModel, M4.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(SelectedValidatorListViewProtocol?, SelectValidatorsConfirmFlow, MetaAccountModel, ChainAsset)>] = [wrap(matchable: parameter0) { $0.0 }, wrap(matchable: parameter1) { $0.1 }, wrap(matchable: parameter2) { $0.2 }, wrap(matchable: parameter3) { $0.3 }]
            return cuckoo_manager.verify(
    """
    proceed(from: SelectedValidatorListViewProtocol?, flow: SelectValidatorsConfirmFlow, wallet: MetaAccountModel, chainAsset: ChainAsset)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func dismiss<M1: Cuckoo.OptionalMatchable>(_ view: M1) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    dismiss(_: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class SelectedValidatorListWireframeProtocolStub: SelectedValidatorListWireframeProtocol {
    

    

    
    
    
    
     func present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed(from parameter0: SelectedValidatorListViewProtocol?, flow parameter1: SelectValidatorsConfirmFlow, wallet parameter2: MetaAccountModel, chainAsset parameter3: ChainAsset)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func dismiss(_ view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import SoraFoundation






 class MockValidatorStakeInfoProtocol: ValidatorStakeInfoProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorStakeInfoProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorStakeInfoProtocol
     typealias Verification = __VerificationProxy_ValidatorStakeInfoProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorStakeInfoProtocol?

     func enableDefaultImplementation(_ stub: ValidatorStakeInfoProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var nominators: [NominatorInfo] {
        get {
            return cuckoo_manager.getter("nominators",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.nominators)
        }
        
    }
    
    
    
    
    
     var totalStake: Decimal {
        get {
            return cuckoo_manager.getter("totalStake",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.totalStake)
        }
        
    }
    
    
    
    
    
     var ownStake: Decimal {
        get {
            return cuckoo_manager.getter("ownStake",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.ownStake)
        }
        
    }
    
    
    
    
    
     var stakeReturn: Decimal {
        get {
            return cuckoo_manager.getter("stakeReturn",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.stakeReturn)
        }
        
    }
    
    
    
    
    
     var maxNominatorsRewarded: UInt32 {
        get {
            return cuckoo_manager.getter("maxNominatorsRewarded",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.maxNominatorsRewarded)
        }
        
    }
    
    
    
    
    
     var oversubscribed: Bool {
        get {
            return cuckoo_manager.getter("oversubscribed",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.oversubscribed)
        }
        
    }
    
    

    

    

     struct __StubbingProxy_ValidatorStakeInfoProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var nominators: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorStakeInfoProtocol, [NominatorInfo]> {
            return .init(manager: cuckoo_manager, name: "nominators")
        }
        
        
        
        
        var totalStake: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorStakeInfoProtocol, Decimal> {
            return .init(manager: cuckoo_manager, name: "totalStake")
        }
        
        
        
        
        var ownStake: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorStakeInfoProtocol, Decimal> {
            return .init(manager: cuckoo_manager, name: "ownStake")
        }
        
        
        
        
        var stakeReturn: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorStakeInfoProtocol, Decimal> {
            return .init(manager: cuckoo_manager, name: "stakeReturn")
        }
        
        
        
        
        var maxNominatorsRewarded: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorStakeInfoProtocol, UInt32> {
            return .init(manager: cuckoo_manager, name: "maxNominatorsRewarded")
        }
        
        
        
        
        var oversubscribed: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorStakeInfoProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "oversubscribed")
        }
        
        
        
    }

     struct __VerificationProxy_ValidatorStakeInfoProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var nominators: Cuckoo.VerifyReadOnlyProperty<[NominatorInfo]> {
            return .init(manager: cuckoo_manager, name: "nominators", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var totalStake: Cuckoo.VerifyReadOnlyProperty<Decimal> {
            return .init(manager: cuckoo_manager, name: "totalStake", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var ownStake: Cuckoo.VerifyReadOnlyProperty<Decimal> {
            return .init(manager: cuckoo_manager, name: "ownStake", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var stakeReturn: Cuckoo.VerifyReadOnlyProperty<Decimal> {
            return .init(manager: cuckoo_manager, name: "stakeReturn", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var maxNominatorsRewarded: Cuckoo.VerifyReadOnlyProperty<UInt32> {
            return .init(manager: cuckoo_manager, name: "maxNominatorsRewarded", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var oversubscribed: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "oversubscribed", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
    }
}


 class ValidatorStakeInfoProtocolStub: ValidatorStakeInfoProtocol {
    
    
    
    
     var nominators: [NominatorInfo] {
        get {
            return DefaultValueRegistry.defaultValue(for: ([NominatorInfo]).self)
        }
        
    }
    
    
    
    
    
     var totalStake: Decimal {
        get {
            return DefaultValueRegistry.defaultValue(for: (Decimal).self)
        }
        
    }
    
    
    
    
    
     var ownStake: Decimal {
        get {
            return DefaultValueRegistry.defaultValue(for: (Decimal).self)
        }
        
    }
    
    
    
    
    
     var stakeReturn: Decimal {
        get {
            return DefaultValueRegistry.defaultValue(for: (Decimal).self)
        }
        
    }
    
    
    
    
    
     var maxNominatorsRewarded: UInt32 {
        get {
            return DefaultValueRegistry.defaultValue(for: (UInt32).self)
        }
        
    }
    
    
    
    
    
     var oversubscribed: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
}










 class MockValidatorInfoProtocol: ValidatorInfoProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorInfoProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorInfoProtocol
     typealias Verification = __VerificationProxy_ValidatorInfoProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorInfoProtocol?

     func enableDefaultImplementation(_ stub: ValidatorInfoProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var address: String {
        get {
            return cuckoo_manager.getter("address",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.address)
        }
        
    }
    
    
    
    
    
     var identity: AccountIdentity? {
        get {
            return cuckoo_manager.getter("identity",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.identity)
        }
        
    }
    
    
    
    
    
     var stakeInfo: ValidatorStakeInfoProtocol? {
        get {
            return cuckoo_manager.getter("stakeInfo",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.stakeInfo)
        }
        
    }
    
    
    
    
    
     var myNomination: ValidatorMyNominationStatus? {
        get {
            return cuckoo_manager.getter("myNomination",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.myNomination)
        }
        
    }
    
    
    
    
    
     var totalStake: Decimal {
        get {
            return cuckoo_manager.getter("totalStake",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.totalStake)
        }
        
    }
    
    
    
    
    
     var ownStake: Decimal {
        get {
            return cuckoo_manager.getter("ownStake",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.ownStake)
        }
        
    }
    
    
    
    
    
     var hasSlashes: Bool {
        get {
            return cuckoo_manager.getter("hasSlashes",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.hasSlashes)
        }
        
    }
    
    
    
    
    
     var blocked: Bool {
        get {
            return cuckoo_manager.getter("blocked",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.blocked)
        }
        
    }
    
    

    

    

     struct __StubbingProxy_ValidatorInfoProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var address: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoProtocol, String> {
            return .init(manager: cuckoo_manager, name: "address")
        }
        
        
        
        
        var identity: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoProtocol, AccountIdentity?> {
            return .init(manager: cuckoo_manager, name: "identity")
        }
        
        
        
        
        var stakeInfo: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoProtocol, ValidatorStakeInfoProtocol?> {
            return .init(manager: cuckoo_manager, name: "stakeInfo")
        }
        
        
        
        
        var myNomination: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoProtocol, ValidatorMyNominationStatus?> {
            return .init(manager: cuckoo_manager, name: "myNomination")
        }
        
        
        
        
        var totalStake: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoProtocol, Decimal> {
            return .init(manager: cuckoo_manager, name: "totalStake")
        }
        
        
        
        
        var ownStake: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoProtocol, Decimal> {
            return .init(manager: cuckoo_manager, name: "ownStake")
        }
        
        
        
        
        var hasSlashes: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "hasSlashes")
        }
        
        
        
        
        var blocked: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "blocked")
        }
        
        
        
    }

     struct __VerificationProxy_ValidatorInfoProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var address: Cuckoo.VerifyReadOnlyProperty<String> {
            return .init(manager: cuckoo_manager, name: "address", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var identity: Cuckoo.VerifyReadOnlyProperty<AccountIdentity?> {
            return .init(manager: cuckoo_manager, name: "identity", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var stakeInfo: Cuckoo.VerifyReadOnlyProperty<ValidatorStakeInfoProtocol?> {
            return .init(manager: cuckoo_manager, name: "stakeInfo", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var myNomination: Cuckoo.VerifyReadOnlyProperty<ValidatorMyNominationStatus?> {
            return .init(manager: cuckoo_manager, name: "myNomination", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var totalStake: Cuckoo.VerifyReadOnlyProperty<Decimal> {
            return .init(manager: cuckoo_manager, name: "totalStake", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var ownStake: Cuckoo.VerifyReadOnlyProperty<Decimal> {
            return .init(manager: cuckoo_manager, name: "ownStake", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var hasSlashes: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "hasSlashes", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var blocked: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "blocked", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
    }
}


 class ValidatorInfoProtocolStub: ValidatorInfoProtocol {
    
    
    
    
     var address: String {
        get {
            return DefaultValueRegistry.defaultValue(for: (String).self)
        }
        
    }
    
    
    
    
    
     var identity: AccountIdentity? {
        get {
            return DefaultValueRegistry.defaultValue(for: (AccountIdentity?).self)
        }
        
    }
    
    
    
    
    
     var stakeInfo: ValidatorStakeInfoProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (ValidatorStakeInfoProtocol?).self)
        }
        
    }
    
    
    
    
    
     var myNomination: ValidatorMyNominationStatus? {
        get {
            return DefaultValueRegistry.defaultValue(for: (ValidatorMyNominationStatus?).self)
        }
        
    }
    
    
    
    
    
     var totalStake: Decimal {
        get {
            return DefaultValueRegistry.defaultValue(for: (Decimal).self)
        }
        
    }
    
    
    
    
    
     var ownStake: Decimal {
        get {
            return DefaultValueRegistry.defaultValue(for: (Decimal).self)
        }
        
    }
    
    
    
    
    
     var hasSlashes: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var blocked: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
}










 class MockValidatorInfoViewProtocol: ValidatorInfoViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorInfoViewProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorInfoViewProtocol
     typealias Verification = __VerificationProxy_ValidatorInfoViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorInfoViewProtocol?

     func enableDefaultImplementation(_ stub: ValidatorInfoViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didRecieve(state: ValidatorInfoState)  {
        
    return cuckoo_manager.call(
    """
    didRecieve(state: ValidatorInfoState)
    """,
            parameters: (state),
            escapingParameters: (state),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRecieve(state: state))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_ValidatorInfoViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorInfoViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockValidatorInfoViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didRecieve<M1: Cuckoo.Matchable>(state: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorInfoState)> where M1.MatchedType == ValidatorInfoState {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoState)>] = [wrap(matchable: state) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoViewProtocol.self, method:
    """
    didRecieve(state: ValidatorInfoState)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorInfoViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didRecieve<M1: Cuckoo.Matchable>(state: M1) -> Cuckoo.__DoNotUse<(ValidatorInfoState), Void> where M1.MatchedType == ValidatorInfoState {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoState)>] = [wrap(matchable: state) { $0 }]
            return cuckoo_manager.verify(
    """
    didRecieve(state: ValidatorInfoState)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorInfoViewProtocolStub: ValidatorInfoViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didRecieve(state: ValidatorInfoState)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorInfoInteractorInputProtocol: ValidatorInfoInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorInfoInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorInfoInteractorInputProtocol
     typealias Verification = __VerificationProxy_ValidatorInfoInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorInfoInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: ValidatorInfoInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func reload()  {
        
    return cuckoo_manager.call(
    """
    reload()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload())
        
    }
    
    

     struct __StubbingProxy_ValidatorInfoInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func reload() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoInteractorInputProtocol.self, method:
    """
    reload()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorInfoInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func reload() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    reload()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorInfoInteractorInputProtocolStub: ValidatorInfoInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func reload()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorInfoInteractorOutputProtocol: ValidatorInfoInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorInfoInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorInfoInteractorOutputProtocol
     typealias Verification = __VerificationProxy_ValidatorInfoInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorInfoInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: ValidatorInfoInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    

     struct __StubbingProxy_ValidatorInfoInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorInfoInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorInfoInteractorOutputProtocolStub: ValidatorInfoInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorInfoPresenterProtocol: ValidatorInfoPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorInfoPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorInfoPresenterProtocol
     typealias Verification = __VerificationProxy_ValidatorInfoPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorInfoPresenterProtocol?

     func enableDefaultImplementation(_ stub: ValidatorInfoPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func reload()  {
        
    return cuckoo_manager.call(
    """
    reload()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload())
        
    }
    
    
    
    
    
     func presentAccountOptions()  {
        
    return cuckoo_manager.call(
    """
    presentAccountOptions()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentAccountOptions())
        
    }
    
    
    
    
    
     func presentTotalStake()  {
        
    return cuckoo_manager.call(
    """
    presentTotalStake()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentTotalStake())
        
    }
    
    
    
    
    
     func presentIdentityItem(_ value: ValidatorInfoViewModel.IdentityItemValue)  {
        
    return cuckoo_manager.call(
    """
    presentIdentityItem(_: ValidatorInfoViewModel.IdentityItemValue)
    """,
            parameters: (value),
            escapingParameters: (value),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentIdentityItem(value))
        
    }
    
    

     struct __StubbingProxy_ValidatorInfoPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func reload() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoPresenterProtocol.self, method:
    """
    reload()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentAccountOptions() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoPresenterProtocol.self, method:
    """
    presentAccountOptions()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentTotalStake() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoPresenterProtocol.self, method:
    """
    presentTotalStake()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentIdentityItem<M1: Cuckoo.Matchable>(_ value: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorInfoViewModel.IdentityItemValue)> where M1.MatchedType == ValidatorInfoViewModel.IdentityItemValue {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoViewModel.IdentityItemValue)>] = [wrap(matchable: value) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoPresenterProtocol.self, method:
    """
    presentIdentityItem(_: ValidatorInfoViewModel.IdentityItemValue)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorInfoPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func reload() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    reload()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentAccountOptions() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentAccountOptions()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentTotalStake() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentTotalStake()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentIdentityItem<M1: Cuckoo.Matchable>(_ value: M1) -> Cuckoo.__DoNotUse<(ValidatorInfoViewModel.IdentityItemValue), Void> where M1.MatchedType == ValidatorInfoViewModel.IdentityItemValue {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoViewModel.IdentityItemValue)>] = [wrap(matchable: value) { $0 }]
            return cuckoo_manager.verify(
    """
    presentIdentityItem(_: ValidatorInfoViewModel.IdentityItemValue)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorInfoPresenterProtocolStub: ValidatorInfoPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func reload()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentAccountOptions()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentTotalStake()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentIdentityItem(_ value: ValidatorInfoViewModel.IdentityItemValue)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorInfoWireframeProtocol: ValidatorInfoWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorInfoWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorInfoWireframeProtocol
     typealias Verification = __VerificationProxy_ValidatorInfoWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorInfoWireframeProtocol?

     func enableDefaultImplementation(_ stub: ValidatorInfoWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showStakingAmounts(from view: ValidatorInfoViewProtocol?, items: [LocalizableResource<StakingAmountViewModel>])  {
        
    return cuckoo_manager.call(
    """
    showStakingAmounts(from: ValidatorInfoViewProtocol?, items: [LocalizableResource<StakingAmountViewModel>])
    """,
            parameters: (view, items),
            escapingParameters: (view, items),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showStakingAmounts(from: view, items: items))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_ValidatorInfoWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showStakingAmounts<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, items: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorInfoViewProtocol?, [LocalizableResource<StakingAmountViewModel>])> where M1.OptionalMatchedType == ValidatorInfoViewProtocol, M2.MatchedType == [LocalizableResource<StakingAmountViewModel>] {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoViewProtocol?, [LocalizableResource<StakingAmountViewModel>])>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: items) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoWireframeProtocol.self, method:
    """
    showStakingAmounts(from: ValidatorInfoViewProtocol?, items: [LocalizableResource<StakingAmountViewModel>])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorInfoWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorInfoWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showStakingAmounts<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, items: M2) -> Cuckoo.__DoNotUse<(ValidatorInfoViewProtocol?, [LocalizableResource<StakingAmountViewModel>]), Void> where M1.OptionalMatchedType == ValidatorInfoViewProtocol, M2.MatchedType == [LocalizableResource<StakingAmountViewModel>] {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoViewProtocol?, [LocalizableResource<StakingAmountViewModel>])>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: items) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showStakingAmounts(from: ValidatorInfoViewProtocol?, items: [LocalizableResource<StakingAmountViewModel>])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorInfoWireframeProtocolStub: ValidatorInfoWireframeProtocol {
    

    

    
    
    
    
     func showStakingAmounts(from view: ValidatorInfoViewProtocol?, items: [LocalizableResource<StakingAmountViewModel>])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockValidatorListFilterWireframeProtocol: ValidatorListFilterWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorListFilterWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorListFilterWireframeProtocol
     typealias Verification = __VerificationProxy_ValidatorListFilterWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorListFilterWireframeProtocol?

     func enableDefaultImplementation(_ stub: ValidatorListFilterWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func close(_ view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(_: ControllerBackedProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view))
        
    }
    
    

     struct __StubbingProxy_ValidatorListFilterWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(_ view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?)> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterWireframeProtocol.self, method:
    """
    close(_: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorListFilterWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(_ view: M1) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(_: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorListFilterWireframeProtocolStub: ValidatorListFilterWireframeProtocol {
    

    

    
    
    
    
     func close(_ view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorListFilterViewProtocol: ValidatorListFilterViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorListFilterViewProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorListFilterViewProtocol
     typealias Verification = __VerificationProxy_ValidatorListFilterViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorListFilterViewProtocol?

     func enableDefaultImplementation(_ stub: ValidatorListFilterViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didUpdateViewModel(_ viewModel: ValidatorListFilterViewModel)  {
        
    return cuckoo_manager.call(
    """
    didUpdateViewModel(_: ValidatorListFilterViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didUpdateViewModel(viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_ValidatorListFilterViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorListFilterViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorListFilterViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockValidatorListFilterViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didUpdateViewModel<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorListFilterViewModel)> where M1.MatchedType == ValidatorListFilterViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorListFilterViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterViewProtocol.self, method:
    """
    didUpdateViewModel(_: ValidatorListFilterViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorListFilterViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didUpdateViewModel<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.__DoNotUse<(ValidatorListFilterViewModel), Void> where M1.MatchedType == ValidatorListFilterViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorListFilterViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didUpdateViewModel(_: ValidatorListFilterViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorListFilterViewProtocolStub: ValidatorListFilterViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didUpdateViewModel(_ viewModel: ValidatorListFilterViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorListFilterPresenterProtocol: ValidatorListFilterPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorListFilterPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorListFilterPresenterProtocol
     typealias Verification = __VerificationProxy_ValidatorListFilterPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorListFilterPresenterProtocol?

     func enableDefaultImplementation(_ stub: ValidatorListFilterPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var view: ValidatorListFilterViewProtocol? {
        get {
            return cuckoo_manager.getter("view",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.view)
        }
        
        set {
            cuckoo_manager.setter("view",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.view = newValue)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func toggleFilterItem(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    toggleFilterItem(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.toggleFilterItem(at: index))
        
    }
    
    
    
    
    
     func selectFilterItem(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    selectFilterItem(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectFilterItem(at: index))
        
    }
    
    
    
    
    
     func applyFilter()  {
        
    return cuckoo_manager.call(
    """
    applyFilter()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyFilter())
        
    }
    
    
    
    
    
     func resetFilter()  {
        
    return cuckoo_manager.call(
    """
    resetFilter()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.resetFilter())
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_ValidatorListFilterPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var view: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockValidatorListFilterPresenterProtocol, ValidatorListFilterViewProtocol> {
            return .init(manager: cuckoo_manager, name: "view")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockValidatorListFilterPresenterProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func toggleFilterItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterPresenterProtocol.self, method:
    """
    toggleFilterItem(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectFilterItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterPresenterProtocol.self, method:
    """
    selectFilterItem(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyFilter() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterPresenterProtocol.self, method:
    """
    applyFilter()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func resetFilter() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterPresenterProtocol.self, method:
    """
    resetFilter()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterPresenterProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorListFilterPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var view: Cuckoo.VerifyOptionalProperty<ValidatorListFilterViewProtocol> {
            return .init(manager: cuckoo_manager, name: "view", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func toggleFilterItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    toggleFilterItem(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectFilterItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    selectFilterItem(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyFilter() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyFilter()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func resetFilter() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    resetFilter()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorListFilterPresenterProtocolStub: ValidatorListFilterPresenterProtocol {
    
    
    
    
     var view: ValidatorListFilterViewProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (ValidatorListFilterViewProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func toggleFilterItem(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectFilterItem(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func applyFilter()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func resetFilter()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorListFilterDelegate: ValidatorListFilterDelegate, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorListFilterDelegate
    
     typealias Stubbing = __StubbingProxy_ValidatorListFilterDelegate
     typealias Verification = __VerificationProxy_ValidatorListFilterDelegate

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorListFilterDelegate?

     func enableDefaultImplementation(_ stub: ValidatorListFilterDelegate) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didUpdate(with flow: ValidatorListFilterFlow)  {
        
    return cuckoo_manager.call(
    """
    didUpdate(with: ValidatorListFilterFlow)
    """,
            parameters: (flow),
            escapingParameters: (flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didUpdate(with: flow))
        
    }
    
    

     struct __StubbingProxy_ValidatorListFilterDelegate: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didUpdate<M1: Cuckoo.Matchable>(with flow: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorListFilterFlow)> where M1.MatchedType == ValidatorListFilterFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorListFilterFlow)>] = [wrap(matchable: flow) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorListFilterDelegate.self, method:
    """
    didUpdate(with: ValidatorListFilterFlow)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorListFilterDelegate: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didUpdate<M1: Cuckoo.Matchable>(with flow: M1) -> Cuckoo.__DoNotUse<(ValidatorListFilterFlow), Void> where M1.MatchedType == ValidatorListFilterFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorListFilterFlow)>] = [wrap(matchable: flow) { $0 }]
            return cuckoo_manager.verify(
    """
    didUpdate(with: ValidatorListFilterFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorListFilterDelegateStub: ValidatorListFilterDelegate {
    

    

    
    
    
    
     func didUpdate(with flow: ValidatorListFilterFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockValidatorSearchWireframeProtocol: ValidatorSearchWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorSearchWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorSearchWireframeProtocol
     typealias Verification = __VerificationProxy_ValidatorSearchWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorSearchWireframeProtocol?

     func enableDefaultImplementation(_ stub: ValidatorSearchWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: ControllerBackedProtocol?)
    """,
            parameters: (flow, chainAsset, wallet, view),
            escapingParameters: (flow, chainAsset, wallet, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(flow: flow, chainAsset: chainAsset, wallet: wallet, from: view))
        
    }
    
    
    
    
    
     func close(_ view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(_: ControllerBackedProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_ValidatorSearchWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(flow: M1, chainAsset: M2, wallet: M3, from view: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, ControllerBackedProtocol?)> where M1.MatchedType == ValidatorInfoFlow, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, ControllerBackedProtocol?)>] = [wrap(matchable: flow) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchWireframeProtocol.self, method:
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(_ view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?)> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchWireframeProtocol.self, method:
    """
    close(_: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorSearchWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(flow: M1, chainAsset: M2, wallet: M3, from view: M4) -> Cuckoo.__DoNotUse<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, ControllerBackedProtocol?), Void> where M1.MatchedType == ValidatorInfoFlow, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, ControllerBackedProtocol?)>] = [wrap(matchable: flow) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return cuckoo_manager.verify(
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(_ view: M1) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(_: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorSearchWireframeProtocolStub: ValidatorSearchWireframeProtocol {
    

    

    
    
    
    
     func present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func close(_ view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorSearchRelaychainDelegate: ValidatorSearchRelaychainDelegate, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorSearchRelaychainDelegate
    
     typealias Stubbing = __StubbingProxy_ValidatorSearchRelaychainDelegate
     typealias Verification = __VerificationProxy_ValidatorSearchRelaychainDelegate

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorSearchRelaychainDelegate?

     func enableDefaultImplementation(_ stub: ValidatorSearchRelaychainDelegate) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func validatorSearchDidUpdate(selectedValidatorList: [SelectedValidatorInfo])  {
        
    return cuckoo_manager.call(
    """
    validatorSearchDidUpdate(selectedValidatorList: [SelectedValidatorInfo])
    """,
            parameters: (selectedValidatorList),
            escapingParameters: (selectedValidatorList),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.validatorSearchDidUpdate(selectedValidatorList: selectedValidatorList))
        
    }
    
    

     struct __StubbingProxy_ValidatorSearchRelaychainDelegate: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func validatorSearchDidUpdate<M1: Cuckoo.Matchable>(selectedValidatorList: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([SelectedValidatorInfo])> where M1.MatchedType == [SelectedValidatorInfo] {
            let matchers: [Cuckoo.ParameterMatcher<([SelectedValidatorInfo])>] = [wrap(matchable: selectedValidatorList) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchRelaychainDelegate.self, method:
    """
    validatorSearchDidUpdate(selectedValidatorList: [SelectedValidatorInfo])
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorSearchRelaychainDelegate: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func validatorSearchDidUpdate<M1: Cuckoo.Matchable>(selectedValidatorList: M1) -> Cuckoo.__DoNotUse<([SelectedValidatorInfo]), Void> where M1.MatchedType == [SelectedValidatorInfo] {
            let matchers: [Cuckoo.ParameterMatcher<([SelectedValidatorInfo])>] = [wrap(matchable: selectedValidatorList) { $0 }]
            return cuckoo_manager.verify(
    """
    validatorSearchDidUpdate(selectedValidatorList: [SelectedValidatorInfo])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorSearchRelaychainDelegateStub: ValidatorSearchRelaychainDelegate {
    

    

    
    
    
    
     func validatorSearchDidUpdate(selectedValidatorList: [SelectedValidatorInfo])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorSearchParachainDelegate: ValidatorSearchParachainDelegate, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorSearchParachainDelegate
    
     typealias Stubbing = __StubbingProxy_ValidatorSearchParachainDelegate
     typealias Verification = __VerificationProxy_ValidatorSearchParachainDelegate

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorSearchParachainDelegate?

     func enableDefaultImplementation(_ stub: ValidatorSearchParachainDelegate) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func validatorSearchDidUpdate(selectedValidatorList: [ParachainStakingCandidateInfo])  {
        
    return cuckoo_manager.call(
    """
    validatorSearchDidUpdate(selectedValidatorList: [ParachainStakingCandidateInfo])
    """,
            parameters: (selectedValidatorList),
            escapingParameters: (selectedValidatorList),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.validatorSearchDidUpdate(selectedValidatorList: selectedValidatorList))
        
    }
    
    

     struct __StubbingProxy_ValidatorSearchParachainDelegate: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func validatorSearchDidUpdate<M1: Cuckoo.Matchable>(selectedValidatorList: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([ParachainStakingCandidateInfo])> where M1.MatchedType == [ParachainStakingCandidateInfo] {
            let matchers: [Cuckoo.ParameterMatcher<([ParachainStakingCandidateInfo])>] = [wrap(matchable: selectedValidatorList) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchParachainDelegate.self, method:
    """
    validatorSearchDidUpdate(selectedValidatorList: [ParachainStakingCandidateInfo])
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorSearchParachainDelegate: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func validatorSearchDidUpdate<M1: Cuckoo.Matchable>(selectedValidatorList: M1) -> Cuckoo.__DoNotUse<([ParachainStakingCandidateInfo]), Void> where M1.MatchedType == [ParachainStakingCandidateInfo] {
            let matchers: [Cuckoo.ParameterMatcher<([ParachainStakingCandidateInfo])>] = [wrap(matchable: selectedValidatorList) { $0 }]
            return cuckoo_manager.verify(
    """
    validatorSearchDidUpdate(selectedValidatorList: [ParachainStakingCandidateInfo])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorSearchParachainDelegateStub: ValidatorSearchParachainDelegate {
    

    

    
    
    
    
     func validatorSearchDidUpdate(selectedValidatorList: [ParachainStakingCandidateInfo])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorSearchViewProtocol: ValidatorSearchViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorSearchViewProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorSearchViewProtocol
     typealias Verification = __VerificationProxy_ValidatorSearchViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorSearchViewProtocol?

     func enableDefaultImplementation(_ stub: ValidatorSearchViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didReload(_ viewModel: ValidatorSearchViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReload(_: ValidatorSearchViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReload(viewModel))
        
    }
    
    
    
    
    
     func didStartSearch()  {
        
    return cuckoo_manager.call(
    """
    didStartSearch()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartSearch())
        
    }
    
    
    
    
    
     func didStopSearch()  {
        
    return cuckoo_manager.call(
    """
    didStopSearch()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopSearch())
        
    }
    
    
    
    
    
     func didReset()  {
        
    return cuckoo_manager.call(
    """
    didReset()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReset())
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_ValidatorSearchViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorSearchViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockValidatorSearchViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockValidatorSearchViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didReload<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorSearchViewModel)> where M1.MatchedType == ValidatorSearchViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorSearchViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchViewProtocol.self, method:
    """
    didReload(_: ValidatorSearchViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartSearch() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchViewProtocol.self, method:
    """
    didStartSearch()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopSearch() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchViewProtocol.self, method:
    """
    didStopSearch()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReset() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchViewProtocol.self, method:
    """
    didReset()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorSearchViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReload<M1: Cuckoo.Matchable>(_ viewModel: M1) -> Cuckoo.__DoNotUse<(ValidatorSearchViewModel), Void> where M1.MatchedType == ValidatorSearchViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorSearchViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReload(_: ValidatorSearchViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartSearch() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartSearch()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopSearch() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopSearch()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReset() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didReset()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorSearchViewProtocolStub: ValidatorSearchViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didReload(_ viewModel: ValidatorSearchViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartSearch()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopSearch()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReset()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorSearchInteractorInputProtocol: ValidatorSearchInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorSearchInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorSearchInteractorInputProtocol
     typealias Verification = __VerificationProxy_ValidatorSearchInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorSearchInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: ValidatorSearchInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func performValidatorSearch(accountId: AccountId)  {
        
    return cuckoo_manager.call(
    """
    performValidatorSearch(accountId: AccountId)
    """,
            parameters: (accountId),
            escapingParameters: (accountId),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performValidatorSearch(accountId: accountId))
        
    }
    
    

     struct __StubbingProxy_ValidatorSearchInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func performValidatorSearch<M1: Cuckoo.Matchable>(accountId: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountId)> where M1.MatchedType == AccountId {
            let matchers: [Cuckoo.ParameterMatcher<(AccountId)>] = [wrap(matchable: accountId) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchInteractorInputProtocol.self, method:
    """
    performValidatorSearch(accountId: AccountId)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorSearchInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func performValidatorSearch<M1: Cuckoo.Matchable>(accountId: M1) -> Cuckoo.__DoNotUse<(AccountId), Void> where M1.MatchedType == AccountId {
            let matchers: [Cuckoo.ParameterMatcher<(AccountId)>] = [wrap(matchable: accountId) { $0 }]
            return cuckoo_manager.verify(
    """
    performValidatorSearch(accountId: AccountId)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorSearchInteractorInputProtocolStub: ValidatorSearchInteractorInputProtocol {
    

    

    
    
    
    
     func performValidatorSearch(accountId: AccountId)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockValidatorSearchInteractorOutputProtocol: ValidatorSearchInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorSearchInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorSearchInteractorOutputProtocol
     typealias Verification = __VerificationProxy_ValidatorSearchInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorSearchInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: ValidatorSearchInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    

     struct __StubbingProxy_ValidatorSearchInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
    }

     struct __VerificationProxy_ValidatorSearchInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
    }
}


 class ValidatorSearchInteractorOutputProtocolStub: ValidatorSearchInteractorOutputProtocol {
    

    

    
}










 class MockValidatorSearchPresenterProtocol: ValidatorSearchPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = ValidatorSearchPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_ValidatorSearchPresenterProtocol
     typealias Verification = __VerificationProxy_ValidatorSearchPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: ValidatorSearchPresenterProtocol?

     func enableDefaultImplementation(_ stub: ValidatorSearchPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func changeValidatorSelection(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    changeValidatorSelection(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.changeValidatorSelection(at: index))
        
    }
    
    
    
    
    
     func search(for textEntry: String)  {
        
    return cuckoo_manager.call(
    """
    search(for: String)
    """,
            parameters: (textEntry),
            escapingParameters: (textEntry),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.search(for: textEntry))
        
    }
    
    
    
    
    
     func didSelectValidator(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    didSelectValidator(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSelectValidator(at: index))
        
    }
    
    
    
    
    
     func applyChanges()  {
        
    return cuckoo_manager.call(
    """
    applyChanges()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyChanges())
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_ValidatorSearchPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockValidatorSearchPresenterProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func changeValidatorSelection<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchPresenterProtocol.self, method:
    """
    changeValidatorSelection(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func search<M1: Cuckoo.Matchable>(for textEntry: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String)> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: textEntry) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchPresenterProtocol.self, method:
    """
    search(for: String)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didSelectValidator<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchPresenterProtocol.self, method:
    """
    didSelectValidator(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyChanges() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchPresenterProtocol.self, method:
    """
    applyChanges()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockValidatorSearchPresenterProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_ValidatorSearchPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func changeValidatorSelection<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    changeValidatorSelection(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func search<M1: Cuckoo.Matchable>(for textEntry: M1) -> Cuckoo.__DoNotUse<(String), Void> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: textEntry) { $0 }]
            return cuckoo_manager.verify(
    """
    search(for: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didSelectValidator<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    didSelectValidator(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyChanges() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyChanges()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class ValidatorSearchPresenterProtocolStub: ValidatorSearchPresenterProtocol {
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func changeValidatorSelection(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func search(for textEntry: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didSelectValidator(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func applyChanges()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockYourValidatorListViewProtocol: YourValidatorListViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = YourValidatorListViewProtocol
    
     typealias Stubbing = __StubbingProxy_YourValidatorListViewProtocol
     typealias Verification = __VerificationProxy_YourValidatorListViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: YourValidatorListViewProtocol?

     func enableDefaultImplementation(_ stub: YourValidatorListViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func reload(state: YourValidatorListViewState)  {
        
    return cuckoo_manager.call(
    """
    reload(state: YourValidatorListViewState)
    """,
            parameters: (state),
            escapingParameters: (state),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload(state: state))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_YourValidatorListViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockYourValidatorListViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockYourValidatorListViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockYourValidatorListViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockYourValidatorListViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockYourValidatorListViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func reload<M1: Cuckoo.Matchable>(state: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(YourValidatorListViewState)> where M1.MatchedType == YourValidatorListViewState {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorListViewState)>] = [wrap(matchable: state) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListViewProtocol.self, method:
    """
    reload(state: YourValidatorListViewState)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_YourValidatorListViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func reload<M1: Cuckoo.Matchable>(state: M1) -> Cuckoo.__DoNotUse<(YourValidatorListViewState), Void> where M1.MatchedType == YourValidatorListViewState {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorListViewState)>] = [wrap(matchable: state) { $0 }]
            return cuckoo_manager.verify(
    """
    reload(state: YourValidatorListViewState)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class YourValidatorListViewProtocolStub: YourValidatorListViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func reload(state: YourValidatorListViewState)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockYourValidatorListPresenterProtocol: YourValidatorListPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = YourValidatorListPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_YourValidatorListPresenterProtocol
     typealias Verification = __VerificationProxy_YourValidatorListPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: YourValidatorListPresenterProtocol?

     func enableDefaultImplementation(_ stub: YourValidatorListPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func retry()  {
        
    return cuckoo_manager.call(
    """
    retry()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.retry())
        
    }
    
    
    
    
    
     func didSelectValidator(viewModel: YourValidatorViewModel)  {
        
    return cuckoo_manager.call(
    """
    didSelectValidator(viewModel: YourValidatorViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSelectValidator(viewModel: viewModel))
        
    }
    
    
    
    
    
     func changeValidators()  {
        
    return cuckoo_manager.call(
    """
    changeValidators()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.changeValidators())
        
    }
    
    
    
    
    
     func didLoad(view: YourValidatorListViewProtocol)  {
        
    return cuckoo_manager.call(
    """
    didLoad(view: YourValidatorListViewProtocol)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didLoad(view: view))
        
    }
    
    
    
    
    
     func willAppear(view: YourValidatorListViewProtocol)  {
        
    return cuckoo_manager.call(
    """
    willAppear(view: YourValidatorListViewProtocol)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.willAppear(view: view))
        
    }
    
    

     struct __StubbingProxy_YourValidatorListPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func retry() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListPresenterProtocol.self, method:
    """
    retry()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didSelectValidator<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(YourValidatorViewModel)> where M1.MatchedType == YourValidatorViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListPresenterProtocol.self, method:
    """
    didSelectValidator(viewModel: YourValidatorViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func changeValidators() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListPresenterProtocol.self, method:
    """
    changeValidators()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(YourValidatorListViewProtocol)> where M1.MatchedType == YourValidatorListViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorListViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListPresenterProtocol.self, method:
    """
    didLoad(view: YourValidatorListViewProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func willAppear<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(YourValidatorListViewProtocol)> where M1.MatchedType == YourValidatorListViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorListViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListPresenterProtocol.self, method:
    """
    willAppear(view: YourValidatorListViewProtocol)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_YourValidatorListPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func retry() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    retry()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didSelectValidator<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(YourValidatorViewModel), Void> where M1.MatchedType == YourValidatorViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didSelectValidator(viewModel: YourValidatorViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func changeValidators() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    changeValidators()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.__DoNotUse<(YourValidatorListViewProtocol), Void> where M1.MatchedType == YourValidatorListViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorListViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    didLoad(view: YourValidatorListViewProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func willAppear<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.__DoNotUse<(YourValidatorListViewProtocol), Void> where M1.MatchedType == YourValidatorListViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorListViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    willAppear(view: YourValidatorListViewProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class YourValidatorListPresenterProtocolStub: YourValidatorListPresenterProtocol {
    

    

    
    
    
    
     func retry()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didSelectValidator(viewModel: YourValidatorViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func changeValidators()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didLoad(view: YourValidatorListViewProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func willAppear(view: YourValidatorListViewProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockYourValidatorListInteractorInputProtocol: YourValidatorListInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = YourValidatorListInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_YourValidatorListInteractorInputProtocol
     typealias Verification = __VerificationProxy_YourValidatorListInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: YourValidatorListInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: YourValidatorListInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func refresh()  {
        
    return cuckoo_manager.call(
    """
    refresh()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.refresh())
        
    }
    
    

     struct __StubbingProxy_YourValidatorListInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func refresh() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListInteractorInputProtocol.self, method:
    """
    refresh()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_YourValidatorListInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func refresh() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    refresh()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class YourValidatorListInteractorInputProtocolStub: YourValidatorListInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func refresh()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockYourValidatorListInteractorOutputProtocol: YourValidatorListInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = YourValidatorListInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_YourValidatorListInteractorOutputProtocol
     typealias Verification = __VerificationProxy_YourValidatorListInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: YourValidatorListInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: YourValidatorListInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    

     struct __StubbingProxy_YourValidatorListInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
    }

     struct __VerificationProxy_YourValidatorListInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
    }
}


 class YourValidatorListInteractorOutputProtocolStub: YourValidatorListInteractorOutputProtocol {
    

    

    
}










 class MockYourValidatorListWireframeProtocol: YourValidatorListWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = YourValidatorListWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_YourValidatorListWireframeProtocol
     typealias Verification = __VerificationProxy_YourValidatorListWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: YourValidatorListWireframeProtocol?

     func enableDefaultImplementation(_ stub: YourValidatorListWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from view: YourValidatorListViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: YourValidatorListViewProtocol?)
    """,
            parameters: (flow, chainAsset, wallet, view),
            escapingParameters: (flow, chainAsset, wallet, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(flow: flow, chainAsset: chainAsset, wallet: wallet, from: view))
        
    }
    
    
    
    
    
     func proceedToSelectValidatorsStart(from view: YourValidatorListViewProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: SelectValidatorsStartFlow)  {
        
    return cuckoo_manager.call(
    """
    proceedToSelectValidatorsStart(from: YourValidatorListViewProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: SelectValidatorsStartFlow)
    """,
            parameters: (view, chainAsset, wallet, flow),
            escapingParameters: (view, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceedToSelectValidatorsStart(from: view, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_YourValidatorListWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(flow: M1, chainAsset: M2, wallet: M3, from view: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, YourValidatorListViewProtocol?)> where M1.MatchedType == ValidatorInfoFlow, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.OptionalMatchedType == YourValidatorListViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, YourValidatorListViewProtocol?)>] = [wrap(matchable: flow) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListWireframeProtocol.self, method:
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: YourValidatorListViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceedToSelectValidatorsStart<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(YourValidatorListViewProtocol?, ChainAsset, MetaAccountModel, SelectValidatorsStartFlow)> where M1.OptionalMatchedType == YourValidatorListViewProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == SelectValidatorsStartFlow {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorListViewProtocol?, ChainAsset, MetaAccountModel, SelectValidatorsStartFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListWireframeProtocol.self, method:
    """
    proceedToSelectValidatorsStart(from: YourValidatorListViewProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: SelectValidatorsStartFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockYourValidatorListWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_YourValidatorListWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(flow: M1, chainAsset: M2, wallet: M3, from view: M4) -> Cuckoo.__DoNotUse<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, YourValidatorListViewProtocol?), Void> where M1.MatchedType == ValidatorInfoFlow, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.OptionalMatchedType == YourValidatorListViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorInfoFlow, ChainAsset, MetaAccountModel, YourValidatorListViewProtocol?)>] = [wrap(matchable: flow) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return cuckoo_manager.verify(
    """
    present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from: YourValidatorListViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceedToSelectValidatorsStart<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.__DoNotUse<(YourValidatorListViewProtocol?, ChainAsset, MetaAccountModel, SelectValidatorsStartFlow), Void> where M1.OptionalMatchedType == YourValidatorListViewProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == SelectValidatorsStartFlow {
            let matchers: [Cuckoo.ParameterMatcher<(YourValidatorListViewProtocol?, ChainAsset, MetaAccountModel, SelectValidatorsStartFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return cuckoo_manager.verify(
    """
    proceedToSelectValidatorsStart(from: YourValidatorListViewProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: SelectValidatorsStartFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class YourValidatorListWireframeProtocolStub: YourValidatorListWireframeProtocol {
    

    

    
    
    
    
     func present(flow: ValidatorInfoFlow, chainAsset: ChainAsset, wallet: MetaAccountModel, from view: YourValidatorListViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceedToSelectValidatorsStart(from view: YourValidatorListViewProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: SelectValidatorsStartFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockStakingBalanceViewProtocol: StakingBalanceViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBalanceViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBalanceViewProtocol
     typealias Verification = __VerificationProxy_StakingBalanceViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBalanceViewProtocol?

     func enableDefaultImplementation(_ stub: StakingBalanceViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func reload(with viewModel: LocalizableResource<StakingBalanceViewModel>)  {
        
    return cuckoo_manager.call(
    """
    reload(with: LocalizableResource<StakingBalanceViewModel>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload(with: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_StakingBalanceViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBalanceViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBalanceViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingBalanceViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBalanceViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBalanceViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func reload<M1: Cuckoo.Matchable>(with viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<StakingBalanceViewModel>)> where M1.MatchedType == LocalizableResource<StakingBalanceViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<StakingBalanceViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceViewProtocol.self, method:
    """
    reload(with: LocalizableResource<StakingBalanceViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBalanceViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func reload<M1: Cuckoo.Matchable>(with viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<StakingBalanceViewModel>), Void> where M1.MatchedType == LocalizableResource<StakingBalanceViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<StakingBalanceViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    reload(with: LocalizableResource<StakingBalanceViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBalanceViewProtocolStub: StakingBalanceViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func reload(with viewModel: LocalizableResource<StakingBalanceViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBalancePresenterProtocol: StakingBalancePresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBalancePresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBalancePresenterProtocol
     typealias Verification = __VerificationProxy_StakingBalancePresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBalancePresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingBalancePresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func handleRefresh()  {
        
    return cuckoo_manager.call(
    """
    handleRefresh()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handleRefresh())
        
    }
    
    
    
    
    
     func handleAction(_ action: StakingBalanceAction)  {
        
    return cuckoo_manager.call(
    """
    handleAction(_: StakingBalanceAction)
    """,
            parameters: (action),
            escapingParameters: (action),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handleAction(action))
        
    }
    
    
    
    
    
     func handleUnbondingMoreAction()  {
        
    return cuckoo_manager.call(
    """
    handleUnbondingMoreAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handleUnbondingMoreAction())
        
    }
    
    

     struct __StubbingProxy_StakingBalancePresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalancePresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handleRefresh() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalancePresenterProtocol.self, method:
    """
    handleRefresh()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handleAction<M1: Cuckoo.Matchable>(_ action: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingBalanceAction)> where M1.MatchedType == StakingBalanceAction {
            let matchers: [Cuckoo.ParameterMatcher<(StakingBalanceAction)>] = [wrap(matchable: action) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalancePresenterProtocol.self, method:
    """
    handleAction(_: StakingBalanceAction)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handleUnbondingMoreAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalancePresenterProtocol.self, method:
    """
    handleUnbondingMoreAction()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBalancePresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handleRefresh() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    handleRefresh()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handleAction<M1: Cuckoo.Matchable>(_ action: M1) -> Cuckoo.__DoNotUse<(StakingBalanceAction), Void> where M1.MatchedType == StakingBalanceAction {
            let matchers: [Cuckoo.ParameterMatcher<(StakingBalanceAction)>] = [wrap(matchable: action) { $0 }]
            return cuckoo_manager.verify(
    """
    handleAction(_: StakingBalanceAction)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handleUnbondingMoreAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    handleUnbondingMoreAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBalancePresenterProtocolStub: StakingBalancePresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handleRefresh()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handleAction(_ action: StakingBalanceAction)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handleUnbondingMoreAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBalanceInteractorInputProtocol: StakingBalanceInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBalanceInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBalanceInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingBalanceInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBalanceInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingBalanceInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func refresh()  {
        
    return cuckoo_manager.call(
    """
    refresh()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.refresh())
        
    }
    
    

     struct __StubbingProxy_StakingBalanceInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func refresh() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceInteractorInputProtocol.self, method:
    """
    refresh()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBalanceInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func refresh() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    refresh()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBalanceInteractorInputProtocolStub: StakingBalanceInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func refresh()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBalanceInteractorOutputProtocol: StakingBalanceInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBalanceInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBalanceInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingBalanceInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBalanceInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingBalanceInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(priceResult: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(priceResult: Result<PriceData?, Error>)
    """,
            parameters: (priceResult),
            escapingParameters: (priceResult),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(priceResult: priceResult))
        
    }
    
    

     struct __StubbingProxy_StakingBalanceInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(priceResult: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: priceResult) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceInteractorOutputProtocol.self, method:
    """
    didReceive(priceResult: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBalanceInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(priceResult: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: priceResult) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(priceResult: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBalanceInteractorOutputProtocolStub: StakingBalanceInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceive(priceResult: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBalanceWireframeProtocol: StakingBalanceWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBalanceWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBalanceWireframeProtocol
     typealias Verification = __VerificationProxy_StakingBalanceWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBalanceWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingBalanceWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showBondMore(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)  {
        
    return cuckoo_manager.call(
    """
    showBondMore(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)
    """,
            parameters: (view, chainAsset, wallet, flow),
            escapingParameters: (view, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showBondMore(from: view, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func showUnbond(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingUnbondSetupFlow)  {
        
    return cuckoo_manager.call(
    """
    showUnbond(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingUnbondSetupFlow)
    """,
            parameters: (view, chainAsset, wallet, flow),
            escapingParameters: (view, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showUnbond(from: view, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func showRedeem(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)  {
        
    return cuckoo_manager.call(
    """
    showRedeem(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)
    """,
            parameters: (view, chainAsset, wallet, flow),
            escapingParameters: (view, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showRedeem(from: view, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func showRebondSetup(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showRebondSetup(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """,
            parameters: (view, chainAsset, wallet),
            escapingParameters: (view, chainAsset, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showRebondSetup(from: view, chainAsset: chainAsset, wallet: wallet))
        
    }
    
    
    
    
    
     func showRebondConfirm(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)  {
        
    return cuckoo_manager.call(
    """
    showRebondConfirm(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)
    """,
            parameters: (view, chainAsset, wallet, flow),
            escapingParameters: (view, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showRebondConfirm(from: view, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func cancel(from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    cancel(from: ControllerBackedProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.cancel(from: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingBalanceWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showBondMore<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBondMoreFlow)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingBondMoreFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBondMoreFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceWireframeProtocol.self, method:
    """
    showBondMore(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showUnbond<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingUnbondSetupFlow)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingUnbondSetupFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingUnbondSetupFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceWireframeProtocol.self, method:
    """
    showUnbond(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingUnbondSetupFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showRedeem<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRedeemConfirmationFlow)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingRedeemConfirmationFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRedeemConfirmationFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceWireframeProtocol.self, method:
    """
    showRedeem(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showRebondSetup<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceWireframeProtocol.self, method:
    """
    showRebondSetup(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showRebondConfirm<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRebondConfirmationFlow)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingRebondConfirmationFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRebondConfirmationFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceWireframeProtocol.self, method:
    """
    showRebondConfirm(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func cancel<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?)> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceWireframeProtocol.self, method:
    """
    cancel(from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBalanceWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBalanceWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showBondMore<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBondMoreFlow), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingBondMoreFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBondMoreFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showBondMore(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showUnbond<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingUnbondSetupFlow), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingUnbondSetupFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingUnbondSetupFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showUnbond(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingUnbondSetupFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showRedeem<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRedeemConfirmationFlow), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingRedeemConfirmationFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRedeemConfirmationFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showRedeem(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showRebondSetup<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showRebondSetup(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showRebondConfirm<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRebondConfirmationFlow), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingRebondConfirmationFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRebondConfirmationFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showRebondConfirm(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func cancel<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    cancel(from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBalanceWireframeProtocolStub: StakingBalanceWireframeProtocol {
    

    

    
    
    
    
     func showBondMore(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showUnbond(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingUnbondSetupFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showRedeem(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showRebondSetup(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showRebondConfirm(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func cancel(from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import CommonWallet
import SoraFoundation






 class MockStakingBondMoreViewProtocol: StakingBondMoreViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreViewProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreViewProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveInput(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAsset(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveAccount(viewModel: AccountViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccount(viewModel: AccountViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccount(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveCollator(viewModel: AccountViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCollator(viewModel: AccountViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCollator(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveHints(viewModel: LocalizableResource<String>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveHints(viewModel: LocalizableResource<String>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveHints(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_StakingBondMoreViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBondMoreViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBondMoreViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingBondMoreViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<IAmountInputViewModel>)> where M1.MatchedType == LocalizableResource<IAmountInputViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<IAmountInputViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreViewProtocol.self, method:
    """
    didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<AssetBalanceViewModelProtocol>)> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreViewProtocol.self, method:
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<NetworkFeeFooterViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<NetworkFeeFooterViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<NetworkFeeFooterViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreViewProtocol.self, method:
    """
    didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccount<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountViewModel)> where M1.MatchedType == AccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreViewProtocol.self, method:
    """
    didReceiveAccount(viewModel: AccountViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveCollator<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountViewModel)> where M1.MatchedType == AccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreViewProtocol.self, method:
    """
    didReceiveCollator(viewModel: AccountViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveHints<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<String>?)> where M1.OptionalMatchedType == LocalizableResource<String> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<String>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreViewProtocol.self, method:
    """
    didReceiveHints(viewModel: LocalizableResource<String>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMoreViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<IAmountInputViewModel>), Void> where M1.MatchedType == LocalizableResource<IAmountInputViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<IAmountInputViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<AssetBalanceViewModelProtocol>), Void> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<NetworkFeeFooterViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<NetworkFeeFooterViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<NetworkFeeFooterViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccount<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(AccountViewModel), Void> where M1.MatchedType == AccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccount(viewModel: AccountViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveCollator<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(AccountViewModel), Void> where M1.MatchedType == AccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCollator(viewModel: AccountViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveHints<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<String>?), Void> where M1.OptionalMatchedType == LocalizableResource<String> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<String>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveHints(viewModel: LocalizableResource<String>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMoreViewProtocolStub: StakingBondMoreViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccount(viewModel: AccountViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveCollator(viewModel: AccountViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveHints(viewModel: LocalizableResource<String>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBondMorePresenterProtocol: StakingBondMorePresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMorePresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMorePresenterProtocol
     typealias Verification = __VerificationProxy_StakingBondMorePresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMorePresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMorePresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func handleContinueAction()  {
        
    return cuckoo_manager.call(
    """
    handleContinueAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handleContinueAction())
        
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)  {
        
    return cuckoo_manager.call(
    """
    updateAmount(_: Decimal)
    """,
            parameters: (newValue),
            escapingParameters: (newValue),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.updateAmount(newValue))
        
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)  {
        
    return cuckoo_manager.call(
    """
    selectAmountPercentage(_: Float)
    """,
            parameters: (percentage),
            escapingParameters: (percentage),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectAmountPercentage(percentage))
        
    }
    
    
    
    
    
     func didTapBackButton()  {
        
    return cuckoo_manager.call(
    """
    didTapBackButton()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didTapBackButton())
        
    }
    
    

     struct __StubbingProxy_StakingBondMorePresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMorePresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handleContinueAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMorePresenterProtocol.self, method:
    """
    handleContinueAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Decimal)> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMorePresenterProtocol.self, method:
    """
    updateAmount(_: Decimal)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Float)> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMorePresenterProtocol.self, method:
    """
    selectAmountPercentage(_: Float)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didTapBackButton() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMorePresenterProtocol.self, method:
    """
    didTapBackButton()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMorePresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handleContinueAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    handleContinueAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.__DoNotUse<(Decimal), Void> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return cuckoo_manager.verify(
    """
    updateAmount(_: Decimal)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.__DoNotUse<(Float), Void> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return cuckoo_manager.verify(
    """
    selectAmountPercentage(_: Float)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didTapBackButton() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didTapBackButton()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMorePresenterProtocolStub: StakingBondMorePresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handleContinueAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didTapBackButton()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBondMoreInteractorInputProtocol: StakingBondMoreInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(reuseIdentifier: String?, builderClosure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(reuseIdentifier: String?, builderClosure: ExtrinsicBuilderClosure?)
    """,
            parameters: (reuseIdentifier, builderClosure),
            escapingParameters: (reuseIdentifier, builderClosure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(reuseIdentifier: reuseIdentifier, builderClosure: builderClosure))
        
    }
    
    

     struct __StubbingProxy_StakingBondMoreInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(reuseIdentifier: M1, builderClosure: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == String, M2.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(String?, ExtrinsicBuilderClosure?)>] = [wrap(matchable: reuseIdentifier) { $0.0 }, wrap(matchable: builderClosure) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreInteractorInputProtocol.self, method:
    """
    estimateFee(reuseIdentifier: String?, builderClosure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMoreInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(reuseIdentifier: M1, builderClosure: M2) -> Cuckoo.__DoNotUse<(String?, ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == String, M2.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(String?, ExtrinsicBuilderClosure?)>] = [wrap(matchable: reuseIdentifier) { $0.0 }, wrap(matchable: builderClosure) { $0.1 }]
            return cuckoo_manager.verify(
    """
    estimateFee(reuseIdentifier: String?, builderClosure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMoreInteractorInputProtocolStub: StakingBondMoreInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(reuseIdentifier: String?, builderClosure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBondMoreInteractorOutputProtocol: StakingBondMoreInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingBondMoreInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMoreInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMoreInteractorOutputProtocolStub: StakingBondMoreInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBondMoreWireframeProtocol: StakingBondMoreWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreWireframeProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showConfirmation(from view: ControllerBackedProtocol?, flow: StakingBondMoreConfirmationFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showConfirmation(from: ControllerBackedProtocol?, flow: StakingBondMoreConfirmationFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """,
            parameters: (view, flow, chainAsset, wallet),
            escapingParameters: (view, flow, chainAsset, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showConfirmation(from: view, flow: flow, chainAsset: chainAsset, wallet: wallet))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingBondMoreWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showConfirmation<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, StakingBondMoreConfirmationFlow, ChainAsset, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == StakingBondMoreConfirmationFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, StakingBondMoreConfirmationFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreWireframeProtocol.self, method:
    """
    showConfirmation(from: ControllerBackedProtocol?, flow: StakingBondMoreConfirmationFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMoreWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showConfirmation<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, StakingBondMoreConfirmationFlow, ChainAsset, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == StakingBondMoreConfirmationFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, StakingBondMoreConfirmationFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showConfirmation(from: ControllerBackedProtocol?, flow: StakingBondMoreConfirmationFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMoreWireframeProtocolStub: StakingBondMoreWireframeProtocol {
    

    

    
    
    
    
     func showConfirmation(from view: ControllerBackedProtocol?, flow: StakingBondMoreConfirmationFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import CommonWallet
import SoraFoundation






 class MockStakingBondMoreConfirmationViewProtocol: StakingBondMoreConfirmationViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreConfirmationViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreConfirmationViewProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreConfirmationViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreConfirmationViewProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreConfirmationViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingBondMoreConfirmViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveConfirmation(viewModel: StakingBondMoreConfirmViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveConfirmation(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAsset(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_StakingBondMoreConfirmationViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBondMoreConfirmationViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBondMoreConfirmationViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingBondMoreConfirmationViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBondMoreConfirmationViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingBondMoreConfirmationViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingBondMoreConfirmViewModel)> where M1.MatchedType == StakingBondMoreConfirmViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingBondMoreConfirmViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationViewProtocol.self, method:
    """
    didReceiveConfirmation(viewModel: StakingBondMoreConfirmViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<AssetBalanceViewModelProtocol>)> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationViewProtocol.self, method:
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<BalanceViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationViewProtocol.self, method:
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMoreConfirmationViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(StakingBondMoreConfirmViewModel), Void> where M1.MatchedType == StakingBondMoreConfirmViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingBondMoreConfirmViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveConfirmation(viewModel: StakingBondMoreConfirmViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<AssetBalanceViewModelProtocol>), Void> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<BalanceViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMoreConfirmationViewProtocolStub: StakingBondMoreConfirmationViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingBondMoreConfirmViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBondMoreConfirmationPresenterProtocol: StakingBondMoreConfirmationPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreConfirmationPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreConfirmationPresenterProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreConfirmationPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreConfirmationPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreConfirmationPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func confirm()  {
        
    return cuckoo_manager.call(
    """
    confirm()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm())
        
    }
    
    
    
    
    
     func selectAccount()  {
        
    return cuckoo_manager.call(
    """
    selectAccount()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectAccount())
        
    }
    
    
    
    
    
     func didTapBackButton()  {
        
    return cuckoo_manager.call(
    """
    didTapBackButton()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didTapBackButton())
        
    }
    
    

     struct __StubbingProxy_StakingBondMoreConfirmationPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func confirm() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationPresenterProtocol.self, method:
    """
    confirm()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectAccount() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationPresenterProtocol.self, method:
    """
    selectAccount()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didTapBackButton() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationPresenterProtocol.self, method:
    """
    didTapBackButton()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMoreConfirmationPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func confirm() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    confirm()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectAccount() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectAccount()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didTapBackButton() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didTapBackButton()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMoreConfirmationPresenterProtocolStub: StakingBondMoreConfirmationPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func confirm()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectAccount()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didTapBackButton()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBondMoreConfirmationInteractorInputProtocol: StakingBondMoreConfirmationInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreConfirmationInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreConfirmationInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreConfirmationInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreConfirmationInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreConfirmationInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """,
            parameters: (builderClosure, reuseIdentifier),
            escapingParameters: (builderClosure, reuseIdentifier),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(builderClosure: builderClosure, reuseIdentifier: reuseIdentifier))
        
    }
    
    
    
    
    
     func submit(builderClosure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """,
            parameters: (builderClosure),
            escapingParameters: (builderClosure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.submit(builderClosure: builderClosure))
        
    }
    
    

     struct __StubbingProxy_StakingBondMoreConfirmationInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(builderClosure: M1, reuseIdentifier: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?, String?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure, M2.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?, String?)>] = [wrap(matchable: builderClosure) { $0.0 }, wrap(matchable: reuseIdentifier) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationInteractorInputProtocol.self, method:
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func submit<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationInteractorInputProtocol.self, method:
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMoreConfirmationInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(builderClosure: M1, reuseIdentifier: M2) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?, String?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure, M2.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?, String?)>] = [wrap(matchable: builderClosure) { $0.0 }, wrap(matchable: reuseIdentifier) { $0.1 }]
            return cuckoo_manager.verify(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func submit<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return cuckoo_manager.verify(
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMoreConfirmationInteractorInputProtocolStub: StakingBondMoreConfirmationInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func submit(builderClosure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBondMoreConfirmationOutputProtocol: StakingBondMoreConfirmationOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreConfirmationOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreConfirmationOutputProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreConfirmationOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreConfirmationOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreConfirmationOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingBondMoreConfirmationOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMoreConfirmationOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMoreConfirmationOutputProtocolStub: StakingBondMoreConfirmationOutputProtocol {
    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBondMoreConfirmationWireframeProtocol: StakingBondMoreConfirmationWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreConfirmationWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreConfirmationWireframeProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreConfirmationWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreConfirmationWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreConfirmationWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(from view: StakingBondMoreConfirmationViewProtocol, chainAsset: ChainAsset, extrinsicHash: String)  {
        
    return cuckoo_manager.call(
    """
    complete(from: StakingBondMoreConfirmationViewProtocol, chainAsset: ChainAsset, extrinsicHash: String)
    """,
            parameters: (view, chainAsset, extrinsicHash),
            escapingParameters: (view, chainAsset, extrinsicHash),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(from: view, chainAsset: chainAsset, extrinsicHash: extrinsicHash))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingBondMoreConfirmationWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, chainAsset: M2, extrinsicHash: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingBondMoreConfirmationViewProtocol, ChainAsset, String)> where M1.MatchedType == StakingBondMoreConfirmationViewProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(StakingBondMoreConfirmationViewProtocol, ChainAsset, String)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: extrinsicHash) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationWireframeProtocol.self, method:
    """
    complete(from: StakingBondMoreConfirmationViewProtocol, chainAsset: ChainAsset, extrinsicHash: String)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingBondMoreConfirmationWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingBondMoreConfirmationWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, chainAsset: M2, extrinsicHash: M3) -> Cuckoo.__DoNotUse<(StakingBondMoreConfirmationViewProtocol, ChainAsset, String), Void> where M1.MatchedType == StakingBondMoreConfirmationViewProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(StakingBondMoreConfirmationViewProtocol, ChainAsset, String)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: extrinsicHash) { $0.2 }]
            return cuckoo_manager.verify(
    """
    complete(from: StakingBondMoreConfirmationViewProtocol, chainAsset: ChainAsset, extrinsicHash: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingBondMoreConfirmationWireframeProtocolStub: StakingBondMoreConfirmationWireframeProtocol {
    

    

    
    
    
    
     func complete(from view: StakingBondMoreConfirmationViewProtocol, chainAsset: ChainAsset, extrinsicHash: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingBondMoreConfirmationViewLayoutProtocol: StakingBondMoreConfirmationViewLayoutProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingBondMoreConfirmationViewLayoutProtocol
    
     typealias Stubbing = __StubbingProxy_StakingBondMoreConfirmationViewLayoutProtocol
     typealias Verification = __VerificationProxy_StakingBondMoreConfirmationViewLayoutProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingBondMoreConfirmationViewLayoutProtocol?

     func enableDefaultImplementation(_ stub: StakingBondMoreConfirmationViewLayoutProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var locale: Locale {
        get {
            return cuckoo_manager.getter("locale",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.locale)
        }
        
        set {
            cuckoo_manager.setter("locale",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.locale = newValue)
        }
        
    }
    
    

    

    

     struct __StubbingProxy_StakingBondMoreConfirmationViewLayoutProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var locale: Cuckoo.ProtocolToBeStubbedProperty<MockStakingBondMoreConfirmationViewLayoutProtocol, Locale> {
            return .init(manager: cuckoo_manager, name: "locale")
        }
        
        
        
    }

     struct __VerificationProxy_StakingBondMoreConfirmationViewLayoutProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var locale: Cuckoo.VerifyProperty<Locale> {
            return .init(manager: cuckoo_manager, name: "locale", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
    }
}


 class StakingBondMoreConfirmationViewLayoutProtocolStub: StakingBondMoreConfirmationViewLayoutProtocol {
    
    
    
    
     var locale: Locale {
        get {
            return DefaultValueRegistry.defaultValue(for: (Locale).self)
        }
        
        set { }
        
    }
    
    

    

    
}





import Cuckoo
@testable import fearless

import BigInt
import CommonWallet
import Foundation
import SoraFoundation






 class MockStakingMainViewProtocol: StakingMainViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingMainViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingMainViewProtocol
     typealias Verification = __VerificationProxy_StakingMainViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingMainViewProtocol?

     func enableDefaultImplementation(_ stub: StakingMainViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(viewModel: StakingMainViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceive(viewModel: StakingMainViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didRecieveNetworkStakingInfo(viewModel: LocalizableResource<NetworkStakingInfoViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didRecieveNetworkStakingInfo(viewModel: LocalizableResource<NetworkStakingInfoViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRecieveNetworkStakingInfo(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveStakingState(viewModel: StakingViewState)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStakingState(viewModel: StakingViewState)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStakingState(viewModel: viewModel))
        
    }
    
    
    
    
    
     func expandNetworkInfoView(_ isExpanded: Bool)  {
        
    return cuckoo_manager.call(
    """
    expandNetworkInfoView(_: Bool)
    """,
            parameters: (isExpanded),
            escapingParameters: (isExpanded),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.expandNetworkInfoView(isExpanded))
        
    }
    
    
    
    
    
     func didReceive(stakingEstimationViewModel: StakingEstimationViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceive(stakingEstimationViewModel: StakingEstimationViewModel)
    """,
            parameters: (stakingEstimationViewModel),
            escapingParameters: (stakingEstimationViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(stakingEstimationViewModel: stakingEstimationViewModel))
        
    }
    
    
    
    
    
     func didReceive(stories: LocalizableResource<StoriesModel>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(stories: LocalizableResource<StoriesModel>)
    """,
            parameters: (stories),
            escapingParameters: (stories),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(stories: stories))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_StakingMainViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingMainViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingMainViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingMainViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingMainViewModel)> where M1.MatchedType == StakingMainViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainViewProtocol.self, method:
    """
    didReceive(viewModel: StakingMainViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didRecieveNetworkStakingInfo<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<NetworkStakingInfoViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<NetworkStakingInfoViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<NetworkStakingInfoViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainViewProtocol.self, method:
    """
    didRecieveNetworkStakingInfo(viewModel: LocalizableResource<NetworkStakingInfoViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveStakingState<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingViewState)> where M1.MatchedType == StakingViewState {
            let matchers: [Cuckoo.ParameterMatcher<(StakingViewState)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainViewProtocol.self, method:
    """
    didReceiveStakingState(viewModel: StakingViewState)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func expandNetworkInfoView<M1: Cuckoo.Matchable>(_ isExpanded: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool)> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: isExpanded) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainViewProtocol.self, method:
    """
    expandNetworkInfoView(_: Bool)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(stakingEstimationViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingEstimationViewModel)> where M1.MatchedType == StakingEstimationViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingEstimationViewModel)>] = [wrap(matchable: stakingEstimationViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainViewProtocol.self, method:
    """
    didReceive(stakingEstimationViewModel: StakingEstimationViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(stories: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<StoriesModel>)> where M1.MatchedType == LocalizableResource<StoriesModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<StoriesModel>)>] = [wrap(matchable: stories) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainViewProtocol.self, method:
    """
    didReceive(stories: LocalizableResource<StoriesModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingMainViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(StakingMainViewModel), Void> where M1.MatchedType == StakingMainViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(viewModel: StakingMainViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didRecieveNetworkStakingInfo<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<NetworkStakingInfoViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<NetworkStakingInfoViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<NetworkStakingInfoViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didRecieveNetworkStakingInfo(viewModel: LocalizableResource<NetworkStakingInfoViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveStakingState<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(StakingViewState), Void> where M1.MatchedType == StakingViewState {
            let matchers: [Cuckoo.ParameterMatcher<(StakingViewState)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStakingState(viewModel: StakingViewState)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func expandNetworkInfoView<M1: Cuckoo.Matchable>(_ isExpanded: M1) -> Cuckoo.__DoNotUse<(Bool), Void> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: isExpanded) { $0 }]
            return cuckoo_manager.verify(
    """
    expandNetworkInfoView(_: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(stakingEstimationViewModel: M1) -> Cuckoo.__DoNotUse<(StakingEstimationViewModel), Void> where M1.MatchedType == StakingEstimationViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingEstimationViewModel)>] = [wrap(matchable: stakingEstimationViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(stakingEstimationViewModel: StakingEstimationViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(stories: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<StoriesModel>), Void> where M1.MatchedType == LocalizableResource<StoriesModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<StoriesModel>)>] = [wrap(matchable: stories) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(stories: LocalizableResource<StoriesModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingMainViewProtocolStub: StakingMainViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didReceive(viewModel: StakingMainViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didRecieveNetworkStakingInfo(viewModel: LocalizableResource<NetworkStakingInfoViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveStakingState(viewModel: StakingViewState)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func expandNetworkInfoView(_ isExpanded: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(stakingEstimationViewModel: StakingEstimationViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(stories: LocalizableResource<StoriesModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingMainPresenterProtocol: StakingMainPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingMainPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingMainPresenterProtocol
     typealias Verification = __VerificationProxy_StakingMainPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingMainPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingMainPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func performAssetSelection()  {
        
    return cuckoo_manager.call(
    """
    performAssetSelection()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performAssetSelection())
        
    }
    
    
    
    
    
     func performMainAction()  {
        
    return cuckoo_manager.call(
    """
    performMainAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performMainAction())
        
    }
    
    
    
    
    
     func performParachainMainAction(for delegation: ParachainStakingDelegationInfo)  {
        
    return cuckoo_manager.call(
    """
    performParachainMainAction(for: ParachainStakingDelegationInfo)
    """,
            parameters: (delegation),
            escapingParameters: (delegation),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performParachainMainAction(for: delegation))
        
    }
    
    
    
    
    
     func performAccountAction()  {
        
    return cuckoo_manager.call(
    """
    performAccountAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performAccountAction())
        
    }
    
    
    
    
    
     func performManageStakingAction()  {
        
    return cuckoo_manager.call(
    """
    performManageStakingAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performManageStakingAction())
        
    }
    
    
    
    
    
     func performParachainManageStakingAction(for delegation: ParachainStakingDelegationInfo)  {
        
    return cuckoo_manager.call(
    """
    performParachainManageStakingAction(for: ParachainStakingDelegationInfo)
    """,
            parameters: (delegation),
            escapingParameters: (delegation),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performParachainManageStakingAction(for: delegation))
        
    }
    
    
    
    
    
     func performNominationStatusAction()  {
        
    return cuckoo_manager.call(
    """
    performNominationStatusAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performNominationStatusAction())
        
    }
    
    
    
    
    
     func performValidationStatusAction()  {
        
    return cuckoo_manager.call(
    """
    performValidationStatusAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performValidationStatusAction())
        
    }
    
    
    
    
    
     func performDelegationStatusAction()  {
        
    return cuckoo_manager.call(
    """
    performDelegationStatusAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performDelegationStatusAction())
        
    }
    
    
    
    
    
     func performRewardInfoAction()  {
        
    return cuckoo_manager.call(
    """
    performRewardInfoAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performRewardInfoAction())
        
    }
    
    
    
    
    
     func performChangeValidatorsAction()  {
        
    return cuckoo_manager.call(
    """
    performChangeValidatorsAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performChangeValidatorsAction())
        
    }
    
    
    
    
    
     func performSetupValidatorsForBondedAction()  {
        
    return cuckoo_manager.call(
    """
    performSetupValidatorsForBondedAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performSetupValidatorsForBondedAction())
        
    }
    
    
    
    
    
     func performBondMoreAction()  {
        
    return cuckoo_manager.call(
    """
    performBondMoreAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performBondMoreAction())
        
    }
    
    
    
    
    
     func performRedeemAction()  {
        
    return cuckoo_manager.call(
    """
    performRedeemAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performRedeemAction())
        
    }
    
    
    
    
    
     func performAnalyticsAction()  {
        
    return cuckoo_manager.call(
    """
    performAnalyticsAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.performAnalyticsAction())
        
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)  {
        
    return cuckoo_manager.call(
    """
    updateAmount(_: Decimal)
    """,
            parameters: (newValue),
            escapingParameters: (newValue),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.updateAmount(newValue))
        
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)  {
        
    return cuckoo_manager.call(
    """
    selectAmountPercentage(_: Float)
    """,
            parameters: (percentage),
            escapingParameters: (percentage),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectAmountPercentage(percentage))
        
    }
    
    
    
    
    
     func selectStory(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    selectStory(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectStory(at: index))
        
    }
    
    
    
    
    
     func networkInfoViewDidChangeExpansion(isExpanded: Bool)  {
        
    return cuckoo_manager.call(
    """
    networkInfoViewDidChangeExpansion(isExpanded: Bool)
    """,
            parameters: (isExpanded),
            escapingParameters: (isExpanded),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.networkInfoViewDidChangeExpansion(isExpanded: isExpanded))
        
    }
    
    

     struct __StubbingProxy_StakingMainPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performAssetSelection() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performAssetSelection()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performMainAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performMainAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performParachainMainAction<M1: Cuckoo.Matchable>(for delegation: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ParachainStakingDelegationInfo)> where M1.MatchedType == ParachainStakingDelegationInfo {
            let matchers: [Cuckoo.ParameterMatcher<(ParachainStakingDelegationInfo)>] = [wrap(matchable: delegation) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performParachainMainAction(for: ParachainStakingDelegationInfo)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performAccountAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performAccountAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performManageStakingAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performManageStakingAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performParachainManageStakingAction<M1: Cuckoo.Matchable>(for delegation: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ParachainStakingDelegationInfo)> where M1.MatchedType == ParachainStakingDelegationInfo {
            let matchers: [Cuckoo.ParameterMatcher<(ParachainStakingDelegationInfo)>] = [wrap(matchable: delegation) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performParachainManageStakingAction(for: ParachainStakingDelegationInfo)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performNominationStatusAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performNominationStatusAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performValidationStatusAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performValidationStatusAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performDelegationStatusAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performDelegationStatusAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performRewardInfoAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performRewardInfoAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performChangeValidatorsAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performChangeValidatorsAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performSetupValidatorsForBondedAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performSetupValidatorsForBondedAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performBondMoreAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performBondMoreAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performRedeemAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performRedeemAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func performAnalyticsAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    performAnalyticsAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Decimal)> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    updateAmount(_: Decimal)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Float)> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    selectAmountPercentage(_: Float)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectStory<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    selectStory(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func networkInfoViewDidChangeExpansion<M1: Cuckoo.Matchable>(isExpanded: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool)> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: isExpanded) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainPresenterProtocol.self, method:
    """
    networkInfoViewDidChangeExpansion(isExpanded: Bool)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingMainPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performAssetSelection() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performAssetSelection()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performMainAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performMainAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performParachainMainAction<M1: Cuckoo.Matchable>(for delegation: M1) -> Cuckoo.__DoNotUse<(ParachainStakingDelegationInfo), Void> where M1.MatchedType == ParachainStakingDelegationInfo {
            let matchers: [Cuckoo.ParameterMatcher<(ParachainStakingDelegationInfo)>] = [wrap(matchable: delegation) { $0 }]
            return cuckoo_manager.verify(
    """
    performParachainMainAction(for: ParachainStakingDelegationInfo)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performAccountAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performAccountAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performManageStakingAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performManageStakingAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performParachainManageStakingAction<M1: Cuckoo.Matchable>(for delegation: M1) -> Cuckoo.__DoNotUse<(ParachainStakingDelegationInfo), Void> where M1.MatchedType == ParachainStakingDelegationInfo {
            let matchers: [Cuckoo.ParameterMatcher<(ParachainStakingDelegationInfo)>] = [wrap(matchable: delegation) { $0 }]
            return cuckoo_manager.verify(
    """
    performParachainManageStakingAction(for: ParachainStakingDelegationInfo)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performNominationStatusAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performNominationStatusAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performValidationStatusAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performValidationStatusAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performDelegationStatusAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performDelegationStatusAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performRewardInfoAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performRewardInfoAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performChangeValidatorsAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performChangeValidatorsAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performSetupValidatorsForBondedAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performSetupValidatorsForBondedAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performBondMoreAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performBondMoreAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performRedeemAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performRedeemAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func performAnalyticsAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    performAnalyticsAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.__DoNotUse<(Decimal), Void> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return cuckoo_manager.verify(
    """
    updateAmount(_: Decimal)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.__DoNotUse<(Float), Void> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return cuckoo_manager.verify(
    """
    selectAmountPercentage(_: Float)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectStory<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    selectStory(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func networkInfoViewDidChangeExpansion<M1: Cuckoo.Matchable>(isExpanded: M1) -> Cuckoo.__DoNotUse<(Bool), Void> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: isExpanded) { $0 }]
            return cuckoo_manager.verify(
    """
    networkInfoViewDidChangeExpansion(isExpanded: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingMainPresenterProtocolStub: StakingMainPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performAssetSelection()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performMainAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performParachainMainAction(for delegation: ParachainStakingDelegationInfo)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performAccountAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performManageStakingAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performParachainManageStakingAction(for delegation: ParachainStakingDelegationInfo)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performNominationStatusAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performValidationStatusAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performDelegationStatusAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performRewardInfoAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performChangeValidatorsAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performSetupValidatorsForBondedAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performBondMoreAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performRedeemAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func performAnalyticsAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectStory(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func networkInfoViewDidChangeExpansion(isExpanded: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingMainInteractorInputProtocol: StakingMainInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingMainInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingMainInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingMainInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingMainInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingMainInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func saveNetworkInfoViewExpansion(isExpanded: Bool)  {
        
    return cuckoo_manager.call(
    """
    saveNetworkInfoViewExpansion(isExpanded: Bool)
    """,
            parameters: (isExpanded),
            escapingParameters: (isExpanded),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.saveNetworkInfoViewExpansion(isExpanded: isExpanded))
        
    }
    
    
    
    
    
     func save(chainAsset: ChainAsset)  {
        
    return cuckoo_manager.call(
    """
    save(chainAsset: ChainAsset)
    """,
            parameters: (chainAsset),
            escapingParameters: (chainAsset),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.save(chainAsset: chainAsset))
        
    }
    
    
    
    
    
     func updatePrices()  {
        
    return cuckoo_manager.call(
    """
    updatePrices()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.updatePrices())
        
    }
    
    

     struct __StubbingProxy_StakingMainInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func saveNetworkInfoViewExpansion<M1: Cuckoo.Matchable>(isExpanded: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool)> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: isExpanded) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorInputProtocol.self, method:
    """
    saveNetworkInfoViewExpansion(isExpanded: Bool)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func save<M1: Cuckoo.Matchable>(chainAsset: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainAsset)> where M1.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset)>] = [wrap(matchable: chainAsset) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorInputProtocol.self, method:
    """
    save(chainAsset: ChainAsset)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func updatePrices() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorInputProtocol.self, method:
    """
    updatePrices()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingMainInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func saveNetworkInfoViewExpansion<M1: Cuckoo.Matchable>(isExpanded: M1) -> Cuckoo.__DoNotUse<(Bool), Void> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: isExpanded) { $0 }]
            return cuckoo_manager.verify(
    """
    saveNetworkInfoViewExpansion(isExpanded: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func save<M1: Cuckoo.Matchable>(chainAsset: M1) -> Cuckoo.__DoNotUse<(ChainAsset), Void> where M1.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset)>] = [wrap(matchable: chainAsset) { $0 }]
            return cuckoo_manager.verify(
    """
    save(chainAsset: ChainAsset)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func updatePrices() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    updatePrices()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingMainInteractorInputProtocolStub: StakingMainInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func saveNetworkInfoViewExpansion(isExpanded: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func save(chainAsset: ChainAsset)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func updatePrices()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingMainInteractorOutputProtocol: StakingMainInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingMainInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingMainInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingMainInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingMainInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingMainInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(selectedAddress: String)  {
        
    return cuckoo_manager.call(
    """
    didReceive(selectedAddress: String)
    """,
            parameters: (selectedAddress),
            escapingParameters: (selectedAddress),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(selectedAddress: selectedAddress))
        
    }
    
    
    
    
    
     func didReceive(price: PriceData?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(price: PriceData?)
    """,
            parameters: (price),
            escapingParameters: (price),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(price: price))
        
    }
    
    
    
    
    
     func didReceive(priceError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(priceError: Error)
    """,
            parameters: (priceError),
            escapingParameters: (priceError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(priceError: priceError))
        
    }
    
    
    
    
    
     func didReceive(totalReward: TotalRewardItem)  {
        
    return cuckoo_manager.call(
    """
    didReceive(totalReward: TotalRewardItem)
    """,
            parameters: (totalReward),
            escapingParameters: (totalReward),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(totalReward: totalReward))
        
    }
    
    
    
    
    
     func didReceive(totalReward: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(totalReward: Error)
    """,
            parameters: (totalReward),
            escapingParameters: (totalReward),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(totalReward: totalReward))
        
    }
    
    
    
    
    
     func didReceive(accountInfo: AccountInfo?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(accountInfo: AccountInfo?)
    """,
            parameters: (accountInfo),
            escapingParameters: (accountInfo),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(accountInfo: accountInfo))
        
    }
    
    
    
    
    
     func didReceive(balanceError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(balanceError: Error)
    """,
            parameters: (balanceError),
            escapingParameters: (balanceError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(balanceError: balanceError))
        
    }
    
    
    
    
    
     func didReceive(calculator: RewardCalculatorEngineProtocol)  {
        
    return cuckoo_manager.call(
    """
    didReceive(calculator: RewardCalculatorEngineProtocol)
    """,
            parameters: (calculator),
            escapingParameters: (calculator),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(calculator: calculator))
        
    }
    
    
    
    
    
     func didReceive(calculatorError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(calculatorError: Error)
    """,
            parameters: (calculatorError),
            escapingParameters: (calculatorError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(calculatorError: calculatorError))
        
    }
    
    
    
    
    
     func didReceive(stashItem: StashItem?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(stashItem: StashItem?)
    """,
            parameters: (stashItem),
            escapingParameters: (stashItem),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(stashItem: stashItem))
        
    }
    
    
    
    
    
     func didReceive(stashItemError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(stashItemError: Error)
    """,
            parameters: (stashItemError),
            escapingParameters: (stashItemError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(stashItemError: stashItemError))
        
    }
    
    
    
    
    
     func didReceive(ledgerInfo: StakingLedger?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(ledgerInfo: StakingLedger?)
    """,
            parameters: (ledgerInfo),
            escapingParameters: (ledgerInfo),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(ledgerInfo: ledgerInfo))
        
    }
    
    
    
    
    
     func didReceive(ledgerInfoError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(ledgerInfoError: Error)
    """,
            parameters: (ledgerInfoError),
            escapingParameters: (ledgerInfoError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(ledgerInfoError: ledgerInfoError))
        
    }
    
    
    
    
    
     func didReceive(nomination: Nomination?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(nomination: Nomination?)
    """,
            parameters: (nomination),
            escapingParameters: (nomination),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(nomination: nomination))
        
    }
    
    
    
    
    
     func didReceive(nominationError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(nominationError: Error)
    """,
            parameters: (nominationError),
            escapingParameters: (nominationError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(nominationError: nominationError))
        
    }
    
    
    
    
    
     func didReceive(validatorPrefs: ValidatorPrefs?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(validatorPrefs: ValidatorPrefs?)
    """,
            parameters: (validatorPrefs),
            escapingParameters: (validatorPrefs),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(validatorPrefs: validatorPrefs))
        
    }
    
    
    
    
    
     func didReceive(validatorError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(validatorError: Error)
    """,
            parameters: (validatorError),
            escapingParameters: (validatorError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(validatorError: validatorError))
        
    }
    
    
    
    
    
     func didReceive(eraStakersInfo: EraStakersInfo)  {
        
    return cuckoo_manager.call(
    """
    didReceive(eraStakersInfo: EraStakersInfo)
    """,
            parameters: (eraStakersInfo),
            escapingParameters: (eraStakersInfo),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(eraStakersInfo: eraStakersInfo))
        
    }
    
    
    
    
    
     func didReceive(eraStakersInfoError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(eraStakersInfoError: Error)
    """,
            parameters: (eraStakersInfoError),
            escapingParameters: (eraStakersInfoError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(eraStakersInfoError: eraStakersInfoError))
        
    }
    
    
    
    
    
     func didReceive(networkStakingInfo: NetworkStakingInfo)  {
        
    return cuckoo_manager.call(
    """
    didReceive(networkStakingInfo: NetworkStakingInfo)
    """,
            parameters: (networkStakingInfo),
            escapingParameters: (networkStakingInfo),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(networkStakingInfo: networkStakingInfo))
        
    }
    
    
    
    
    
     func didReceive(networkStakingInfoError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(networkStakingInfoError: Error)
    """,
            parameters: (networkStakingInfoError),
            escapingParameters: (networkStakingInfoError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(networkStakingInfoError: networkStakingInfoError))
        
    }
    
    
    
    
    
     func didReceive(payee: RewardDestinationArg?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(payee: RewardDestinationArg?)
    """,
            parameters: (payee),
            escapingParameters: (payee),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(payee: payee))
        
    }
    
    
    
    
    
     func didReceive(payeeError: Error)  {
        
    return cuckoo_manager.call(
    """
    didReceive(payeeError: Error)
    """,
            parameters: (payeeError),
            escapingParameters: (payeeError),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(payeeError: payeeError))
        
    }
    
    
    
    
    
     func didReceive(newChainAsset: ChainAsset)  {
        
    return cuckoo_manager.call(
    """
    didReceive(newChainAsset: ChainAsset)
    """,
            parameters: (newChainAsset),
            escapingParameters: (newChainAsset),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(newChainAsset: newChainAsset))
        
    }
    
    
    
    
    
     func didReceieve(subqueryRewards: Result<[SubqueryRewardItemData]?, Error>, period: AnalyticsPeriod)  {
        
    return cuckoo_manager.call(
    """
    didReceieve(subqueryRewards: Result<[SubqueryRewardItemData]?, Error>, period: AnalyticsPeriod)
    """,
            parameters: (subqueryRewards, period),
            escapingParameters: (subqueryRewards, period),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceieve(subqueryRewards: subqueryRewards, period: period))
        
    }
    
    
    
    
    
     func didReceiveMinNominatorBond(result: Result<BigUInt?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMinNominatorBond(result: Result<BigUInt?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMinNominatorBond(result: result))
        
    }
    
    
    
    
    
     func didReceiveCounterForNominators(result: Result<UInt32?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCounterForNominators(result: Result<UInt32?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCounterForNominators(result: result))
        
    }
    
    
    
    
    
     func didReceiveMaxNominatorsCount(result: Result<UInt32?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMaxNominatorsCount(result: Result<UInt32?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMaxNominatorsCount(result: result))
        
    }
    
    
    
    
    
     func didReceive(eraCountdownResult: Result<EraCountdown, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(eraCountdownResult: Result<EraCountdown, Error>)
    """,
            parameters: (eraCountdownResult),
            escapingParameters: (eraCountdownResult),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(eraCountdownResult: eraCountdownResult))
        
    }
    
    
    
    
    
     func didReceiveMaxNominatorsPerValidator(result: Result<UInt32, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveMaxNominatorsPerValidator(result: Result<UInt32, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveMaxNominatorsPerValidator(result: result))
        
    }
    
    
    
    
    
     func didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveControllerAccount(result: result))
        
    }
    
    
    
    
    
     func networkInfoViewExpansion(isExpanded: Bool)  {
        
    return cuckoo_manager.call(
    """
    networkInfoViewExpansion(isExpanded: Bool)
    """,
            parameters: (isExpanded),
            escapingParameters: (isExpanded),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.networkInfoViewExpansion(isExpanded: isExpanded))
        
    }
    
    
    
    
    
     func didReceive(delegationInfos: [ParachainStakingDelegationInfo]?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(delegationInfos: [ParachainStakingDelegationInfo]?)
    """,
            parameters: (delegationInfos),
            escapingParameters: (delegationInfos),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(delegationInfos: delegationInfos))
        
    }
    
    
    
    
    
     func didReceiveRound(round: ParachainStakingRoundInfo?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveRound(round: ParachainStakingRoundInfo?)
    """,
            parameters: (round),
            escapingParameters: (round),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveRound(round: round))
        
    }
    
    
    
    
    
     func didReceiveCurrentBlock(currentBlock: UInt32?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCurrentBlock(currentBlock: UInt32?)
    """,
            parameters: (currentBlock),
            escapingParameters: (currentBlock),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCurrentBlock(currentBlock: currentBlock))
        
    }
    
    
    
    
    
     func didReceiveScheduledRequests(requests: [AccountAddress: [ParachainStakingScheduledRequest]]?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveScheduledRequests(requests: [AccountAddress: [ParachainStakingScheduledRequest]]?)
    """,
            parameters: (requests),
            escapingParameters: (requests),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveScheduledRequests(requests: requests))
        
    }
    
    
    
    
    
     func didReceiveTopDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveTopDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)
    """,
            parameters: (delegations),
            escapingParameters: (delegations),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveTopDelegations(delegations: delegations))
        
    }
    
    
    
    
    
     func didReceiveBottomDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBottomDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)
    """,
            parameters: (delegations),
            escapingParameters: (delegations),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBottomDelegations(delegations: delegations))
        
    }
    
    

     struct __StubbingProxy_StakingMainInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(selectedAddress: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(String)> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: selectedAddress) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(selectedAddress: String)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(price: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(PriceData?)> where M1.OptionalMatchedType == PriceData {
            let matchers: [Cuckoo.ParameterMatcher<(PriceData?)>] = [wrap(matchable: price) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(price: PriceData?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(priceError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: priceError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(priceError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(totalReward: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(TotalRewardItem)> where M1.MatchedType == TotalRewardItem {
            let matchers: [Cuckoo.ParameterMatcher<(TotalRewardItem)>] = [wrap(matchable: totalReward) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(totalReward: TotalRewardItem)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(totalReward: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: totalReward) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(totalReward: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(accountInfo: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountInfo?)> where M1.OptionalMatchedType == AccountInfo {
            let matchers: [Cuckoo.ParameterMatcher<(AccountInfo?)>] = [wrap(matchable: accountInfo) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(accountInfo: AccountInfo?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(balanceError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: balanceError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(balanceError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(calculator: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(RewardCalculatorEngineProtocol)> where M1.MatchedType == RewardCalculatorEngineProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(RewardCalculatorEngineProtocol)>] = [wrap(matchable: calculator) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(calculator: RewardCalculatorEngineProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(calculatorError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: calculatorError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(calculatorError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(stashItem: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StashItem?)> where M1.OptionalMatchedType == StashItem {
            let matchers: [Cuckoo.ParameterMatcher<(StashItem?)>] = [wrap(matchable: stashItem) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(stashItem: StashItem?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(stashItemError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: stashItemError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(stashItemError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(ledgerInfo: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingLedger?)> where M1.OptionalMatchedType == StakingLedger {
            let matchers: [Cuckoo.ParameterMatcher<(StakingLedger?)>] = [wrap(matchable: ledgerInfo) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(ledgerInfo: StakingLedger?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(ledgerInfoError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: ledgerInfoError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(ledgerInfoError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(nomination: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Nomination?)> where M1.OptionalMatchedType == Nomination {
            let matchers: [Cuckoo.ParameterMatcher<(Nomination?)>] = [wrap(matchable: nomination) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(nomination: Nomination?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(nominationError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: nominationError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(nominationError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(validatorPrefs: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ValidatorPrefs?)> where M1.OptionalMatchedType == ValidatorPrefs {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorPrefs?)>] = [wrap(matchable: validatorPrefs) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(validatorPrefs: ValidatorPrefs?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(validatorError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: validatorError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(validatorError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(eraStakersInfo: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(EraStakersInfo)> where M1.MatchedType == EraStakersInfo {
            let matchers: [Cuckoo.ParameterMatcher<(EraStakersInfo)>] = [wrap(matchable: eraStakersInfo) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(eraStakersInfo: EraStakersInfo)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(eraStakersInfoError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: eraStakersInfoError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(eraStakersInfoError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(networkStakingInfo: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(NetworkStakingInfo)> where M1.MatchedType == NetworkStakingInfo {
            let matchers: [Cuckoo.ParameterMatcher<(NetworkStakingInfo)>] = [wrap(matchable: networkStakingInfo) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(networkStakingInfo: NetworkStakingInfo)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(networkStakingInfoError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: networkStakingInfoError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(networkStakingInfoError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(payee: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(RewardDestinationArg?)> where M1.OptionalMatchedType == RewardDestinationArg {
            let matchers: [Cuckoo.ParameterMatcher<(RewardDestinationArg?)>] = [wrap(matchable: payee) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(payee: RewardDestinationArg?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(payeeError: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Error)> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: payeeError) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(payeeError: Error)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(newChainAsset: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainAsset)> where M1.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset)>] = [wrap(matchable: newChainAsset) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(newChainAsset: ChainAsset)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceieve<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(subqueryRewards: M1, period: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<[SubqueryRewardItemData]?, Error>, AnalyticsPeriod)> where M1.MatchedType == Result<[SubqueryRewardItemData]?, Error>, M2.MatchedType == AnalyticsPeriod {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[SubqueryRewardItemData]?, Error>, AnalyticsPeriod)>] = [wrap(matchable: subqueryRewards) { $0.0 }, wrap(matchable: period) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceieve(subqueryRewards: Result<[SubqueryRewardItemData]?, Error>, period: AnalyticsPeriod)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMinNominatorBond<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<BigUInt?, Error>)> where M1.MatchedType == Result<BigUInt?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveMinNominatorBond(result: Result<BigUInt?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveCounterForNominators<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<UInt32?, Error>)> where M1.MatchedType == Result<UInt32?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<UInt32?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveCounterForNominators(result: Result<UInt32?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMaxNominatorsCount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<UInt32?, Error>)> where M1.MatchedType == Result<UInt32?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<UInt32?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveMaxNominatorsCount(result: Result<UInt32?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(eraCountdownResult: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<EraCountdown, Error>)> where M1.MatchedType == Result<EraCountdown, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<EraCountdown, Error>)>] = [wrap(matchable: eraCountdownResult) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(eraCountdownResult: Result<EraCountdown, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveMaxNominatorsPerValidator<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<UInt32, Error>)> where M1.MatchedType == Result<UInt32, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<UInt32, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveMaxNominatorsPerValidator(result: Result<UInt32, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveControllerAccount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ChainAccountResponse?, Error>)> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func networkInfoViewExpansion<M1: Cuckoo.Matchable>(isExpanded: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Bool)> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: isExpanded) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    networkInfoViewExpansion(isExpanded: Bool)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(delegationInfos: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([ParachainStakingDelegationInfo]?)> where M1.OptionalMatchedType == [ParachainStakingDelegationInfo] {
            let matchers: [Cuckoo.ParameterMatcher<([ParachainStakingDelegationInfo]?)>] = [wrap(matchable: delegationInfos) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceive(delegationInfos: [ParachainStakingDelegationInfo]?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveRound<M1: Cuckoo.OptionalMatchable>(round: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ParachainStakingRoundInfo?)> where M1.OptionalMatchedType == ParachainStakingRoundInfo {
            let matchers: [Cuckoo.ParameterMatcher<(ParachainStakingRoundInfo?)>] = [wrap(matchable: round) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveRound(round: ParachainStakingRoundInfo?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveCurrentBlock<M1: Cuckoo.OptionalMatchable>(currentBlock: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UInt32?)> where M1.OptionalMatchedType == UInt32 {
            let matchers: [Cuckoo.ParameterMatcher<(UInt32?)>] = [wrap(matchable: currentBlock) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveCurrentBlock(currentBlock: UInt32?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveScheduledRequests<M1: Cuckoo.OptionalMatchable>(requests: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([AccountAddress: [ParachainStakingScheduledRequest]]?)> where M1.OptionalMatchedType == [AccountAddress: [ParachainStakingScheduledRequest]] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountAddress: [ParachainStakingScheduledRequest]]?)>] = [wrap(matchable: requests) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveScheduledRequests(requests: [AccountAddress: [ParachainStakingScheduledRequest]]?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveTopDelegations<M1: Cuckoo.OptionalMatchable>(delegations: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([AccountAddress: ParachainStakingDelegations]?)> where M1.OptionalMatchedType == [AccountAddress: ParachainStakingDelegations] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountAddress: ParachainStakingDelegations]?)>] = [wrap(matchable: delegations) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveTopDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBottomDelegations<M1: Cuckoo.OptionalMatchable>(delegations: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([AccountAddress: ParachainStakingDelegations]?)> where M1.OptionalMatchedType == [AccountAddress: ParachainStakingDelegations] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountAddress: ParachainStakingDelegations]?)>] = [wrap(matchable: delegations) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainInteractorOutputProtocol.self, method:
    """
    didReceiveBottomDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingMainInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(selectedAddress: M1) -> Cuckoo.__DoNotUse<(String), Void> where M1.MatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(String)>] = [wrap(matchable: selectedAddress) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(selectedAddress: String)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(price: M1) -> Cuckoo.__DoNotUse<(PriceData?), Void> where M1.OptionalMatchedType == PriceData {
            let matchers: [Cuckoo.ParameterMatcher<(PriceData?)>] = [wrap(matchable: price) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(price: PriceData?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(priceError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: priceError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(priceError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(totalReward: M1) -> Cuckoo.__DoNotUse<(TotalRewardItem), Void> where M1.MatchedType == TotalRewardItem {
            let matchers: [Cuckoo.ParameterMatcher<(TotalRewardItem)>] = [wrap(matchable: totalReward) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(totalReward: TotalRewardItem)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(totalReward: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: totalReward) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(totalReward: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(accountInfo: M1) -> Cuckoo.__DoNotUse<(AccountInfo?), Void> where M1.OptionalMatchedType == AccountInfo {
            let matchers: [Cuckoo.ParameterMatcher<(AccountInfo?)>] = [wrap(matchable: accountInfo) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(accountInfo: AccountInfo?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(balanceError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: balanceError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(balanceError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(calculator: M1) -> Cuckoo.__DoNotUse<(RewardCalculatorEngineProtocol), Void> where M1.MatchedType == RewardCalculatorEngineProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(RewardCalculatorEngineProtocol)>] = [wrap(matchable: calculator) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(calculator: RewardCalculatorEngineProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(calculatorError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: calculatorError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(calculatorError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(stashItem: M1) -> Cuckoo.__DoNotUse<(StashItem?), Void> where M1.OptionalMatchedType == StashItem {
            let matchers: [Cuckoo.ParameterMatcher<(StashItem?)>] = [wrap(matchable: stashItem) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(stashItem: StashItem?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(stashItemError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: stashItemError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(stashItemError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(ledgerInfo: M1) -> Cuckoo.__DoNotUse<(StakingLedger?), Void> where M1.OptionalMatchedType == StakingLedger {
            let matchers: [Cuckoo.ParameterMatcher<(StakingLedger?)>] = [wrap(matchable: ledgerInfo) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(ledgerInfo: StakingLedger?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(ledgerInfoError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: ledgerInfoError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(ledgerInfoError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(nomination: M1) -> Cuckoo.__DoNotUse<(Nomination?), Void> where M1.OptionalMatchedType == Nomination {
            let matchers: [Cuckoo.ParameterMatcher<(Nomination?)>] = [wrap(matchable: nomination) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(nomination: Nomination?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(nominationError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: nominationError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(nominationError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(validatorPrefs: M1) -> Cuckoo.__DoNotUse<(ValidatorPrefs?), Void> where M1.OptionalMatchedType == ValidatorPrefs {
            let matchers: [Cuckoo.ParameterMatcher<(ValidatorPrefs?)>] = [wrap(matchable: validatorPrefs) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(validatorPrefs: ValidatorPrefs?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(validatorError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: validatorError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(validatorError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(eraStakersInfo: M1) -> Cuckoo.__DoNotUse<(EraStakersInfo), Void> where M1.MatchedType == EraStakersInfo {
            let matchers: [Cuckoo.ParameterMatcher<(EraStakersInfo)>] = [wrap(matchable: eraStakersInfo) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(eraStakersInfo: EraStakersInfo)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(eraStakersInfoError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: eraStakersInfoError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(eraStakersInfoError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(networkStakingInfo: M1) -> Cuckoo.__DoNotUse<(NetworkStakingInfo), Void> where M1.MatchedType == NetworkStakingInfo {
            let matchers: [Cuckoo.ParameterMatcher<(NetworkStakingInfo)>] = [wrap(matchable: networkStakingInfo) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(networkStakingInfo: NetworkStakingInfo)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(networkStakingInfoError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: networkStakingInfoError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(networkStakingInfoError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(payee: M1) -> Cuckoo.__DoNotUse<(RewardDestinationArg?), Void> where M1.OptionalMatchedType == RewardDestinationArg {
            let matchers: [Cuckoo.ParameterMatcher<(RewardDestinationArg?)>] = [wrap(matchable: payee) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(payee: RewardDestinationArg?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(payeeError: M1) -> Cuckoo.__DoNotUse<(Error), Void> where M1.MatchedType == Error {
            let matchers: [Cuckoo.ParameterMatcher<(Error)>] = [wrap(matchable: payeeError) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(payeeError: Error)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(newChainAsset: M1) -> Cuckoo.__DoNotUse<(ChainAsset), Void> where M1.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset)>] = [wrap(matchable: newChainAsset) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(newChainAsset: ChainAsset)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceieve<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(subqueryRewards: M1, period: M2) -> Cuckoo.__DoNotUse<(Result<[SubqueryRewardItemData]?, Error>, AnalyticsPeriod), Void> where M1.MatchedType == Result<[SubqueryRewardItemData]?, Error>, M2.MatchedType == AnalyticsPeriod {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[SubqueryRewardItemData]?, Error>, AnalyticsPeriod)>] = [wrap(matchable: subqueryRewards) { $0.0 }, wrap(matchable: period) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didReceieve(subqueryRewards: Result<[SubqueryRewardItemData]?, Error>, period: AnalyticsPeriod)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMinNominatorBond<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<BigUInt?, Error>), Void> where M1.MatchedType == Result<BigUInt?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<BigUInt?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMinNominatorBond(result: Result<BigUInt?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveCounterForNominators<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<UInt32?, Error>), Void> where M1.MatchedType == Result<UInt32?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<UInt32?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCounterForNominators(result: Result<UInt32?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMaxNominatorsCount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<UInt32?, Error>), Void> where M1.MatchedType == Result<UInt32?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<UInt32?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMaxNominatorsCount(result: Result<UInt32?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(eraCountdownResult: M1) -> Cuckoo.__DoNotUse<(Result<EraCountdown, Error>), Void> where M1.MatchedType == Result<EraCountdown, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<EraCountdown, Error>)>] = [wrap(matchable: eraCountdownResult) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(eraCountdownResult: Result<EraCountdown, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveMaxNominatorsPerValidator<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<UInt32, Error>), Void> where M1.MatchedType == Result<UInt32, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<UInt32, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveMaxNominatorsPerValidator(result: Result<UInt32, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveControllerAccount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ChainAccountResponse?, Error>), Void> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func networkInfoViewExpansion<M1: Cuckoo.Matchable>(isExpanded: M1) -> Cuckoo.__DoNotUse<(Bool), Void> where M1.MatchedType == Bool {
            let matchers: [Cuckoo.ParameterMatcher<(Bool)>] = [wrap(matchable: isExpanded) { $0 }]
            return cuckoo_manager.verify(
    """
    networkInfoViewExpansion(isExpanded: Bool)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(delegationInfos: M1) -> Cuckoo.__DoNotUse<([ParachainStakingDelegationInfo]?), Void> where M1.OptionalMatchedType == [ParachainStakingDelegationInfo] {
            let matchers: [Cuckoo.ParameterMatcher<([ParachainStakingDelegationInfo]?)>] = [wrap(matchable: delegationInfos) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(delegationInfos: [ParachainStakingDelegationInfo]?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveRound<M1: Cuckoo.OptionalMatchable>(round: M1) -> Cuckoo.__DoNotUse<(ParachainStakingRoundInfo?), Void> where M1.OptionalMatchedType == ParachainStakingRoundInfo {
            let matchers: [Cuckoo.ParameterMatcher<(ParachainStakingRoundInfo?)>] = [wrap(matchable: round) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveRound(round: ParachainStakingRoundInfo?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveCurrentBlock<M1: Cuckoo.OptionalMatchable>(currentBlock: M1) -> Cuckoo.__DoNotUse<(UInt32?), Void> where M1.OptionalMatchedType == UInt32 {
            let matchers: [Cuckoo.ParameterMatcher<(UInt32?)>] = [wrap(matchable: currentBlock) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCurrentBlock(currentBlock: UInt32?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveScheduledRequests<M1: Cuckoo.OptionalMatchable>(requests: M1) -> Cuckoo.__DoNotUse<([AccountAddress: [ParachainStakingScheduledRequest]]?), Void> where M1.OptionalMatchedType == [AccountAddress: [ParachainStakingScheduledRequest]] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountAddress: [ParachainStakingScheduledRequest]]?)>] = [wrap(matchable: requests) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveScheduledRequests(requests: [AccountAddress: [ParachainStakingScheduledRequest]]?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveTopDelegations<M1: Cuckoo.OptionalMatchable>(delegations: M1) -> Cuckoo.__DoNotUse<([AccountAddress: ParachainStakingDelegations]?), Void> where M1.OptionalMatchedType == [AccountAddress: ParachainStakingDelegations] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountAddress: ParachainStakingDelegations]?)>] = [wrap(matchable: delegations) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveTopDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBottomDelegations<M1: Cuckoo.OptionalMatchable>(delegations: M1) -> Cuckoo.__DoNotUse<([AccountAddress: ParachainStakingDelegations]?), Void> where M1.OptionalMatchedType == [AccountAddress: ParachainStakingDelegations] {
            let matchers: [Cuckoo.ParameterMatcher<([AccountAddress: ParachainStakingDelegations]?)>] = [wrap(matchable: delegations) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBottomDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingMainInteractorOutputProtocolStub: StakingMainInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceive(selectedAddress: String)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(price: PriceData?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(priceError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(totalReward: TotalRewardItem)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(totalReward: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(accountInfo: AccountInfo?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(balanceError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(calculator: RewardCalculatorEngineProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(calculatorError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(stashItem: StashItem?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(stashItemError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(ledgerInfo: StakingLedger?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(ledgerInfoError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(nomination: Nomination?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(nominationError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(validatorPrefs: ValidatorPrefs?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(validatorError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(eraStakersInfo: EraStakersInfo)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(eraStakersInfoError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(networkStakingInfo: NetworkStakingInfo)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(networkStakingInfoError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(payee: RewardDestinationArg?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(payeeError: Error)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(newChainAsset: ChainAsset)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceieve(subqueryRewards: Result<[SubqueryRewardItemData]?, Error>, period: AnalyticsPeriod)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMinNominatorBond(result: Result<BigUInt?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveCounterForNominators(result: Result<UInt32?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMaxNominatorsCount(result: Result<UInt32?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(eraCountdownResult: Result<EraCountdown, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveMaxNominatorsPerValidator(result: Result<UInt32, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveControllerAccount(result: Result<ChainAccountResponse?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func networkInfoViewExpansion(isExpanded: Bool)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(delegationInfos: [ParachainStakingDelegationInfo]?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveRound(round: ParachainStakingRoundInfo?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveCurrentBlock(currentBlock: UInt32?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveScheduledRequests(requests: [AccountAddress: [ParachainStakingScheduledRequest]]?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveTopDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBottomDelegations(delegations: [AccountAddress: ParachainStakingDelegations]?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingMainWireframeProtocol: StakingMainWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingMainWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingMainWireframeProtocol
     typealias Verification = __VerificationProxy_StakingMainWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingMainWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingMainWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showSetupAmount(from view: StakingMainViewProtocol?, amount: Decimal?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showSetupAmount(from: StakingMainViewProtocol?, amount: Decimal?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, amount, chain, asset, selectedAccount),
            escapingParameters: (view, amount, chain, asset, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showSetupAmount(from: view, amount: amount, chain: chain, asset: asset, selectedAccount: selectedAccount))
        
    }
    
    
    
    
    
     func showManageStaking(from view: StakingMainViewProtocol?, items: [StakingManageOption], delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)  {
        
    return cuckoo_manager.call(
    """
    showManageStaking(from: StakingMainViewProtocol?, items: [StakingManageOption], delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """,
            parameters: (view, items, delegate, context),
            escapingParameters: (view, items, delegate, context),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showManageStaking(from: view, items: items, delegate: delegate, context: context))
        
    }
    
    
    
    
    
     func proceedToSelectValidatorsStart(from view: StakingMainViewProtocol?, existingBonding: ExistingBonding, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    proceedToSelectValidatorsStart(from: StakingMainViewProtocol?, existingBonding: ExistingBonding, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, existingBonding, chain, asset, selectedAccount),
            escapingParameters: (view, existingBonding, chain, asset, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceedToSelectValidatorsStart(from: view, existingBonding: existingBonding, chain: chain, asset: asset, selectedAccount: selectedAccount))
        
    }
    
    
    
    
    
     func showStories(from view: ControllerBackedProtocol?, startingFrom index: Int, chainAsset: ChainAsset)  {
        
    return cuckoo_manager.call(
    """
    showStories(from: ControllerBackedProtocol?, startingFrom: Int, chainAsset: ChainAsset)
    """,
            parameters: (view, index, chainAsset),
            escapingParameters: (view, index, chainAsset),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showStories(from: view, startingFrom: index, chainAsset: chainAsset))
        
    }
    
    
    
    
    
     func showRewardDetails(from view: ControllerBackedProtocol?, maxReward: (title: String, amount: Decimal), avgReward: (title: String, amount: Decimal))  {
        
    return cuckoo_manager.call(
    """
    showRewardDetails(from: ControllerBackedProtocol?, maxReward: (title: String, amount: Decimal), avgReward: (title: String, amount: Decimal))
    """,
            parameters: (view, maxReward, avgReward),
            escapingParameters: (view, maxReward, avgReward),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showRewardDetails(from: view, maxReward: maxReward, avgReward: avgReward))
        
    }
    
    
    
    
    
     func showRewardPayoutsForNominator(from view: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showRewardPayoutsForNominator(from: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, stashAddress, chain, asset, selectedAccount),
            escapingParameters: (view, stashAddress, chain, asset, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showRewardPayoutsForNominator(from: view, stashAddress: stashAddress, chain: chain, asset: asset, selectedAccount: selectedAccount))
        
    }
    
    
    
    
    
     func showRewardPayoutsForValidator(from view: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showRewardPayoutsForValidator(from: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, stashAddress, chain, asset, selectedAccount),
            escapingParameters: (view, stashAddress, chain, asset, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showRewardPayoutsForValidator(from: view, stashAddress: stashAddress, chain: chain, asset: asset, selectedAccount: selectedAccount))
        
    }
    
    
    
    
    
     func showStakingBalance(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBalanceFlow)  {
        
    return cuckoo_manager.call(
    """
    showStakingBalance(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBalanceFlow)
    """,
            parameters: (view, chainAsset, wallet, flow),
            escapingParameters: (view, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showStakingBalance(from: view, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func showNominatorValidators(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showNominatorValidators(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """,
            parameters: (view, chainAsset, wallet),
            escapingParameters: (view, chainAsset, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showNominatorValidators(from: view, chainAsset: chainAsset, wallet: wallet))
        
    }
    
    
    
    
    
     func showRewardDestination(from view: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showRewardDestination(from: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, chain, asset, selectedAccount),
            escapingParameters: (view, chain, asset, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showRewardDestination(from: view, chain: chain, asset: asset, selectedAccount: selectedAccount))
        
    }
    
    
    
    
    
     func showControllerAccount(from view: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showControllerAccount(from: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, chain, asset, selectedAccount),
            escapingParameters: (view, chain, asset, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showControllerAccount(from: view, chain: chain, asset: asset, selectedAccount: selectedAccount))
        
    }
    
    
    
    
    
     func showAccountsSelection(from view: StakingMainViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)  {
        
    return cuckoo_manager.call(
    """
    showAccountsSelection(from: StakingMainViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)
    """,
            parameters: (view, moduleOutput),
            escapingParameters: (view, moduleOutput),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showAccountsSelection(from: view, moduleOutput: moduleOutput))
        
    }
    
    
    
    
    
     func showBondMore(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)  {
        
    return cuckoo_manager.call(
    """
    showBondMore(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)
    """,
            parameters: (view, chainAsset, wallet, flow),
            escapingParameters: (view, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showBondMore(from: view, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func showRedeem(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)  {
        
    return cuckoo_manager.call(
    """
    showRedeem(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)
    """,
            parameters: (view, chainAsset, wallet, flow),
            escapingParameters: (view, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showRedeem(from: view, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func showAnalytics(from view: ControllerBackedProtocol?, mode: AnalyticsContainerViewMode, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: AnalyticsRewardsFlow)  {
        
    return cuckoo_manager.call(
    """
    showAnalytics(from: ControllerBackedProtocol?, mode: AnalyticsContainerViewMode, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: AnalyticsRewardsFlow)
    """,
            parameters: (view, mode, chainAsset, wallet, flow),
            escapingParameters: (view, mode, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showAnalytics(from: view, mode: mode, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func showYourValidatorInfo(chainAsset: ChainAsset, selectedAccount: MetaAccountModel, flow: ValidatorInfoFlow, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showYourValidatorInfo(chainAsset: ChainAsset, selectedAccount: MetaAccountModel, flow: ValidatorInfoFlow, from: ControllerBackedProtocol?)
    """,
            parameters: (chainAsset, selectedAccount, flow, view),
            escapingParameters: (chainAsset, selectedAccount, flow, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showYourValidatorInfo(chainAsset: chainAsset, selectedAccount: selectedAccount, flow: flow, from: view))
        
    }
    
    
    
    
    
     func showChainAssetSelection(from view: StakingMainViewProtocol?, selectedChainAsset: ChainAsset?, delegate: AssetSelectionDelegate)  {
        
    return cuckoo_manager.call(
    """
    showChainAssetSelection(from: StakingMainViewProtocol?, selectedChainAsset: ChainAsset?, delegate: AssetSelectionDelegate)
    """,
            parameters: (view, selectedChainAsset, delegate),
            escapingParameters: (view, selectedChainAsset, delegate),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showChainAssetSelection(from: view, selectedChainAsset: selectedChainAsset, delegate: delegate))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingMainWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showSetupAmount<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, amount: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingMainViewProtocol?, Decimal?, ChainModel, AssetModel, MetaAccountModel)> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.OptionalMatchedType == Decimal, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, Decimal?, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: amount) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showSetupAmount(from: StakingMainViewProtocol?, amount: Decimal?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showManageStaking<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable>(from view: M1, items: M2, delegate: M3, context: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingMainViewProtocol?, [StakingManageOption], ModalPickerViewControllerDelegate?, AnyObject?)> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.MatchedType == [StakingManageOption], M3.OptionalMatchedType == ModalPickerViewControllerDelegate, M4.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, [StakingManageOption], ModalPickerViewControllerDelegate?, AnyObject?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: items) { $0.1 }, wrap(matchable: delegate) { $0.2 }, wrap(matchable: context) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showManageStaking(from: StakingMainViewProtocol?, items: [StakingManageOption], delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceedToSelectValidatorsStart<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, existingBonding: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingMainViewProtocol?, ExistingBonding, ChainModel, AssetModel, MetaAccountModel)> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.MatchedType == ExistingBonding, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, ExistingBonding, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: existingBonding) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    proceedToSelectValidatorsStart(from: StakingMainViewProtocol?, existingBonding: ExistingBonding, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showStories<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, startingFrom index: M2, chainAsset: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, Int, ChainAsset)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == Int, M3.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, Int, ChainAsset)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: index) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showStories(from: ControllerBackedProtocol?, startingFrom: Int, chainAsset: ChainAsset)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showRewardDetails<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, maxReward: M2, avgReward: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, (title: String, amount: Decimal), (title: String, amount: Decimal))> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == (title: String, amount: Decimal), M3.MatchedType == (title: String, amount: Decimal) {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, (title: String, amount: Decimal), (title: String, amount: Decimal))>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: maxReward) { $0.1 }, wrap(matchable: avgReward) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showRewardDetails(from: ControllerBackedProtocol?, maxReward: (title: String, amount: Decimal), avgReward: (title: String, amount: Decimal))
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showRewardPayoutsForNominator<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, stashAddress: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, AccountAddress, ChainModel, AssetModel, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == AccountAddress, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, AccountAddress, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: stashAddress) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showRewardPayoutsForNominator(from: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showRewardPayoutsForValidator<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, stashAddress: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, AccountAddress, ChainModel, AssetModel, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == AccountAddress, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, AccountAddress, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: stashAddress) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showRewardPayoutsForValidator(from: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showStakingBalance<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBalanceFlow)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingBalanceFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBalanceFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showStakingBalance(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBalanceFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showNominatorValidators<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showNominatorValidators(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showRewardDestination<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chain: M2, asset: M3, selectedAccount: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainModel, AssetModel, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainModel, M3.MatchedType == AssetModel, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chain) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: selectedAccount) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showRewardDestination(from: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showControllerAccount<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chain: M2, asset: M3, selectedAccount: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainModel, AssetModel, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainModel, M3.MatchedType == AssetModel, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chain) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: selectedAccount) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showControllerAccount(from: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showAccountsSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, moduleOutput: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingMainViewProtocol?, WalletsManagmentModuleOutput)> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.MatchedType == WalletsManagmentModuleOutput {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, WalletsManagmentModuleOutput)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: moduleOutput) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showAccountsSelection(from: StakingMainViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showBondMore<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBondMoreFlow)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingBondMoreFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBondMoreFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showBondMore(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showRedeem<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRedeemConfirmationFlow)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingRedeemConfirmationFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRedeemConfirmationFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showRedeem(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showAnalytics<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, mode: M2, chainAsset: M3, wallet: M4, flow: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, AnalyticsContainerViewMode, ChainAsset, MetaAccountModel, AnalyticsRewardsFlow)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == AnalyticsContainerViewMode, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel, M5.MatchedType == AnalyticsRewardsFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, AnalyticsContainerViewMode, ChainAsset, MetaAccountModel, AnalyticsRewardsFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: mode) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }, wrap(matchable: flow) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showAnalytics(from: ControllerBackedProtocol?, mode: AnalyticsContainerViewMode, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: AnalyticsRewardsFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showYourValidatorInfo<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(chainAsset: M1, selectedAccount: M2, flow: M3, from view: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(ChainAsset, MetaAccountModel, ValidatorInfoFlow, ControllerBackedProtocol?)> where M1.MatchedType == ChainAsset, M2.MatchedType == MetaAccountModel, M3.MatchedType == ValidatorInfoFlow, M4.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset, MetaAccountModel, ValidatorInfoFlow, ControllerBackedProtocol?)>] = [wrap(matchable: chainAsset) { $0.0 }, wrap(matchable: selectedAccount) { $0.1 }, wrap(matchable: flow) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showYourValidatorInfo(chainAsset: ChainAsset, selectedAccount: MetaAccountModel, flow: ValidatorInfoFlow, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showChainAssetSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable>(from view: M1, selectedChainAsset: M2, delegate: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingMainViewProtocol?, ChainAsset?, AssetSelectionDelegate)> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.OptionalMatchedType == ChainAsset, M3.MatchedType == AssetSelectionDelegate {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, ChainAsset?, AssetSelectionDelegate)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: selectedChainAsset) { $0.1 }, wrap(matchable: delegate) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    showChainAssetSelection(from: StakingMainViewProtocol?, selectedChainAsset: ChainAsset?, delegate: AssetSelectionDelegate)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingMainWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showSetupAmount<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, amount: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.__DoNotUse<(StakingMainViewProtocol?, Decimal?, ChainModel, AssetModel, MetaAccountModel), Void> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.OptionalMatchedType == Decimal, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, Decimal?, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: amount) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return cuckoo_manager.verify(
    """
    showSetupAmount(from: StakingMainViewProtocol?, amount: Decimal?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showManageStaking<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable>(from view: M1, items: M2, delegate: M3, context: M4) -> Cuckoo.__DoNotUse<(StakingMainViewProtocol?, [StakingManageOption], ModalPickerViewControllerDelegate?, AnyObject?), Void> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.MatchedType == [StakingManageOption], M3.OptionalMatchedType == ModalPickerViewControllerDelegate, M4.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, [StakingManageOption], ModalPickerViewControllerDelegate?, AnyObject?)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: items) { $0.1 }, wrap(matchable: delegate) { $0.2 }, wrap(matchable: context) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showManageStaking(from: StakingMainViewProtocol?, items: [StakingManageOption], delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceedToSelectValidatorsStart<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, existingBonding: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.__DoNotUse<(StakingMainViewProtocol?, ExistingBonding, ChainModel, AssetModel, MetaAccountModel), Void> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.MatchedType == ExistingBonding, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, ExistingBonding, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: existingBonding) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return cuckoo_manager.verify(
    """
    proceedToSelectValidatorsStart(from: StakingMainViewProtocol?, existingBonding: ExistingBonding, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showStories<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, startingFrom index: M2, chainAsset: M3) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, Int, ChainAsset), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == Int, M3.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, Int, ChainAsset)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: index) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showStories(from: ControllerBackedProtocol?, startingFrom: Int, chainAsset: ChainAsset)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showRewardDetails<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, maxReward: M2, avgReward: M3) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, (title: String, amount: Decimal), (title: String, amount: Decimal)), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == (title: String, amount: Decimal), M3.MatchedType == (title: String, amount: Decimal) {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, (title: String, amount: Decimal), (title: String, amount: Decimal))>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: maxReward) { $0.1 }, wrap(matchable: avgReward) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showRewardDetails(from: ControllerBackedProtocol?, maxReward: (title: String, amount: Decimal), avgReward: (title: String, amount: Decimal))
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showRewardPayoutsForNominator<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, stashAddress: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, AccountAddress, ChainModel, AssetModel, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == AccountAddress, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, AccountAddress, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: stashAddress) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return cuckoo_manager.verify(
    """
    showRewardPayoutsForNominator(from: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showRewardPayoutsForValidator<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, stashAddress: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, AccountAddress, ChainModel, AssetModel, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == AccountAddress, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, AccountAddress, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: stashAddress) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return cuckoo_manager.verify(
    """
    showRewardPayoutsForValidator(from: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showStakingBalance<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBalanceFlow), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingBalanceFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBalanceFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showStakingBalance(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBalanceFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showNominatorValidators<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showNominatorValidators(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showRewardDestination<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chain: M2, asset: M3, selectedAccount: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainModel, AssetModel, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainModel, M3.MatchedType == AssetModel, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chain) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: selectedAccount) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showRewardDestination(from: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showControllerAccount<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chain: M2, asset: M3, selectedAccount: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainModel, AssetModel, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainModel, M3.MatchedType == AssetModel, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chain) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: selectedAccount) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showControllerAccount(from: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showAccountsSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, moduleOutput: M2) -> Cuckoo.__DoNotUse<(StakingMainViewProtocol?, WalletsManagmentModuleOutput), Void> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.MatchedType == WalletsManagmentModuleOutput {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, WalletsManagmentModuleOutput)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: moduleOutput) { $0.1 }]
            return cuckoo_manager.verify(
    """
    showAccountsSelection(from: StakingMainViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showBondMore<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBondMoreFlow), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingBondMoreFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingBondMoreFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showBondMore(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showRedeem<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(from view: M1, chainAsset: M2, wallet: M3, flow: M4) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRedeemConfirmationFlow), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == ChainAsset, M3.MatchedType == MetaAccountModel, M4.MatchedType == StakingRedeemConfirmationFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, ChainAsset, MetaAccountModel, StakingRedeemConfirmationFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: chainAsset) { $0.1 }, wrap(matchable: wallet) { $0.2 }, wrap(matchable: flow) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showRedeem(from: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showAnalytics<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, mode: M2, chainAsset: M3, wallet: M4, flow: M5) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, AnalyticsContainerViewMode, ChainAsset, MetaAccountModel, AnalyticsRewardsFlow), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == AnalyticsContainerViewMode, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel, M5.MatchedType == AnalyticsRewardsFlow {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, AnalyticsContainerViewMode, ChainAsset, MetaAccountModel, AnalyticsRewardsFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: mode) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }, wrap(matchable: flow) { $0.4 }]
            return cuckoo_manager.verify(
    """
    showAnalytics(from: ControllerBackedProtocol?, mode: AnalyticsContainerViewMode, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: AnalyticsRewardsFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showYourValidatorInfo<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.OptionalMatchable>(chainAsset: M1, selectedAccount: M2, flow: M3, from view: M4) -> Cuckoo.__DoNotUse<(ChainAsset, MetaAccountModel, ValidatorInfoFlow, ControllerBackedProtocol?), Void> where M1.MatchedType == ChainAsset, M2.MatchedType == MetaAccountModel, M3.MatchedType == ValidatorInfoFlow, M4.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(ChainAsset, MetaAccountModel, ValidatorInfoFlow, ControllerBackedProtocol?)>] = [wrap(matchable: chainAsset) { $0.0 }, wrap(matchable: selectedAccount) { $0.1 }, wrap(matchable: flow) { $0.2 }, wrap(matchable: view) { $0.3 }]
            return cuckoo_manager.verify(
    """
    showYourValidatorInfo(chainAsset: ChainAsset, selectedAccount: MetaAccountModel, flow: ValidatorInfoFlow, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showChainAssetSelection<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable>(from view: M1, selectedChainAsset: M2, delegate: M3) -> Cuckoo.__DoNotUse<(StakingMainViewProtocol?, ChainAsset?, AssetSelectionDelegate), Void> where M1.OptionalMatchedType == StakingMainViewProtocol, M2.OptionalMatchedType == ChainAsset, M3.MatchedType == AssetSelectionDelegate {
            let matchers: [Cuckoo.ParameterMatcher<(StakingMainViewProtocol?, ChainAsset?, AssetSelectionDelegate)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: selectedChainAsset) { $0.1 }, wrap(matchable: delegate) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showChainAssetSelection(from: StakingMainViewProtocol?, selectedChainAsset: ChainAsset?, delegate: AssetSelectionDelegate)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingMainWireframeProtocolStub: StakingMainWireframeProtocol {
    

    

    
    
    
    
     func showSetupAmount(from view: StakingMainViewProtocol?, amount: Decimal?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showManageStaking(from view: StakingMainViewProtocol?, items: [StakingManageOption], delegate: ModalPickerViewControllerDelegate?, context: AnyObject?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceedToSelectValidatorsStart(from view: StakingMainViewProtocol?, existingBonding: ExistingBonding, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showStories(from view: ControllerBackedProtocol?, startingFrom index: Int, chainAsset: ChainAsset)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showRewardDetails(from view: ControllerBackedProtocol?, maxReward: (title: String, amount: Decimal), avgReward: (title: String, amount: Decimal))   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showRewardPayoutsForNominator(from view: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showRewardPayoutsForValidator(from view: ControllerBackedProtocol?, stashAddress: AccountAddress, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showStakingBalance(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBalanceFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showNominatorValidators(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showRewardDestination(from view: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showControllerAccount(from view: ControllerBackedProtocol?, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showAccountsSelection(from view: StakingMainViewProtocol?, moduleOutput: WalletsManagmentModuleOutput)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showBondMore(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingBondMoreFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showRedeem(from view: ControllerBackedProtocol?, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRedeemConfirmationFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showAnalytics(from view: ControllerBackedProtocol?, mode: AnalyticsContainerViewMode, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: AnalyticsRewardsFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showYourValidatorInfo(chainAsset: ChainAsset, selectedAccount: MetaAccountModel, flow: ValidatorInfoFlow, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showChainAssetSelection(from view: StakingMainViewProtocol?, selectedChainAsset: ChainAsset?, delegate: AssetSelectionDelegate)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingMainModuleOutput: StakingMainModuleOutput, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingMainModuleOutput
    
     typealias Stubbing = __StubbingProxy_StakingMainModuleOutput
     typealias Verification = __VerificationProxy_StakingMainModuleOutput

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingMainModuleOutput?

     func enableDefaultImplementation(_ stub: StakingMainModuleOutput) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didSwitchStakingType(_ type: AssetSelectionStakingType)  {
        
    return cuckoo_manager.call(
    """
    didSwitchStakingType(_: AssetSelectionStakingType)
    """,
            parameters: (type),
            escapingParameters: (type),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSwitchStakingType(type))
        
    }
    
    

     struct __StubbingProxy_StakingMainModuleOutput: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didSwitchStakingType<M1: Cuckoo.Matchable>(_ type: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AssetSelectionStakingType)> where M1.MatchedType == AssetSelectionStakingType {
            let matchers: [Cuckoo.ParameterMatcher<(AssetSelectionStakingType)>] = [wrap(matchable: type) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingMainModuleOutput.self, method:
    """
    didSwitchStakingType(_: AssetSelectionStakingType)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingMainModuleOutput: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didSwitchStakingType<M1: Cuckoo.Matchable>(_ type: M1) -> Cuckoo.__DoNotUse<(AssetSelectionStakingType), Void> where M1.MatchedType == AssetSelectionStakingType {
            let matchers: [Cuckoo.ParameterMatcher<(AssetSelectionStakingType)>] = [wrap(matchable: type) { $0 }]
            return cuckoo_manager.verify(
    """
    didSwitchStakingType(_: AssetSelectionStakingType)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingMainModuleOutputStub: StakingMainModuleOutput {
    

    

    
    
    
    
     func didSwitchStakingType(_ type: AssetSelectionStakingType)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockStakingPayoutConfirmationViewProtocol: StakingPayoutConfirmationViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingPayoutConfirmationViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingPayoutConfirmationViewProtocol
     typealias Verification = __VerificationProxy_StakingPayoutConfirmationViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingPayoutConfirmationViewProtocol?

     func enableDefaultImplementation(_ stub: StakingPayoutConfirmationViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didRecieve(viewModel: [LocalizableResource<PayoutConfirmViewModel>])  {
        
    return cuckoo_manager.call(
    """
    didRecieve(viewModel: [LocalizableResource<PayoutConfirmViewModel>])
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRecieve(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """,
            parameters: (feeViewModel),
            escapingParameters: (feeViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(feeViewModel: feeViewModel))
        
    }
    
    
    
    
    
     func didReceive(singleViewModel: StakingPayoutConfirmationViewModel?)  {
        
    return cuckoo_manager.call(
    """
    didReceive(singleViewModel: StakingPayoutConfirmationViewModel?)
    """,
            parameters: (singleViewModel),
            escapingParameters: (singleViewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(singleViewModel: singleViewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_StakingPayoutConfirmationViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingPayoutConfirmationViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingPayoutConfirmationViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingPayoutConfirmationViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingPayoutConfirmationViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingPayoutConfirmationViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didRecieve<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<([LocalizableResource<PayoutConfirmViewModel>])> where M1.MatchedType == [LocalizableResource<PayoutConfirmViewModel>] {
            let matchers: [Cuckoo.ParameterMatcher<([LocalizableResource<PayoutConfirmViewModel>])>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationViewProtocol.self, method:
    """
    didRecieve(viewModel: [LocalizableResource<PayoutConfirmViewModel>])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(feeViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<BalanceViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: feeViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationViewProtocol.self, method:
    """
    didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.OptionalMatchable>(singleViewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingPayoutConfirmationViewModel?)> where M1.OptionalMatchedType == StakingPayoutConfirmationViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingPayoutConfirmationViewModel?)>] = [wrap(matchable: singleViewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationViewProtocol.self, method:
    """
    didReceive(singleViewModel: StakingPayoutConfirmationViewModel?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingPayoutConfirmationViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didRecieve<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<([LocalizableResource<PayoutConfirmViewModel>]), Void> where M1.MatchedType == [LocalizableResource<PayoutConfirmViewModel>] {
            let matchers: [Cuckoo.ParameterMatcher<([LocalizableResource<PayoutConfirmViewModel>])>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didRecieve(viewModel: [LocalizableResource<PayoutConfirmViewModel>])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(feeViewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<BalanceViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: feeViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.OptionalMatchable>(singleViewModel: M1) -> Cuckoo.__DoNotUse<(StakingPayoutConfirmationViewModel?), Void> where M1.OptionalMatchedType == StakingPayoutConfirmationViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingPayoutConfirmationViewModel?)>] = [wrap(matchable: singleViewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(singleViewModel: StakingPayoutConfirmationViewModel?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingPayoutConfirmationViewProtocolStub: StakingPayoutConfirmationViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didRecieve(viewModel: [LocalizableResource<PayoutConfirmViewModel>])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(feeViewModel: LocalizableResource<BalanceViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(singleViewModel: StakingPayoutConfirmationViewModel?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingPayoutConfirmationPresenterProtocol: StakingPayoutConfirmationPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingPayoutConfirmationPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingPayoutConfirmationPresenterProtocol
     typealias Verification = __VerificationProxy_StakingPayoutConfirmationPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingPayoutConfirmationPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingPayoutConfirmationPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    
    
    
    
     func presentAccountOptions(for viewModel: AccountInfoViewModel)  {
        
    return cuckoo_manager.call(
    """
    presentAccountOptions(for: AccountInfoViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentAccountOptions(for: viewModel))
        
    }
    
    
    
    
    
     func didTapBackButton()  {
        
    return cuckoo_manager.call(
    """
    didTapBackButton()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didTapBackButton())
        
    }
    
    

     struct __StubbingProxy_StakingPayoutConfirmationPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentAccountOptions<M1: Cuckoo.Matchable>(for viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountInfoViewModel)> where M1.MatchedType == AccountInfoViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountInfoViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationPresenterProtocol.self, method:
    """
    presentAccountOptions(for: AccountInfoViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didTapBackButton() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationPresenterProtocol.self, method:
    """
    didTapBackButton()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingPayoutConfirmationPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentAccountOptions<M1: Cuckoo.Matchable>(for viewModel: M1) -> Cuckoo.__DoNotUse<(AccountInfoViewModel), Void> where M1.MatchedType == AccountInfoViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountInfoViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    presentAccountOptions(for: AccountInfoViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didTapBackButton() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didTapBackButton()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingPayoutConfirmationPresenterProtocolStub: StakingPayoutConfirmationPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentAccountOptions(for viewModel: AccountInfoViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didTapBackButton()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingPayoutConfirmationInteractorInputProtocol: StakingPayoutConfirmationInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingPayoutConfirmationInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingPayoutConfirmationInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingPayoutConfirmationInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingPayoutConfirmationInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingPayoutConfirmationInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?)
    """,
            parameters: (builderClosure),
            escapingParameters: (builderClosure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(builderClosure: builderClosure))
        
    }
    
    
    
    
    
     func submitPayout(builderClosure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    submitPayout(builderClosure: ExtrinsicBuilderClosure?)
    """,
            parameters: (builderClosure),
            escapingParameters: (builderClosure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.submitPayout(builderClosure: builderClosure))
        
    }
    
    

     struct __StubbingProxy_StakingPayoutConfirmationInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationInteractorInputProtocol.self, method:
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func submitPayout<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationInteractorInputProtocol.self, method:
    """
    submitPayout(builderClosure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingPayoutConfirmationInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return cuckoo_manager.verify(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func submitPayout<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return cuckoo_manager.verify(
    """
    submitPayout(builderClosure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingPayoutConfirmationInteractorInputProtocolStub: StakingPayoutConfirmationInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func submitPayout(builderClosure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingPayoutConfirmationInteractorOutputProtocol: StakingPayoutConfirmationInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingPayoutConfirmationInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingPayoutConfirmationInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingPayoutConfirmationInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingPayoutConfirmationInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingPayoutConfirmationInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingPayoutConfirmationInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingPayoutConfirmationInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingPayoutConfirmationInteractorOutputProtocolStub: StakingPayoutConfirmationInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingPayoutConfirmationWireframeProtocol: StakingPayoutConfirmationWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingPayoutConfirmationWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingPayoutConfirmationWireframeProtocol
     typealias Verification = __VerificationProxy_StakingPayoutConfirmationWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingPayoutConfirmationWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingPayoutConfirmationWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(from view: StakingPayoutConfirmationViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    complete(from: StakingPayoutConfirmationViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(from: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingPayoutConfirmationWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingPayoutConfirmationViewProtocol?)> where M1.OptionalMatchedType == StakingPayoutConfirmationViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingPayoutConfirmationViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationWireframeProtocol.self, method:
    """
    complete(from: StakingPayoutConfirmationViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutConfirmationWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingPayoutConfirmationWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(StakingPayoutConfirmationViewProtocol?), Void> where M1.OptionalMatchedType == StakingPayoutConfirmationViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingPayoutConfirmationViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    complete(from: StakingPayoutConfirmationViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingPayoutConfirmationWireframeProtocolStub: StakingPayoutConfirmationWireframeProtocol {
    

    

    
    
    
    
     func complete(from view: StakingPayoutConfirmationViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import Foundation
import SoraFoundation






 class MockStakingRebondConfirmationViewProtocol: StakingRebondConfirmationViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondConfirmationViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondConfirmationViewProtocol
     typealias Verification = __VerificationProxy_StakingRebondConfirmationViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondConfirmationViewProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondConfirmationViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingRebondConfirmationViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveConfirmation(viewModel: StakingRebondConfirmationViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveConfirmation(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAsset(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_StakingRebondConfirmationViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRebondConfirmationViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRebondConfirmationViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingRebondConfirmationViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRebondConfirmationViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRebondConfirmationViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRebondConfirmationViewModel)> where M1.MatchedType == StakingRebondConfirmationViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRebondConfirmationViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationViewProtocol.self, method:
    """
    didReceiveConfirmation(viewModel: StakingRebondConfirmationViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<AssetBalanceViewModelProtocol>)> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationViewProtocol.self, method:
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<BalanceViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationViewProtocol.self, method:
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondConfirmationViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(StakingRebondConfirmationViewModel), Void> where M1.MatchedType == StakingRebondConfirmationViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRebondConfirmationViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveConfirmation(viewModel: StakingRebondConfirmationViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<AssetBalanceViewModelProtocol>), Void> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<BalanceViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondConfirmationViewProtocolStub: StakingRebondConfirmationViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingRebondConfirmationViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRebondConfirmationPresenterProtocol: StakingRebondConfirmationPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondConfirmationPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondConfirmationPresenterProtocol
     typealias Verification = __VerificationProxy_StakingRebondConfirmationPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondConfirmationPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondConfirmationPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func confirm()  {
        
    return cuckoo_manager.call(
    """
    confirm()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm())
        
    }
    
    
    
    
    
     func selectAccount()  {
        
    return cuckoo_manager.call(
    """
    selectAccount()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectAccount())
        
    }
    
    

     struct __StubbingProxy_StakingRebondConfirmationPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func confirm() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationPresenterProtocol.self, method:
    """
    confirm()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectAccount() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationPresenterProtocol.self, method:
    """
    selectAccount()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondConfirmationPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func confirm() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    confirm()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectAccount() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectAccount()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondConfirmationPresenterProtocolStub: StakingRebondConfirmationPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func confirm()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectAccount()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRebondConfirmationInteractorInputProtocol: StakingRebondConfirmationInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondConfirmationInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondConfirmationInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingRebondConfirmationInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondConfirmationInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondConfirmationInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """,
            parameters: (builderClosure, reuseIdentifier),
            escapingParameters: (builderClosure, reuseIdentifier),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(builderClosure: builderClosure, reuseIdentifier: reuseIdentifier))
        
    }
    
    
    
    
    
     func submit(builderClosure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """,
            parameters: (builderClosure),
            escapingParameters: (builderClosure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.submit(builderClosure: builderClosure))
        
    }
    
    

     struct __StubbingProxy_StakingRebondConfirmationInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(builderClosure: M1, reuseIdentifier: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?, String?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure, M2.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?, String?)>] = [wrap(matchable: builderClosure) { $0.0 }, wrap(matchable: reuseIdentifier) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationInteractorInputProtocol.self, method:
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func submit<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationInteractorInputProtocol.self, method:
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondConfirmationInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(builderClosure: M1, reuseIdentifier: M2) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?, String?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure, M2.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?, String?)>] = [wrap(matchable: builderClosure) { $0.0 }, wrap(matchable: reuseIdentifier) { $0.1 }]
            return cuckoo_manager.verify(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func submit<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return cuckoo_manager.verify(
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondConfirmationInteractorInputProtocolStub: StakingRebondConfirmationInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func submit(builderClosure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRebondConfirmationInteractorOutputProtocol: StakingRebondConfirmationInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondConfirmationInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondConfirmationInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingRebondConfirmationInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondConfirmationInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondConfirmationInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingRebondConfirmationInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondConfirmationInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondConfirmationInteractorOutputProtocolStub: StakingRebondConfirmationInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRebondConfirmationWireframeProtocol: StakingRebondConfirmationWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondConfirmationWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondConfirmationWireframeProtocol
     typealias Verification = __VerificationProxy_StakingRebondConfirmationWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondConfirmationWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondConfirmationWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(from view: StakingRebondConfirmationViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    complete(from: StakingRebondConfirmationViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(from: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingRebondConfirmationWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRebondConfirmationViewProtocol?)> where M1.OptionalMatchedType == StakingRebondConfirmationViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRebondConfirmationViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationWireframeProtocol.self, method:
    """
    complete(from: StakingRebondConfirmationViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondConfirmationWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondConfirmationWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(StakingRebondConfirmationViewProtocol?), Void> where M1.OptionalMatchedType == StakingRebondConfirmationViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRebondConfirmationViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    complete(from: StakingRebondConfirmationViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondConfirmationWireframeProtocolStub: StakingRebondConfirmationWireframeProtocol {
    

    

    
    
    
    
     func complete(from view: StakingRebondConfirmationViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import CommonWallet
import Foundation
import SoraFoundation






 class MockStakingRebondSetupViewProtocol: StakingRebondSetupViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondSetupViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondSetupViewProtocol
     typealias Verification = __VerificationProxy_StakingRebondSetupViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondSetupViewProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondSetupViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAsset(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveInput(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_StakingRebondSetupViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRebondSetupViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRebondSetupViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingRebondSetupViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<AssetBalanceViewModelProtocol>)> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupViewProtocol.self, method:
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<BalanceViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupViewProtocol.self, method:
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<IAmountInputViewModel>)> where M1.MatchedType == LocalizableResource<IAmountInputViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<IAmountInputViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupViewProtocol.self, method:
    """
    didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondSetupViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<AssetBalanceViewModelProtocol>), Void> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<BalanceViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<IAmountInputViewModel>), Void> where M1.MatchedType == LocalizableResource<IAmountInputViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<IAmountInputViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondSetupViewProtocolStub: StakingRebondSetupViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRebondSetupPresenterProtocol: StakingRebondSetupPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondSetupPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondSetupPresenterProtocol
     typealias Verification = __VerificationProxy_StakingRebondSetupPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondSetupPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondSetupPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)  {
        
    return cuckoo_manager.call(
    """
    selectAmountPercentage(_: Float)
    """,
            parameters: (percentage),
            escapingParameters: (percentage),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectAmountPercentage(percentage))
        
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)  {
        
    return cuckoo_manager.call(
    """
    updateAmount(_: Decimal)
    """,
            parameters: (newValue),
            escapingParameters: (newValue),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.updateAmount(newValue))
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    
    
    
    
     func close()  {
        
    return cuckoo_manager.call(
    """
    close()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close())
        
    }
    
    

     struct __StubbingProxy_StakingRebondSetupPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Float)> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupPresenterProtocol.self, method:
    """
    selectAmountPercentage(_: Float)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Decimal)> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupPresenterProtocol.self, method:
    """
    updateAmount(_: Decimal)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func close() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupPresenterProtocol.self, method:
    """
    close()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondSetupPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.__DoNotUse<(Float), Void> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return cuckoo_manager.verify(
    """
    selectAmountPercentage(_: Float)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.__DoNotUse<(Decimal), Void> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return cuckoo_manager.verify(
    """
    updateAmount(_: Decimal)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func close() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    close()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondSetupPresenterProtocolStub: StakingRebondSetupPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func close()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRebondSetupInteractorInputProtocol: StakingRebondSetupInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondSetupInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondSetupInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingRebondSetupInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondSetupInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondSetupInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee()  {
        
    return cuckoo_manager.call(
    """
    estimateFee()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee())
        
    }
    
    

     struct __StubbingProxy_StakingRebondSetupInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupInteractorInputProtocol.self, method:
    """
    estimateFee()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondSetupInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    estimateFee()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondSetupInteractorInputProtocolStub: StakingRebondSetupInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRebondSetupInteractorOutputProtocol: StakingRebondSetupInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondSetupInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondSetupInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingRebondSetupInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondSetupInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondSetupInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceiveStakingLedger(result: Result<StakingLedger?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStakingLedger(result: Result<StakingLedger?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStakingLedger(result: result))
        
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(result: result))
        
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    
    
    
    
     func didReceiveActiveEra(result: Result<ActiveEraInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveActiveEra(result: Result<ActiveEraInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveActiveEra(result: result))
        
    }
    
    
    
    
    
     func didReceiveController(result: Result<ChainAccountResponse?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveController(result: Result<ChainAccountResponse?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveController(result: result))
        
    }
    
    
    
    
    
     func didReceiveStashItem(result: Result<StashItem?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStashItem(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingRebondSetupInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceiveStakingLedger<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<StakingLedger?, Error>)> where M1.MatchedType == Result<StakingLedger?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StakingLedger?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupInteractorOutputProtocol.self, method:
    """
    didReceiveStakingLedger(result: Result<StakingLedger?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RuntimeDispatchInfo, Error>)> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupInteractorOutputProtocol.self, method:
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveActiveEra<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ActiveEraInfo?, Error>)> where M1.MatchedType == Result<ActiveEraInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ActiveEraInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupInteractorOutputProtocol.self, method:
    """
    didReceiveActiveEra(result: Result<ActiveEraInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveController<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ChainAccountResponse?, Error>)> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupInteractorOutputProtocol.self, method:
    """
    didReceiveController(result: Result<ChainAccountResponse?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveStashItem<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<StashItem?, Error>)> where M1.MatchedType == Result<StashItem?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StashItem?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupInteractorOutputProtocol.self, method:
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>)> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondSetupInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceiveStakingLedger<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<StakingLedger?, Error>), Void> where M1.MatchedType == Result<StakingLedger?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StakingLedger?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStakingLedger(result: Result<StakingLedger?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RuntimeDispatchInfo, Error>), Void> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveActiveEra<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ActiveEraInfo?, Error>), Void> where M1.MatchedType == Result<ActiveEraInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ActiveEraInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveActiveEra(result: Result<ActiveEraInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveController<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ChainAccountResponse?, Error>), Void> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveController(result: Result<ChainAccountResponse?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveStashItem<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<StashItem?, Error>), Void> where M1.MatchedType == Result<StashItem?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StashItem?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>), Void> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondSetupInteractorOutputProtocolStub: StakingRebondSetupInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceiveStakingLedger(result: Result<StakingLedger?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveActiveEra(result: Result<ActiveEraInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveController(result: Result<ChainAccountResponse?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveStashItem(result: Result<StashItem?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRebondSetupWireframeProtocol: StakingRebondSetupWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRebondSetupWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRebondSetupWireframeProtocol
     typealias Verification = __VerificationProxy_StakingRebondSetupWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRebondSetupWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingRebondSetupWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func proceed(view: StakingRebondSetupViewProtocol?, amount: Decimal, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)  {
        
    return cuckoo_manager.call(
    """
    proceed(view: StakingRebondSetupViewProtocol?, amount: Decimal, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)
    """,
            parameters: (view, amount, chainAsset, wallet, flow),
            escapingParameters: (view, amount, chainAsset, wallet, flow),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(view: view, amount: amount, chainAsset: chainAsset, wallet: wallet, flow: flow))
        
    }
    
    
    
    
    
     func close(view: StakingRebondSetupViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(view: StakingRebondSetupViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingRebondSetupWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(view: M1, amount: M2, chainAsset: M3, wallet: M4, flow: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRebondSetupViewProtocol?, Decimal, ChainAsset, MetaAccountModel, StakingRebondConfirmationFlow)> where M1.OptionalMatchedType == StakingRebondSetupViewProtocol, M2.MatchedType == Decimal, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel, M5.MatchedType == StakingRebondConfirmationFlow {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRebondSetupViewProtocol?, Decimal, ChainAsset, MetaAccountModel, StakingRebondConfirmationFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: amount) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }, wrap(matchable: flow) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupWireframeProtocol.self, method:
    """
    proceed(view: StakingRebondSetupViewProtocol?, amount: Decimal, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRebondSetupViewProtocol?)> where M1.OptionalMatchedType == StakingRebondSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRebondSetupViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupWireframeProtocol.self, method:
    """
    close(view: StakingRebondSetupViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRebondSetupWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRebondSetupWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(view: M1, amount: M2, chainAsset: M3, wallet: M4, flow: M5) -> Cuckoo.__DoNotUse<(StakingRebondSetupViewProtocol?, Decimal, ChainAsset, MetaAccountModel, StakingRebondConfirmationFlow), Void> where M1.OptionalMatchedType == StakingRebondSetupViewProtocol, M2.MatchedType == Decimal, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel, M5.MatchedType == StakingRebondConfirmationFlow {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRebondSetupViewProtocol?, Decimal, ChainAsset, MetaAccountModel, StakingRebondConfirmationFlow)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: amount) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }, wrap(matchable: flow) { $0.4 }]
            return cuckoo_manager.verify(
    """
    proceed(view: StakingRebondSetupViewProtocol?, amount: Decimal, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(StakingRebondSetupViewProtocol?), Void> where M1.OptionalMatchedType == StakingRebondSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRebondSetupViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(view: StakingRebondSetupViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRebondSetupWireframeProtocolStub: StakingRebondSetupWireframeProtocol {
    

    

    
    
    
    
     func proceed(view: StakingRebondSetupViewProtocol?, amount: Decimal, chainAsset: ChainAsset, wallet: MetaAccountModel, flow: StakingRebondConfirmationFlow)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func close(view: StakingRebondSetupViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import Foundation
import SoraFoundation






 class MockStakingRedeemViewProtocol: StakingRedeemViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRedeemViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRedeemViewProtocol
     typealias Verification = __VerificationProxy_StakingRedeemViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRedeemViewProtocol?

     func enableDefaultImplementation(_ stub: StakingRedeemViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingRedeemViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveConfirmation(viewModel: StakingRedeemViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveConfirmation(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAsset(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveHints(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_StakingRedeemViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRedeemViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRedeemViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingRedeemViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRedeemViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRedeemViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRedeemViewModel)> where M1.MatchedType == StakingRedeemViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRedeemViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemViewProtocol.self, method:
    """
    didReceiveConfirmation(viewModel: StakingRedeemViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<AssetBalanceViewModelProtocol>)> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemViewProtocol.self, method:
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<BalanceViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemViewProtocol.self, method:
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveHints<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<[TitleIconViewModel]>)> where M1.MatchedType == LocalizableResource<[TitleIconViewModel]> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<[TitleIconViewModel]>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemViewProtocol.self, method:
    """
    didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRedeemViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(StakingRedeemViewModel), Void> where M1.MatchedType == StakingRedeemViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRedeemViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveConfirmation(viewModel: StakingRedeemViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<AssetBalanceViewModelProtocol>), Void> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<BalanceViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveHints<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<[TitleIconViewModel]>), Void> where M1.MatchedType == LocalizableResource<[TitleIconViewModel]> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<[TitleIconViewModel]>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRedeemViewProtocolStub: StakingRedeemViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingRedeemViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRedeemPresenterProtocol: StakingRedeemPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRedeemPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRedeemPresenterProtocol
     typealias Verification = __VerificationProxy_StakingRedeemPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRedeemPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingRedeemPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func confirm()  {
        
    return cuckoo_manager.call(
    """
    confirm()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm())
        
    }
    
    
    
    
    
     func selectAccount()  {
        
    return cuckoo_manager.call(
    """
    selectAccount()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectAccount())
        
    }
    
    

     struct __StubbingProxy_StakingRedeemPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func confirm() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemPresenterProtocol.self, method:
    """
    confirm()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectAccount() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemPresenterProtocol.self, method:
    """
    selectAccount()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRedeemPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func confirm() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    confirm()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectAccount() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectAccount()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRedeemPresenterProtocolStub: StakingRedeemPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func confirm()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectAccount()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRedeemInteractorInputProtocol: StakingRedeemInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRedeemInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRedeemInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingRedeemInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRedeemInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingRedeemInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """,
            parameters: (builderClosure, reuseIdentifier),
            escapingParameters: (builderClosure, reuseIdentifier),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(builderClosure: builderClosure, reuseIdentifier: reuseIdentifier))
        
    }
    
    
    
    
    
     func submit(builderClosure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """,
            parameters: (builderClosure),
            escapingParameters: (builderClosure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.submit(builderClosure: builderClosure))
        
    }
    
    

     struct __StubbingProxy_StakingRedeemInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(builderClosure: M1, reuseIdentifier: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?, String?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure, M2.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?, String?)>] = [wrap(matchable: builderClosure) { $0.0 }, wrap(matchable: reuseIdentifier) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemInteractorInputProtocol.self, method:
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func submit<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemInteractorInputProtocol.self, method:
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRedeemInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(builderClosure: M1, reuseIdentifier: M2) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?, String?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure, M2.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?, String?)>] = [wrap(matchable: builderClosure) { $0.0 }, wrap(matchable: reuseIdentifier) { $0.1 }]
            return cuckoo_manager.verify(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func submit<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return cuckoo_manager.verify(
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRedeemInteractorInputProtocolStub: StakingRedeemInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func submit(builderClosure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRedeemInteractorOutputProtocol: StakingRedeemInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRedeemInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRedeemInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingRedeemInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRedeemInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingRedeemInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingRedeemInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRedeemInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRedeemInteractorOutputProtocolStub: StakingRedeemInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRedeemWireframeProtocol: StakingRedeemWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRedeemWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRedeemWireframeProtocol
     typealias Verification = __VerificationProxy_StakingRedeemWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRedeemWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingRedeemWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(from view: StakingRedeemViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    complete(from: StakingRedeemViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(from: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingRedeemWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRedeemViewProtocol?)> where M1.OptionalMatchedType == StakingRedeemViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRedeemViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemWireframeProtocol.self, method:
    """
    complete(from: StakingRedeemViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRedeemWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRedeemWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(StakingRedeemViewProtocol?), Void> where M1.OptionalMatchedType == StakingRedeemViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRedeemViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    complete(from: StakingRedeemViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRedeemWireframeProtocolStub: StakingRedeemWireframeProtocol {
    

    

    
    
    
    
     func complete(from view: StakingRedeemViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockStakingRewardDestConfirmViewProtocol: StakingRewardDestConfirmViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestConfirmViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestConfirmViewProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestConfirmViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestConfirmViewProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestConfirmViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingRewardDestConfirmViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveConfirmation(viewModel: StakingRewardDestConfirmViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveConfirmation(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestConfirmViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardDestConfirmViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardDestConfirmViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingRewardDestConfirmViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardDestConfirmViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardDestConfirmViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRewardDestConfirmViewModel)> where M1.MatchedType == StakingRewardDestConfirmViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRewardDestConfirmViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmViewProtocol.self, method:
    """
    didReceiveConfirmation(viewModel: StakingRewardDestConfirmViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<BalanceViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmViewProtocol.self, method:
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestConfirmViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(StakingRewardDestConfirmViewModel), Void> where M1.MatchedType == StakingRewardDestConfirmViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRewardDestConfirmViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveConfirmation(viewModel: StakingRewardDestConfirmViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<BalanceViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestConfirmViewProtocolStub: StakingRewardDestConfirmViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingRewardDestConfirmViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDestConfirmPresenterProtocol: StakingRewardDestConfirmPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestConfirmPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestConfirmPresenterProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestConfirmPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestConfirmPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestConfirmPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func confirm()  {
        
    return cuckoo_manager.call(
    """
    confirm()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm())
        
    }
    
    
    
    
    
     func presentSenderAccountOptions()  {
        
    return cuckoo_manager.call(
    """
    presentSenderAccountOptions()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentSenderAccountOptions())
        
    }
    
    
    
    
    
     func presentPayoutAccountOptions()  {
        
    return cuckoo_manager.call(
    """
    presentPayoutAccountOptions()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentPayoutAccountOptions())
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestConfirmPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func confirm() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmPresenterProtocol.self, method:
    """
    confirm()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentSenderAccountOptions() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmPresenterProtocol.self, method:
    """
    presentSenderAccountOptions()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentPayoutAccountOptions() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmPresenterProtocol.self, method:
    """
    presentPayoutAccountOptions()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestConfirmPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func confirm() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    confirm()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentSenderAccountOptions() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentSenderAccountOptions()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentPayoutAccountOptions() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    presentPayoutAccountOptions()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestConfirmPresenterProtocolStub: StakingRewardDestConfirmPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func confirm()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentSenderAccountOptions()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentPayoutAccountOptions()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDestConfirmInteractorInputProtocol: StakingRewardDestConfirmInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestConfirmInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestConfirmInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestConfirmInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestConfirmInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestConfirmInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(for rewardDestination: RewardDestination<AccountAddress>, stashItem: StashItem)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(for: RewardDestination<AccountAddress>, stashItem: StashItem)
    """,
            parameters: (rewardDestination, stashItem),
            escapingParameters: (rewardDestination, stashItem),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(for: rewardDestination, stashItem: stashItem))
        
    }
    
    
    
    
    
     func submit(rewardDestination: RewardDestination<AccountAddress>, for stashItem: StashItem)  {
        
    return cuckoo_manager.call(
    """
    submit(rewardDestination: RewardDestination<AccountAddress>, for: StashItem)
    """,
            parameters: (rewardDestination, stashItem),
            escapingParameters: (rewardDestination, stashItem),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.submit(rewardDestination: rewardDestination, for: stashItem))
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestConfirmInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(for rewardDestination: M1, stashItem: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(RewardDestination<AccountAddress>, StashItem)> where M1.MatchedType == RewardDestination<AccountAddress>, M2.MatchedType == StashItem {
            let matchers: [Cuckoo.ParameterMatcher<(RewardDestination<AccountAddress>, StashItem)>] = [wrap(matchable: rewardDestination) { $0.0 }, wrap(matchable: stashItem) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmInteractorInputProtocol.self, method:
    """
    estimateFee(for: RewardDestination<AccountAddress>, stashItem: StashItem)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func submit<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(rewardDestination: M1, for stashItem: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(RewardDestination<AccountAddress>, StashItem)> where M1.MatchedType == RewardDestination<AccountAddress>, M2.MatchedType == StashItem {
            let matchers: [Cuckoo.ParameterMatcher<(RewardDestination<AccountAddress>, StashItem)>] = [wrap(matchable: rewardDestination) { $0.0 }, wrap(matchable: stashItem) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmInteractorInputProtocol.self, method:
    """
    submit(rewardDestination: RewardDestination<AccountAddress>, for: StashItem)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestConfirmInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(for rewardDestination: M1, stashItem: M2) -> Cuckoo.__DoNotUse<(RewardDestination<AccountAddress>, StashItem), Void> where M1.MatchedType == RewardDestination<AccountAddress>, M2.MatchedType == StashItem {
            let matchers: [Cuckoo.ParameterMatcher<(RewardDestination<AccountAddress>, StashItem)>] = [wrap(matchable: rewardDestination) { $0.0 }, wrap(matchable: stashItem) { $0.1 }]
            return cuckoo_manager.verify(
    """
    estimateFee(for: RewardDestination<AccountAddress>, stashItem: StashItem)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func submit<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(rewardDestination: M1, for stashItem: M2) -> Cuckoo.__DoNotUse<(RewardDestination<AccountAddress>, StashItem), Void> where M1.MatchedType == RewardDestination<AccountAddress>, M2.MatchedType == StashItem {
            let matchers: [Cuckoo.ParameterMatcher<(RewardDestination<AccountAddress>, StashItem)>] = [wrap(matchable: rewardDestination) { $0.0 }, wrap(matchable: stashItem) { $0.1 }]
            return cuckoo_manager.verify(
    """
    submit(rewardDestination: RewardDestination<AccountAddress>, for: StashItem)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestConfirmInteractorInputProtocolStub: StakingRewardDestConfirmInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(for rewardDestination: RewardDestination<AccountAddress>, stashItem: StashItem)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func submit(rewardDestination: RewardDestination<AccountAddress>, for stashItem: StashItem)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDestConfirmInteractorOutputProtocol: StakingRewardDestConfirmInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestConfirmInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestConfirmInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestConfirmInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestConfirmInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestConfirmInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(result: result))
        
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    
    
    
    
     func didReceiveStashItem(result: Result<StashItem?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStashItem(result: result))
        
    }
    
    
    
    
    
     func didReceiveController(result: Result<ChainAccountResponse?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveController(result: Result<ChainAccountResponse?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveController(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result))
        
    }
    
    
    
    
    
     func didSubmitRewardDest(result: Result<String, Error>)  {
        
    return cuckoo_manager.call(
    """
    didSubmitRewardDest(result: Result<String, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didSubmitRewardDest(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestConfirmInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RuntimeDispatchInfo, Error>)> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveStashItem<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<StashItem?, Error>)> where M1.MatchedType == Result<StashItem?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StashItem?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveController<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ChainAccountResponse?, Error>)> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveController(result: Result<ChainAccountResponse?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>)> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didSubmitRewardDest<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<String, Error>)> where M1.MatchedType == Result<String, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<String, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmInteractorOutputProtocol.self, method:
    """
    didSubmitRewardDest(result: Result<String, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestConfirmInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RuntimeDispatchInfo, Error>), Void> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveStashItem<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<StashItem?, Error>), Void> where M1.MatchedType == Result<StashItem?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StashItem?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveController<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ChainAccountResponse?, Error>), Void> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveController(result: Result<ChainAccountResponse?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>), Void> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didSubmitRewardDest<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<String, Error>), Void> where M1.MatchedType == Result<String, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<String, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didSubmitRewardDest(result: Result<String, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestConfirmInteractorOutputProtocolStub: StakingRewardDestConfirmInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveStashItem(result: Result<StashItem?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveController(result: Result<ChainAccountResponse?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didSubmitRewardDest(result: Result<String, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDestConfirmWireframeProtocol: StakingRewardDestConfirmWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestConfirmWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestConfirmWireframeProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestConfirmWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestConfirmWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestConfirmWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(from view: StakingRewardDestConfirmViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    complete(from: StakingRewardDestConfirmViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(from: view))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestConfirmWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRewardDestConfirmViewProtocol?)> where M1.OptionalMatchedType == StakingRewardDestConfirmViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRewardDestConfirmViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmWireframeProtocol.self, method:
    """
    complete(from: StakingRewardDestConfirmViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestConfirmWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestConfirmWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.OptionalMatchable>(from view: M1) -> Cuckoo.__DoNotUse<(StakingRewardDestConfirmViewProtocol?), Void> where M1.OptionalMatchedType == StakingRewardDestConfirmViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRewardDestConfirmViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    complete(from: StakingRewardDestConfirmViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestConfirmWireframeProtocolStub: StakingRewardDestConfirmWireframeProtocol {
    

    

    
    
    
    
     func complete(from view: StakingRewardDestConfirmViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import SoraFoundation






 class MockStakingRewardDestSetupViewProtocol: StakingRewardDestSetupViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestSetupViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestSetupViewProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestSetupViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestSetupViewProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestSetupViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveRewardDestination(viewModel: ChangeRewardDestinationViewModel?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveRewardDestination(viewModel: ChangeRewardDestinationViewModel?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveRewardDestination(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestSetupViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardDestSetupViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardDestSetupViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingRewardDestSetupViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<BalanceViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupViewProtocol.self, method:
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveRewardDestination<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ChangeRewardDestinationViewModel?)> where M1.OptionalMatchedType == ChangeRewardDestinationViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChangeRewardDestinationViewModel?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupViewProtocol.self, method:
    """
    didReceiveRewardDestination(viewModel: ChangeRewardDestinationViewModel?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestSetupViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<BalanceViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveRewardDestination<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(ChangeRewardDestinationViewModel?), Void> where M1.OptionalMatchedType == ChangeRewardDestinationViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(ChangeRewardDestinationViewModel?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveRewardDestination(viewModel: ChangeRewardDestinationViewModel?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestSetupViewProtocolStub: StakingRewardDestSetupViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveRewardDestination(viewModel: ChangeRewardDestinationViewModel?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDestSetupPresenterProtocol: StakingRewardDestSetupPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestSetupPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestSetupPresenterProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestSetupPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestSetupPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestSetupPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func selectRestakeDestination()  {
        
    return cuckoo_manager.call(
    """
    selectRestakeDestination()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectRestakeDestination())
        
    }
    
    
    
    
    
     func selectPayoutDestination()  {
        
    return cuckoo_manager.call(
    """
    selectPayoutDestination()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectPayoutDestination())
        
    }
    
    
    
    
    
     func selectPayoutAccount()  {
        
    return cuckoo_manager.call(
    """
    selectPayoutAccount()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectPayoutAccount())
        
    }
    
    
    
    
    
     func displayLearnMore()  {
        
    return cuckoo_manager.call(
    """
    displayLearnMore()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.displayLearnMore())
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestSetupPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectRestakeDestination() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupPresenterProtocol.self, method:
    """
    selectRestakeDestination()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectPayoutDestination() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupPresenterProtocol.self, method:
    """
    selectPayoutDestination()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectPayoutAccount() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupPresenterProtocol.self, method:
    """
    selectPayoutAccount()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func displayLearnMore() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupPresenterProtocol.self, method:
    """
    displayLearnMore()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestSetupPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectRestakeDestination() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectRestakeDestination()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectPayoutDestination() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectPayoutDestination()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectPayoutAccount() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectPayoutAccount()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func displayLearnMore() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    displayLearnMore()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestSetupPresenterProtocolStub: StakingRewardDestSetupPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectRestakeDestination()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectPayoutDestination()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectPayoutAccount()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func displayLearnMore()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDestSetupInteractorInputProtocol: StakingRewardDestSetupInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestSetupInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestSetupInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestSetupInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestSetupInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestSetupInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(rewardDestination: RewardDestination<AccountAddress>)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(rewardDestination: RewardDestination<AccountAddress>)
    """,
            parameters: (rewardDestination),
            escapingParameters: (rewardDestination),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(rewardDestination: rewardDestination))
        
    }
    
    
    
    
    
     func fetchPayoutAccounts()  {
        
    return cuckoo_manager.call(
    """
    fetchPayoutAccounts()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.fetchPayoutAccounts())
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestSetupInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.Matchable>(rewardDestination: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(RewardDestination<AccountAddress>)> where M1.MatchedType == RewardDestination<AccountAddress> {
            let matchers: [Cuckoo.ParameterMatcher<(RewardDestination<AccountAddress>)>] = [wrap(matchable: rewardDestination) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorInputProtocol.self, method:
    """
    estimateFee(rewardDestination: RewardDestination<AccountAddress>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func fetchPayoutAccounts() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorInputProtocol.self, method:
    """
    fetchPayoutAccounts()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestSetupInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.Matchable>(rewardDestination: M1) -> Cuckoo.__DoNotUse<(RewardDestination<AccountAddress>), Void> where M1.MatchedType == RewardDestination<AccountAddress> {
            let matchers: [Cuckoo.ParameterMatcher<(RewardDestination<AccountAddress>)>] = [wrap(matchable: rewardDestination) { $0 }]
            return cuckoo_manager.verify(
    """
    estimateFee(rewardDestination: RewardDestination<AccountAddress>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func fetchPayoutAccounts() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    fetchPayoutAccounts()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestSetupInteractorInputProtocolStub: StakingRewardDestSetupInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(rewardDestination: RewardDestination<AccountAddress>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func fetchPayoutAccounts()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDestSetupInteractorOutputProtocol: StakingRewardDestSetupInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestSetupInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestSetupInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestSetupInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestSetupInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestSetupInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(result: result))
        
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    
    
    
    
     func didReceiveStashItem(result: Result<StashItem?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStashItem(result: result))
        
    }
    
    
    
    
    
     func didReceiveController(result: Result<ChainAccountResponse?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveController(result: Result<ChainAccountResponse?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveController(result: result))
        
    }
    
    
    
    
    
     func didReceiveStash(result: Result<ChainAccountResponse?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStash(result: Result<ChainAccountResponse?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStash(result: result))
        
    }
    
    
    
    
    
     func didReceiveStakingLedger(result: Result<StakingLedger?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveStakingLedger(result: Result<StakingLedger?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveStakingLedger(result: result))
        
    }
    
    
    
    
    
     func didReceiveRewardDestinationAccount(result: Result<RewardDestination<ChainAccountResponse>?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveRewardDestinationAccount(result: Result<RewardDestination<ChainAccountResponse>?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveRewardDestinationAccount(result: result))
        
    }
    
    
    
    
    
     func didReceiveRewardDestinationAddress(result: Result<RewardDestination<AccountAddress>?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveRewardDestinationAddress(result: Result<RewardDestination<AccountAddress>?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveRewardDestinationAddress(result: result))
        
    }
    
    
    
    
    
     func didReceiveCalculator(result: Result<RewardCalculatorEngineProtocol?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCalculator(result: Result<RewardCalculatorEngineProtocol?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCalculator(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccounts(result: result))
        
    }
    
    
    
    
    
     func didReceiveNomination(result: Result<Nomination?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveNomination(result: Result<Nomination?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveNomination(result: result))
        
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccountInfo(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestSetupInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RuntimeDispatchInfo, Error>)> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveStashItem<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<StashItem?, Error>)> where M1.MatchedType == Result<StashItem?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StashItem?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveController<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ChainAccountResponse?, Error>)> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveController(result: Result<ChainAccountResponse?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveStash<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<ChainAccountResponse?, Error>)> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveStash(result: Result<ChainAccountResponse?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveStakingLedger<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<StakingLedger?, Error>)> where M1.MatchedType == Result<StakingLedger?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StakingLedger?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveStakingLedger(result: Result<StakingLedger?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveRewardDestinationAccount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RewardDestination<ChainAccountResponse>?, Error>)> where M1.MatchedType == Result<RewardDestination<ChainAccountResponse>?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RewardDestination<ChainAccountResponse>?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveRewardDestinationAccount(result: Result<RewardDestination<ChainAccountResponse>?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveRewardDestinationAddress<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RewardDestination<AccountAddress>?, Error>)> where M1.MatchedType == Result<RewardDestination<AccountAddress>?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RewardDestination<AccountAddress>?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveRewardDestinationAddress(result: Result<RewardDestination<AccountAddress>?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveCalculator<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<RewardCalculatorEngineProtocol?, Error>)> where M1.MatchedType == Result<RewardCalculatorEngineProtocol?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RewardCalculatorEngineProtocol?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveCalculator(result: Result<RewardCalculatorEngineProtocol?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccounts<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<[ChainAccountResponse], Error>)> where M1.MatchedType == Result<[ChainAccountResponse], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[ChainAccountResponse], Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveNomination<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<Nomination?, Error>)> where M1.MatchedType == Result<Nomination?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<Nomination?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveNomination(result: Result<Nomination?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<AccountInfo?, Error>)> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupInteractorOutputProtocol.self, method:
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestSetupInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RuntimeDispatchInfo, Error>), Void> where M1.MatchedType == Result<RuntimeDispatchInfo, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RuntimeDispatchInfo, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveStashItem<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<StashItem?, Error>), Void> where M1.MatchedType == Result<StashItem?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StashItem?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStashItem(result: Result<StashItem?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveController<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ChainAccountResponse?, Error>), Void> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveController(result: Result<ChainAccountResponse?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveStash<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<ChainAccountResponse?, Error>), Void> where M1.MatchedType == Result<ChainAccountResponse?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<ChainAccountResponse?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStash(result: Result<ChainAccountResponse?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveStakingLedger<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<StakingLedger?, Error>), Void> where M1.MatchedType == Result<StakingLedger?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<StakingLedger?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveStakingLedger(result: Result<StakingLedger?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveRewardDestinationAccount<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RewardDestination<ChainAccountResponse>?, Error>), Void> where M1.MatchedType == Result<RewardDestination<ChainAccountResponse>?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RewardDestination<ChainAccountResponse>?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveRewardDestinationAccount(result: Result<RewardDestination<ChainAccountResponse>?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveRewardDestinationAddress<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RewardDestination<AccountAddress>?, Error>), Void> where M1.MatchedType == Result<RewardDestination<AccountAddress>?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RewardDestination<AccountAddress>?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveRewardDestinationAddress(result: Result<RewardDestination<AccountAddress>?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveCalculator<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<RewardCalculatorEngineProtocol?, Error>), Void> where M1.MatchedType == Result<RewardCalculatorEngineProtocol?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<RewardCalculatorEngineProtocol?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCalculator(result: Result<RewardCalculatorEngineProtocol?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccounts<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<[ChainAccountResponse], Error>), Void> where M1.MatchedType == Result<[ChainAccountResponse], Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<[ChainAccountResponse], Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveNomination<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<Nomination?, Error>), Void> where M1.MatchedType == Result<Nomination?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<Nomination?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveNomination(result: Result<Nomination?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccountInfo<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<AccountInfo?, Error>), Void> where M1.MatchedType == Result<AccountInfo?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<AccountInfo?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccountInfo(result: Result<AccountInfo?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestSetupInteractorOutputProtocolStub: StakingRewardDestSetupInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceiveFee(result: Result<RuntimeDispatchInfo, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveStashItem(result: Result<StashItem?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveController(result: Result<ChainAccountResponse?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveStash(result: Result<ChainAccountResponse?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveStakingLedger(result: Result<StakingLedger?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveRewardDestinationAccount(result: Result<RewardDestination<ChainAccountResponse>?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveRewardDestinationAddress(result: Result<RewardDestination<AccountAddress>?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveCalculator(result: Result<RewardCalculatorEngineProtocol?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccounts(result: Result<[ChainAccountResponse], Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveNomination(result: Result<Nomination?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccountInfo(result: Result<AccountInfo?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDestSetupWireframeProtocol: StakingRewardDestSetupWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDestSetupWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDestSetupWireframeProtocol
     typealias Verification = __VerificationProxy_StakingRewardDestSetupWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDestSetupWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDestSetupWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func proceed(view: StakingRewardDestSetupViewProtocol?, rewardDestination: RewardDestination<ChainAccountResponse>, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    proceed(view: StakingRewardDestSetupViewProtocol?, rewardDestination: RewardDestination<ChainAccountResponse>, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, rewardDestination, asset, chain, selectedAccount),
            escapingParameters: (view, rewardDestination, asset, chain, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(view: view, rewardDestination: rewardDestination, asset: asset, chain: chain, selectedAccount: selectedAccount))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    
    
    
    
     func presentAccountSelection(_ accounts: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from view: ControllerBackedProtocol?, context: AnyObject?)  {
        
    return cuckoo_manager.call(
    """
    presentAccountSelection(_: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from: ControllerBackedProtocol?, context: AnyObject?)
    """,
            parameters: (accounts, selectedAccountItem, title, delegate, view, context),
            escapingParameters: (accounts, selectedAccountItem, title, delegate, view, context),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentAccountSelection(accounts, selectedAccountItem: selectedAccountItem, title: title, delegate: delegate, from: view, context: context))
        
    }
    
    

     struct __StubbingProxy_StakingRewardDestSetupWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(view: M1, rewardDestination: M2, asset: M3, chain: M4, selectedAccount: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRewardDestSetupViewProtocol?, RewardDestination<ChainAccountResponse>, AssetModel, ChainModel, MetaAccountModel)> where M1.OptionalMatchedType == StakingRewardDestSetupViewProtocol, M2.MatchedType == RewardDestination<ChainAccountResponse>, M3.MatchedType == AssetModel, M4.MatchedType == ChainModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRewardDestSetupViewProtocol?, RewardDestination<ChainAccountResponse>, AssetModel, ChainModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: rewardDestination) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: chain) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupWireframeProtocol.self, method:
    """
    proceed(view: StakingRewardDestSetupViewProtocol?, rewardDestination: RewardDestination<ChainAccountResponse>, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentAccountSelection<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable, M6: Cuckoo.OptionalMatchable>(_ accounts: M1, selectedAccountItem: M2, title: M3, delegate: M4, from view: M5, context: M6) -> Cuckoo.ProtocolStubNoReturnFunction<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?)> where M1.MatchedType == [ChainAccountResponse], M2.OptionalMatchedType == ChainAccountResponse, M3.MatchedType == LocalizableResource<String>, M4.MatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == ControllerBackedProtocol, M6.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?)>] = [wrap(matchable: accounts) { $0.0 }, wrap(matchable: selectedAccountItem) { $0.1 }, wrap(matchable: title) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: view) { $0.4 }, wrap(matchable: context) { $0.5 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDestSetupWireframeProtocol.self, method:
    """
    presentAccountSelection(_: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from: ControllerBackedProtocol?, context: AnyObject?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDestSetupWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(view: M1, rewardDestination: M2, asset: M3, chain: M4, selectedAccount: M5) -> Cuckoo.__DoNotUse<(StakingRewardDestSetupViewProtocol?, RewardDestination<ChainAccountResponse>, AssetModel, ChainModel, MetaAccountModel), Void> where M1.OptionalMatchedType == StakingRewardDestSetupViewProtocol, M2.MatchedType == RewardDestination<ChainAccountResponse>, M3.MatchedType == AssetModel, M4.MatchedType == ChainModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRewardDestSetupViewProtocol?, RewardDestination<ChainAccountResponse>, AssetModel, ChainModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: rewardDestination) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: chain) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return cuckoo_manager.verify(
    """
    proceed(view: StakingRewardDestSetupViewProtocol?, rewardDestination: RewardDestination<ChainAccountResponse>, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentAccountSelection<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable, M6: Cuckoo.OptionalMatchable>(_ accounts: M1, selectedAccountItem: M2, title: M3, delegate: M4, from view: M5, context: M6) -> Cuckoo.__DoNotUse<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?), Void> where M1.MatchedType == [ChainAccountResponse], M2.OptionalMatchedType == ChainAccountResponse, M3.MatchedType == LocalizableResource<String>, M4.MatchedType == ModalPickerViewControllerDelegate, M5.OptionalMatchedType == ControllerBackedProtocol, M6.OptionalMatchedType == AnyObject {
            let matchers: [Cuckoo.ParameterMatcher<([ChainAccountResponse], ChainAccountResponse?, LocalizableResource<String>, ModalPickerViewControllerDelegate, ControllerBackedProtocol?, AnyObject?)>] = [wrap(matchable: accounts) { $0.0 }, wrap(matchable: selectedAccountItem) { $0.1 }, wrap(matchable: title) { $0.2 }, wrap(matchable: delegate) { $0.3 }, wrap(matchable: view) { $0.4 }, wrap(matchable: context) { $0.5 }]
            return cuckoo_manager.verify(
    """
    presentAccountSelection(_: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from: ControllerBackedProtocol?, context: AnyObject?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDestSetupWireframeProtocolStub: StakingRewardDestSetupWireframeProtocol {
    

    

    
    
    
    
     func proceed(view: StakingRewardDestSetupViewProtocol?, rewardDestination: RewardDestination<ChainAccountResponse>, asset: AssetModel, chain: ChainModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentAccountSelection(_ accounts: [ChainAccountResponse], selectedAccountItem: ChainAccountResponse?, title: LocalizableResource<String>, delegate: ModalPickerViewControllerDelegate, from view: ControllerBackedProtocol?, context: AnyObject?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockStakingRewardDetailsViewProtocol: StakingRewardDetailsViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDetailsViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDetailsViewProtocol
     typealias Verification = __VerificationProxy_StakingRewardDetailsViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDetailsViewProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDetailsViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func reload(with viewModel: LocalizableResource<StakingRewardDetailsViewModel>)  {
        
    return cuckoo_manager.call(
    """
    reload(with: LocalizableResource<StakingRewardDetailsViewModel>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload(with: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_StakingRewardDetailsViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardDetailsViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardDetailsViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingRewardDetailsViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func reload<M1: Cuckoo.Matchable>(with viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<StakingRewardDetailsViewModel>)> where M1.MatchedType == LocalizableResource<StakingRewardDetailsViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<StakingRewardDetailsViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDetailsViewProtocol.self, method:
    """
    reload(with: LocalizableResource<StakingRewardDetailsViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDetailsViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDetailsViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func reload<M1: Cuckoo.Matchable>(with viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<StakingRewardDetailsViewModel>), Void> where M1.MatchedType == LocalizableResource<StakingRewardDetailsViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<StakingRewardDetailsViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    reload(with: LocalizableResource<StakingRewardDetailsViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDetailsViewProtocolStub: StakingRewardDetailsViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func reload(with viewModel: LocalizableResource<StakingRewardDetailsViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDetailsPresenterProtocol: StakingRewardDetailsPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDetailsPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDetailsPresenterProtocol
     typealias Verification = __VerificationProxy_StakingRewardDetailsPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDetailsPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDetailsPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func handlePayoutAction()  {
        
    return cuckoo_manager.call(
    """
    handlePayoutAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handlePayoutAction())
        
    }
    
    
    
    
    
     func handleValidatorAccountAction(locale: Locale)  {
        
    return cuckoo_manager.call(
    """
    handleValidatorAccountAction(locale: Locale)
    """,
            parameters: (locale),
            escapingParameters: (locale),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handleValidatorAccountAction(locale: locale))
        
    }
    
    

     struct __StubbingProxy_StakingRewardDetailsPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDetailsPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handlePayoutAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDetailsPresenterProtocol.self, method:
    """
    handlePayoutAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handleValidatorAccountAction<M1: Cuckoo.Matchable>(locale: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Locale)> where M1.MatchedType == Locale {
            let matchers: [Cuckoo.ParameterMatcher<(Locale)>] = [wrap(matchable: locale) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDetailsPresenterProtocol.self, method:
    """
    handleValidatorAccountAction(locale: Locale)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDetailsPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handlePayoutAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    handlePayoutAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handleValidatorAccountAction<M1: Cuckoo.Matchable>(locale: M1) -> Cuckoo.__DoNotUse<(Locale), Void> where M1.MatchedType == Locale {
            let matchers: [Cuckoo.ParameterMatcher<(Locale)>] = [wrap(matchable: locale) { $0 }]
            return cuckoo_manager.verify(
    """
    handleValidatorAccountAction(locale: Locale)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDetailsPresenterProtocolStub: StakingRewardDetailsPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handlePayoutAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handleValidatorAccountAction(locale: Locale)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDetailsInteractorInputProtocol: StakingRewardDetailsInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDetailsInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDetailsInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingRewardDetailsInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDetailsInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDetailsInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    

     struct __StubbingProxy_StakingRewardDetailsInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDetailsInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDetailsInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDetailsInteractorInputProtocolStub: StakingRewardDetailsInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDetailsInteractorOutputProtocol: StakingRewardDetailsInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDetailsInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDetailsInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingRewardDetailsInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDetailsInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDetailsInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(priceResult: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(priceResult: Result<PriceData?, Error>)
    """,
            parameters: (priceResult),
            escapingParameters: (priceResult),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(priceResult: priceResult))
        
    }
    
    

     struct __StubbingProxy_StakingRewardDetailsInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(priceResult: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: priceResult) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDetailsInteractorOutputProtocol.self, method:
    """
    didReceive(priceResult: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDetailsInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(priceResult: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: priceResult) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(priceResult: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDetailsInteractorOutputProtocolStub: StakingRewardDetailsInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceive(priceResult: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardDetailsWireframeProtocol: StakingRewardDetailsWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardDetailsWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardDetailsWireframeProtocol
     typealias Verification = __VerificationProxy_StakingRewardDetailsWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardDetailsWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardDetailsWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showPayoutConfirmation(from view: ControllerBackedProtocol?, payoutInfo: PayoutInfo, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showPayoutConfirmation(from: ControllerBackedProtocol?, payoutInfo: PayoutInfo, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, payoutInfo, chain, asset, selectedAccount),
            escapingParameters: (view, payoutInfo, chain, asset, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showPayoutConfirmation(from: view, payoutInfo: payoutInfo, chain: chain, asset: asset, selectedAccount: selectedAccount))
        
    }
    
    

     struct __StubbingProxy_StakingRewardDetailsWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showPayoutConfirmation<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, payoutInfo: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, PayoutInfo, ChainModel, AssetModel, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == PayoutInfo, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, PayoutInfo, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: payoutInfo) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardDetailsWireframeProtocol.self, method:
    """
    showPayoutConfirmation(from: ControllerBackedProtocol?, payoutInfo: PayoutInfo, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardDetailsWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showPayoutConfirmation<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable>(from view: M1, payoutInfo: M2, chain: M3, asset: M4, selectedAccount: M5) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, PayoutInfo, ChainModel, AssetModel, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == PayoutInfo, M3.MatchedType == ChainModel, M4.MatchedType == AssetModel, M5.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, PayoutInfo, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: payoutInfo) { $0.1 }, wrap(matchable: chain) { $0.2 }, wrap(matchable: asset) { $0.3 }, wrap(matchable: selectedAccount) { $0.4 }]
            return cuckoo_manager.verify(
    """
    showPayoutConfirmation(from: ControllerBackedProtocol?, payoutInfo: PayoutInfo, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardDetailsWireframeProtocolStub: StakingRewardDetailsWireframeProtocol {
    

    

    
    
    
    
     func showPayoutConfirmation(from view: ControllerBackedProtocol?, payoutInfo: PayoutInfo, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation
import SoraUI






 class MockStakingRewardPayoutsViewProtocol: StakingRewardPayoutsViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardPayoutsViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardPayoutsViewProtocol
     typealias Verification = __VerificationProxy_StakingRewardPayoutsViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardPayoutsViewProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardPayoutsViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func reload(with state: StakingRewardPayoutsViewState)  {
        
    return cuckoo_manager.call(
    """
    reload(with: StakingRewardPayoutsViewState)
    """,
            parameters: (state),
            escapingParameters: (state),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload(with: state))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_StakingRewardPayoutsViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardPayoutsViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardPayoutsViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingRewardPayoutsViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardPayoutsViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingRewardPayoutsViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func reload<M1: Cuckoo.Matchable>(with state: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingRewardPayoutsViewState)> where M1.MatchedType == StakingRewardPayoutsViewState {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRewardPayoutsViewState)>] = [wrap(matchable: state) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsViewProtocol.self, method:
    """
    reload(with: StakingRewardPayoutsViewState)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardPayoutsViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func reload<M1: Cuckoo.Matchable>(with state: M1) -> Cuckoo.__DoNotUse<(StakingRewardPayoutsViewState), Void> where M1.MatchedType == StakingRewardPayoutsViewState {
            let matchers: [Cuckoo.ParameterMatcher<(StakingRewardPayoutsViewState)>] = [wrap(matchable: state) { $0 }]
            return cuckoo_manager.verify(
    """
    reload(with: StakingRewardPayoutsViewState)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardPayoutsViewProtocolStub: StakingRewardPayoutsViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func reload(with state: StakingRewardPayoutsViewState)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardPayoutsPresenterProtocol: StakingRewardPayoutsPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardPayoutsPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardPayoutsPresenterProtocol
     typealias Verification = __VerificationProxy_StakingRewardPayoutsPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardPayoutsPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardPayoutsPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func handleSelectedHistory(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    handleSelectedHistory(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handleSelectedHistory(at: index))
        
    }
    
    
    
    
    
     func handlePayoutAction()  {
        
    return cuckoo_manager.call(
    """
    handlePayoutAction()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.handlePayoutAction())
        
    }
    
    
    
    
    
     func reload()  {
        
    return cuckoo_manager.call(
    """
    reload()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload())
        
    }
    
    
    
    
    
     func getTimeLeftString(at index: Int) -> LocalizableResource<NSAttributedString>? {
        
    return cuckoo_manager.call(
    """
    getTimeLeftString(at: Int) -> LocalizableResource<NSAttributedString>?
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.getTimeLeftString(at: index))
        
    }
    
    

     struct __StubbingProxy_StakingRewardPayoutsPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handleSelectedHistory<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsPresenterProtocol.self, method:
    """
    handleSelectedHistory(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func handlePayoutAction() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsPresenterProtocol.self, method:
    """
    handlePayoutAction()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func reload() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsPresenterProtocol.self, method:
    """
    reload()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func getTimeLeftString<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubFunction<(Int), LocalizableResource<NSAttributedString>?> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsPresenterProtocol.self, method:
    """
    getTimeLeftString(at: Int) -> LocalizableResource<NSAttributedString>?
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardPayoutsPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handleSelectedHistory<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    handleSelectedHistory(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func handlePayoutAction() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    handlePayoutAction()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func reload() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    reload()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func getTimeLeftString<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), LocalizableResource<NSAttributedString>?> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    getTimeLeftString(at: Int) -> LocalizableResource<NSAttributedString>?
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardPayoutsPresenterProtocolStub: StakingRewardPayoutsPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handleSelectedHistory(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func handlePayoutAction()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func reload()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func getTimeLeftString(at index: Int) -> LocalizableResource<NSAttributedString>?  {
        return DefaultValueRegistry.defaultValue(for: (LocalizableResource<NSAttributedString>?).self)
    }
    
    
}










 class MockStakingRewardPayoutsInteractorInputProtocol: StakingRewardPayoutsInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardPayoutsInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardPayoutsInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingRewardPayoutsInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardPayoutsInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardPayoutsInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func reload()  {
        
    return cuckoo_manager.call(
    """
    reload()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reload())
        
    }
    
    

     struct __StubbingProxy_StakingRewardPayoutsInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func reload() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsInteractorInputProtocol.self, method:
    """
    reload()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardPayoutsInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func reload() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    reload()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardPayoutsInteractorInputProtocolStub: StakingRewardPayoutsInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func reload()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardPayoutsInteractorOutputProtocol: StakingRewardPayoutsInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardPayoutsInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardPayoutsInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingRewardPayoutsInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardPayoutsInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardPayoutsInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(result: Result<PayoutsInfo, PayoutRewardsServiceError>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(result: Result<PayoutsInfo, PayoutRewardsServiceError>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(result: result))
        
    }
    
    
    
    
    
     func didReceive(priceResult: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(priceResult: Result<PriceData?, Error>)
    """,
            parameters: (priceResult),
            escapingParameters: (priceResult),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(priceResult: priceResult))
        
    }
    
    
    
    
    
     func didReceive(eraCountdownResult: Result<EraCountdown, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceive(eraCountdownResult: Result<EraCountdown, Error>)
    """,
            parameters: (eraCountdownResult),
            escapingParameters: (eraCountdownResult),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(eraCountdownResult: eraCountdownResult))
        
    }
    
    

     struct __StubbingProxy_StakingRewardPayoutsInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PayoutsInfo, PayoutRewardsServiceError>)> where M1.MatchedType == Result<PayoutsInfo, PayoutRewardsServiceError> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PayoutsInfo, PayoutRewardsServiceError>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsInteractorOutputProtocol.self, method:
    """
    didReceive(result: Result<PayoutsInfo, PayoutRewardsServiceError>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(priceResult: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: priceResult) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsInteractorOutputProtocol.self, method:
    """
    didReceive(priceResult: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(eraCountdownResult: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<EraCountdown, Error>)> where M1.MatchedType == Result<EraCountdown, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<EraCountdown, Error>)>] = [wrap(matchable: eraCountdownResult) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsInteractorOutputProtocol.self, method:
    """
    didReceive(eraCountdownResult: Result<EraCountdown, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardPayoutsInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PayoutsInfo, PayoutRewardsServiceError>), Void> where M1.MatchedType == Result<PayoutsInfo, PayoutRewardsServiceError> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PayoutsInfo, PayoutRewardsServiceError>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(result: Result<PayoutsInfo, PayoutRewardsServiceError>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(priceResult: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: priceResult) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(priceResult: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(eraCountdownResult: M1) -> Cuckoo.__DoNotUse<(Result<EraCountdown, Error>), Void> where M1.MatchedType == Result<EraCountdown, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<EraCountdown, Error>)>] = [wrap(matchable: eraCountdownResult) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(eraCountdownResult: Result<EraCountdown, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardPayoutsInteractorOutputProtocolStub: StakingRewardPayoutsInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceive(result: Result<PayoutsInfo, PayoutRewardsServiceError>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(priceResult: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceive(eraCountdownResult: Result<EraCountdown, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingRewardPayoutsWireframeProtocol: StakingRewardPayoutsWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingRewardPayoutsWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingRewardPayoutsWireframeProtocol
     typealias Verification = __VerificationProxy_StakingRewardPayoutsWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingRewardPayoutsWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingRewardPayoutsWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func showRewardDetails(from view: ControllerBackedProtocol?, payoutInfo: PayoutInfo, activeEra: EraIndex, historyDepth: UInt32, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    showRewardDetails(from: ControllerBackedProtocol?, payoutInfo: PayoutInfo, activeEra: EraIndex, historyDepth: UInt32, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """,
            parameters: (view, payoutInfo, activeEra, historyDepth, chain, asset, selectedAccount),
            escapingParameters: (view, payoutInfo, activeEra, historyDepth, chain, asset, selectedAccount),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showRewardDetails(from: view, payoutInfo: payoutInfo, activeEra: activeEra, historyDepth: historyDepth, chain: chain, asset: asset, selectedAccount: selectedAccount))
        
    }
    
    
    
    
    
     func showPayoutConfirmation(for payouts: [PayoutInfo], chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    showPayoutConfirmation(for: [PayoutInfo], chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel, from: ControllerBackedProtocol?)
    """,
            parameters: (payouts, chain, asset, selectedAccount, view),
            escapingParameters: (payouts, chain, asset, selectedAccount, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showPayoutConfirmation(for: payouts, chain: chain, asset: asset, selectedAccount: selectedAccount, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingRewardPayoutsWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func showRewardDetails<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable, M6: Cuckoo.Matchable, M7: Cuckoo.Matchable>(from view: M1, payoutInfo: M2, activeEra: M3, historyDepth: M4, chain: M5, asset: M6, selectedAccount: M7) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, PayoutInfo, EraIndex, UInt32, ChainModel, AssetModel, MetaAccountModel)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == PayoutInfo, M3.MatchedType == EraIndex, M4.MatchedType == UInt32, M5.MatchedType == ChainModel, M6.MatchedType == AssetModel, M7.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, PayoutInfo, EraIndex, UInt32, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: payoutInfo) { $0.1 }, wrap(matchable: activeEra) { $0.2 }, wrap(matchable: historyDepth) { $0.3 }, wrap(matchable: chain) { $0.4 }, wrap(matchable: asset) { $0.5 }, wrap(matchable: selectedAccount) { $0.6 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsWireframeProtocol.self, method:
    """
    showRewardDetails(from: ControllerBackedProtocol?, payoutInfo: PayoutInfo, activeEra: EraIndex, historyDepth: UInt32, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showPayoutConfirmation<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable>(for payouts: M1, chain: M2, asset: M3, selectedAccount: M4, from view: M5) -> Cuckoo.ProtocolStubNoReturnFunction<([PayoutInfo], ChainModel, AssetModel, MetaAccountModel, ControllerBackedProtocol?)> where M1.MatchedType == [PayoutInfo], M2.MatchedType == ChainModel, M3.MatchedType == AssetModel, M4.MatchedType == MetaAccountModel, M5.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<([PayoutInfo], ChainModel, AssetModel, MetaAccountModel, ControllerBackedProtocol?)>] = [wrap(matchable: payouts) { $0.0 }, wrap(matchable: chain) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: selectedAccount) { $0.3 }, wrap(matchable: view) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingRewardPayoutsWireframeProtocol.self, method:
    """
    showPayoutConfirmation(for: [PayoutInfo], chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingRewardPayoutsWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func showRewardDetails<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.Matchable, M6: Cuckoo.Matchable, M7: Cuckoo.Matchable>(from view: M1, payoutInfo: M2, activeEra: M3, historyDepth: M4, chain: M5, asset: M6, selectedAccount: M7) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, PayoutInfo, EraIndex, UInt32, ChainModel, AssetModel, MetaAccountModel), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == PayoutInfo, M3.MatchedType == EraIndex, M4.MatchedType == UInt32, M5.MatchedType == ChainModel, M6.MatchedType == AssetModel, M7.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, PayoutInfo, EraIndex, UInt32, ChainModel, AssetModel, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: payoutInfo) { $0.1 }, wrap(matchable: activeEra) { $0.2 }, wrap(matchable: historyDepth) { $0.3 }, wrap(matchable: chain) { $0.4 }, wrap(matchable: asset) { $0.5 }, wrap(matchable: selectedAccount) { $0.6 }]
            return cuckoo_manager.verify(
    """
    showRewardDetails(from: ControllerBackedProtocol?, payoutInfo: PayoutInfo, activeEra: EraIndex, historyDepth: UInt32, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showPayoutConfirmation<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable, M5: Cuckoo.OptionalMatchable>(for payouts: M1, chain: M2, asset: M3, selectedAccount: M4, from view: M5) -> Cuckoo.__DoNotUse<([PayoutInfo], ChainModel, AssetModel, MetaAccountModel, ControllerBackedProtocol?), Void> where M1.MatchedType == [PayoutInfo], M2.MatchedType == ChainModel, M3.MatchedType == AssetModel, M4.MatchedType == MetaAccountModel, M5.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<([PayoutInfo], ChainModel, AssetModel, MetaAccountModel, ControllerBackedProtocol?)>] = [wrap(matchable: payouts) { $0.0 }, wrap(matchable: chain) { $0.1 }, wrap(matchable: asset) { $0.2 }, wrap(matchable: selectedAccount) { $0.3 }, wrap(matchable: view) { $0.4 }]
            return cuckoo_manager.verify(
    """
    showPayoutConfirmation(for: [PayoutInfo], chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingRewardPayoutsWireframeProtocolStub: StakingRewardPayoutsWireframeProtocol {
    

    

    
    
    
    
     func showRewardDetails(from view: ControllerBackedProtocol?, payoutInfo: PayoutInfo, activeEra: EraIndex, historyDepth: UInt32, chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showPayoutConfirmation(for payouts: [PayoutInfo], chain: ChainModel, asset: AssetModel, selectedAccount: MetaAccountModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingPayoutViewModelFactoryProtocol: StakingPayoutViewModelFactoryProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingPayoutViewModelFactoryProtocol
    
     typealias Stubbing = __StubbingProxy_StakingPayoutViewModelFactoryProtocol
     typealias Verification = __VerificationProxy_StakingPayoutViewModelFactoryProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingPayoutViewModelFactoryProtocol?

     func enableDefaultImplementation(_ stub: StakingPayoutViewModelFactoryProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func createPayoutsViewModel(payoutsInfo: PayoutsInfo, priceData: PriceData?, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<StakingPayoutViewModel> {
        
    return cuckoo_manager.call(
    """
    createPayoutsViewModel(payoutsInfo: PayoutsInfo, priceData: PriceData?, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<StakingPayoutViewModel>
    """,
            parameters: (payoutsInfo, priceData, eraCountdown, erasPerDay),
            escapingParameters: (payoutsInfo, priceData, eraCountdown, erasPerDay),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.createPayoutsViewModel(payoutsInfo: payoutsInfo, priceData: priceData, eraCountdown: eraCountdown, erasPerDay: erasPerDay))
        
    }
    
    
    
    
    
     func timeLeftString(at index: Int, payoutsInfo: PayoutsInfo, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<NSAttributedString> {
        
    return cuckoo_manager.call(
    """
    timeLeftString(at: Int, payoutsInfo: PayoutsInfo, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<NSAttributedString>
    """,
            parameters: (index, payoutsInfo, eraCountdown, erasPerDay),
            escapingParameters: (index, payoutsInfo, eraCountdown, erasPerDay),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.timeLeftString(at: index, payoutsInfo: payoutsInfo, eraCountdown: eraCountdown, erasPerDay: erasPerDay))
        
    }
    
    

     struct __StubbingProxy_StakingPayoutViewModelFactoryProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func createPayoutsViewModel<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.Matchable>(payoutsInfo: M1, priceData: M2, eraCountdown: M3, erasPerDay: M4) -> Cuckoo.ProtocolStubFunction<(PayoutsInfo, PriceData?, EraCountdown?, UInt32), LocalizableResource<StakingPayoutViewModel>> where M1.MatchedType == PayoutsInfo, M2.OptionalMatchedType == PriceData, M3.OptionalMatchedType == EraCountdown, M4.MatchedType == UInt32 {
            let matchers: [Cuckoo.ParameterMatcher<(PayoutsInfo, PriceData?, EraCountdown?, UInt32)>] = [wrap(matchable: payoutsInfo) { $0.0 }, wrap(matchable: priceData) { $0.1 }, wrap(matchable: eraCountdown) { $0.2 }, wrap(matchable: erasPerDay) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutViewModelFactoryProtocol.self, method:
    """
    createPayoutsViewModel(payoutsInfo: PayoutsInfo, priceData: PriceData?, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<StakingPayoutViewModel>
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func timeLeftString<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.Matchable>(at index: M1, payoutsInfo: M2, eraCountdown: M3, erasPerDay: M4) -> Cuckoo.ProtocolStubFunction<(Int, PayoutsInfo, EraCountdown?, UInt32), LocalizableResource<NSAttributedString>> where M1.MatchedType == Int, M2.MatchedType == PayoutsInfo, M3.OptionalMatchedType == EraCountdown, M4.MatchedType == UInt32 {
            let matchers: [Cuckoo.ParameterMatcher<(Int, PayoutsInfo, EraCountdown?, UInt32)>] = [wrap(matchable: index) { $0.0 }, wrap(matchable: payoutsInfo) { $0.1 }, wrap(matchable: eraCountdown) { $0.2 }, wrap(matchable: erasPerDay) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingPayoutViewModelFactoryProtocol.self, method:
    """
    timeLeftString(at: Int, payoutsInfo: PayoutsInfo, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<NSAttributedString>
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingPayoutViewModelFactoryProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func createPayoutsViewModel<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.Matchable>(payoutsInfo: M1, priceData: M2, eraCountdown: M3, erasPerDay: M4) -> Cuckoo.__DoNotUse<(PayoutsInfo, PriceData?, EraCountdown?, UInt32), LocalizableResource<StakingPayoutViewModel>> where M1.MatchedType == PayoutsInfo, M2.OptionalMatchedType == PriceData, M3.OptionalMatchedType == EraCountdown, M4.MatchedType == UInt32 {
            let matchers: [Cuckoo.ParameterMatcher<(PayoutsInfo, PriceData?, EraCountdown?, UInt32)>] = [wrap(matchable: payoutsInfo) { $0.0 }, wrap(matchable: priceData) { $0.1 }, wrap(matchable: eraCountdown) { $0.2 }, wrap(matchable: erasPerDay) { $0.3 }]
            return cuckoo_manager.verify(
    """
    createPayoutsViewModel(payoutsInfo: PayoutsInfo, priceData: PriceData?, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<StakingPayoutViewModel>
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func timeLeftString<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.Matchable>(at index: M1, payoutsInfo: M2, eraCountdown: M3, erasPerDay: M4) -> Cuckoo.__DoNotUse<(Int, PayoutsInfo, EraCountdown?, UInt32), LocalizableResource<NSAttributedString>> where M1.MatchedType == Int, M2.MatchedType == PayoutsInfo, M3.OptionalMatchedType == EraCountdown, M4.MatchedType == UInt32 {
            let matchers: [Cuckoo.ParameterMatcher<(Int, PayoutsInfo, EraCountdown?, UInt32)>] = [wrap(matchable: index) { $0.0 }, wrap(matchable: payoutsInfo) { $0.1 }, wrap(matchable: eraCountdown) { $0.2 }, wrap(matchable: erasPerDay) { $0.3 }]
            return cuckoo_manager.verify(
    """
    timeLeftString(at: Int, payoutsInfo: PayoutsInfo, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<NSAttributedString>
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingPayoutViewModelFactoryProtocolStub: StakingPayoutViewModelFactoryProtocol {
    

    

    
    
    
    
     func createPayoutsViewModel(payoutsInfo: PayoutsInfo, priceData: PriceData?, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<StakingPayoutViewModel>  {
        return DefaultValueRegistry.defaultValue(for: (LocalizableResource<StakingPayoutViewModel>).self)
    }
    
    
    
    
    
     func timeLeftString(at index: Int, payoutsInfo: PayoutsInfo, eraCountdown: EraCountdown?, erasPerDay: UInt32) -> LocalizableResource<NSAttributedString>  {
        return DefaultValueRegistry.defaultValue(for: (LocalizableResource<NSAttributedString>).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import Foundation
import SoraFoundation






 class MockStakingUnbondConfirmViewProtocol: StakingUnbondConfirmViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondConfirmViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondConfirmViewProtocol
     typealias Verification = __VerificationProxy_StakingUnbondConfirmViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondConfirmViewProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondConfirmViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return cuckoo_manager.getter("loadableContentView",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.loadableContentView)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return cuckoo_manager.getter("shouldDisableInteractionWhenLoading",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.shouldDisableInteractionWhenLoading)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingUnbondConfirmViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveConfirmation(viewModel: StakingUnbondConfirmViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveConfirmation(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAsset(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)
    """,
            parameters: (duration),
            escapingParameters: (duration),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBonding(duration: duration))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    
    
    
    
     func didStartLoading()  {
        
    return cuckoo_manager.call(
    """
    didStartLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStartLoading())
        
    }
    
    
    
    
    
     func didStopLoading()  {
        
    return cuckoo_manager.call(
    """
    didStopLoading()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didStopLoading())
        
    }
    
    

     struct __StubbingProxy_StakingUnbondConfirmViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingUnbondConfirmViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingUnbondConfirmViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingUnbondConfirmViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        var loadableContentView: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingUnbondConfirmViewProtocol, UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView")
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingUnbondConfirmViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading")
        }
        
        
        
        
        
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingUnbondConfirmViewModel)> where M1.MatchedType == StakingUnbondConfirmViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingUnbondConfirmViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmViewProtocol.self, method:
    """
    didReceiveConfirmation(viewModel: StakingUnbondConfirmViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<AssetBalanceViewModelProtocol>)> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmViewProtocol.self, method:
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<BalanceViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmViewProtocol.self, method:
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBonding<M1: Cuckoo.Matchable>(duration: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<TitleWithSubtitleViewModel>)> where M1.MatchedType == LocalizableResource<TitleWithSubtitleViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<TitleWithSubtitleViewModel>)>] = [wrap(matchable: duration) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmViewProtocol.self, method:
    """
    didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStartLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmViewProtocol.self, method:
    """
    didStartLoading()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didStopLoading() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmViewProtocol.self, method:
    """
    didStopLoading()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondConfirmViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var loadableContentView: Cuckoo.VerifyReadOnlyProperty<UIView> {
            return .init(manager: cuckoo_manager, name: "loadableContentView", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var shouldDisableInteractionWhenLoading: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "shouldDisableInteractionWhenLoading", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveConfirmation<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(StakingUnbondConfirmViewModel), Void> where M1.MatchedType == StakingUnbondConfirmViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingUnbondConfirmViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveConfirmation(viewModel: StakingUnbondConfirmViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<AssetBalanceViewModelProtocol>), Void> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<BalanceViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<BalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<BalanceViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBonding<M1: Cuckoo.Matchable>(duration: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<TitleWithSubtitleViewModel>), Void> where M1.MatchedType == LocalizableResource<TitleWithSubtitleViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<TitleWithSubtitleViewModel>)>] = [wrap(matchable: duration) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStartLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStartLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didStopLoading() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didStopLoading()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondConfirmViewProtocolStub: StakingUnbondConfirmViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    
    
    
    
     var loadableContentView: UIView {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIView).self)
        }
        
    }
    
    
    
    
    
     var shouldDisableInteractionWhenLoading: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveConfirmation(viewModel: StakingUnbondConfirmViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<BalanceViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStartLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didStopLoading()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingUnbondConfirmPresenterProtocol: StakingUnbondConfirmPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondConfirmPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondConfirmPresenterProtocol
     typealias Verification = __VerificationProxy_StakingUnbondConfirmPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondConfirmPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondConfirmPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func confirm()  {
        
    return cuckoo_manager.call(
    """
    confirm()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.confirm())
        
    }
    
    
    
    
    
     func selectAccount()  {
        
    return cuckoo_manager.call(
    """
    selectAccount()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectAccount())
        
    }
    
    
    
    
    
     func didTapBackButton()  {
        
    return cuckoo_manager.call(
    """
    didTapBackButton()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didTapBackButton())
        
    }
    
    

     struct __StubbingProxy_StakingUnbondConfirmPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func confirm() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmPresenterProtocol.self, method:
    """
    confirm()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectAccount() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmPresenterProtocol.self, method:
    """
    selectAccount()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didTapBackButton() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmPresenterProtocol.self, method:
    """
    didTapBackButton()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondConfirmPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func confirm() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    confirm()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectAccount() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    selectAccount()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didTapBackButton() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didTapBackButton()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondConfirmPresenterProtocolStub: StakingUnbondConfirmPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func confirm()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectAccount()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didTapBackButton()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingUnbondConfirmInteractorInputProtocol: StakingUnbondConfirmInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondConfirmInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondConfirmInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingUnbondConfirmInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondConfirmInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondConfirmInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """,
            parameters: (builderClosure, reuseIdentifier),
            escapingParameters: (builderClosure, reuseIdentifier),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(builderClosure: builderClosure, reuseIdentifier: reuseIdentifier))
        
    }
    
    
    
    
    
     func submit(builderClosure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """,
            parameters: (builderClosure),
            escapingParameters: (builderClosure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.submit(builderClosure: builderClosure))
        
    }
    
    

     struct __StubbingProxy_StakingUnbondConfirmInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(builderClosure: M1, reuseIdentifier: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?, String?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure, M2.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?, String?)>] = [wrap(matchable: builderClosure) { $0.0 }, wrap(matchable: reuseIdentifier) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmInteractorInputProtocol.self, method:
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func submit<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmInteractorInputProtocol.self, method:
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondConfirmInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.OptionalMatchable>(builderClosure: M1, reuseIdentifier: M2) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?, String?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure, M2.OptionalMatchedType == String {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?, String?)>] = [wrap(matchable: builderClosure) { $0.0 }, wrap(matchable: reuseIdentifier) { $0.1 }]
            return cuckoo_manager.verify(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func submit<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return cuckoo_manager.verify(
    """
    submit(builderClosure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondConfirmInteractorInputProtocolStub: StakingUnbondConfirmInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?, reuseIdentifier: String?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func submit(builderClosure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingUnbondConfirmInteractorOutputProtocol: StakingUnbondConfirmInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondConfirmInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondConfirmInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingUnbondConfirmInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondConfirmInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondConfirmInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingUnbondConfirmInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondConfirmInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondConfirmInteractorOutputProtocolStub: StakingUnbondConfirmInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingUnbondConfirmWireframeProtocol: StakingUnbondConfirmWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondConfirmWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondConfirmWireframeProtocol
     typealias Verification = __VerificationProxy_StakingUnbondConfirmWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondConfirmWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondConfirmWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func complete(on view: ControllerBackedProtocol?, hash: String, chainAsset: ChainAsset)  {
        
    return cuckoo_manager.call(
    """
    complete(on: ControllerBackedProtocol?, hash: String, chainAsset: ChainAsset)
    """,
            parameters: (view, hash, chainAsset),
            escapingParameters: (view, hash, chainAsset),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.complete(on: view, hash: hash, chainAsset: chainAsset))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_StakingUnbondConfirmWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func complete<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(on view: M1, hash: M2, chainAsset: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(ControllerBackedProtocol?, String, ChainAsset)> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == String, M3.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, String, ChainAsset)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: hash) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmWireframeProtocol.self, method:
    """
    complete(on: ControllerBackedProtocol?, hash: String, chainAsset: ChainAsset)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondConfirmWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondConfirmWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func complete<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(on view: M1, hash: M2, chainAsset: M3) -> Cuckoo.__DoNotUse<(ControllerBackedProtocol?, String, ChainAsset), Void> where M1.OptionalMatchedType == ControllerBackedProtocol, M2.MatchedType == String, M3.MatchedType == ChainAsset {
            let matchers: [Cuckoo.ParameterMatcher<(ControllerBackedProtocol?, String, ChainAsset)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: hash) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }]
            return cuckoo_manager.verify(
    """
    complete(on: ControllerBackedProtocol?, hash: String, chainAsset: ChainAsset)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondConfirmWireframeProtocolStub: StakingUnbondConfirmWireframeProtocol {
    

    

    
    
    
    
     func complete(on view: ControllerBackedProtocol?, hash: String, chainAsset: ChainAsset)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import BigInt
import CommonWallet
import Foundation
import SoraFoundation






 class MockStakingUnbondSetupViewProtocol: StakingUnbondSetupViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondSetupViewProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondSetupViewProtocol
     typealias Verification = __VerificationProxy_StakingUnbondSetupViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondSetupViewProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondSetupViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAsset(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)  {
        
    return cuckoo_manager.call(
    """
    didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveFee(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveInput(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)
    """,
            parameters: (duration),
            escapingParameters: (duration),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveBonding(duration: duration))
        
    }
    
    
    
    
    
     func didReceiveAccount(viewModel: AccountViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveAccount(viewModel: AccountViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveAccount(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveCollator(viewModel: AccountViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceiveCollator(viewModel: AccountViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveCollator(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveTitle(viewModel: LocalizableResource<String>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveTitle(viewModel: LocalizableResource<String>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveTitle(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)  {
        
    return cuckoo_manager.call(
    """
    didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceiveHints(viewModel: viewModel))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_StakingUnbondSetupViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingUnbondSetupViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStakingUnbondSetupViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStakingUnbondSetupViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<AssetBalanceViewModelProtocol>)> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupViewProtocol.self, method:
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<NetworkFeeFooterViewModelProtocol>?)> where M1.OptionalMatchedType == LocalizableResource<NetworkFeeFooterViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<NetworkFeeFooterViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupViewProtocol.self, method:
    """
    didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<IAmountInputViewModel>)> where M1.MatchedType == LocalizableResource<IAmountInputViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<IAmountInputViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupViewProtocol.self, method:
    """
    didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveBonding<M1: Cuckoo.Matchable>(duration: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<TitleWithSubtitleViewModel>)> where M1.MatchedType == LocalizableResource<TitleWithSubtitleViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<TitleWithSubtitleViewModel>)>] = [wrap(matchable: duration) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupViewProtocol.self, method:
    """
    didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveAccount<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountViewModel)> where M1.MatchedType == AccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupViewProtocol.self, method:
    """
    didReceiveAccount(viewModel: AccountViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveCollator<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(AccountViewModel)> where M1.MatchedType == AccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupViewProtocol.self, method:
    """
    didReceiveCollator(viewModel: AccountViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveTitle<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<String>)> where M1.MatchedType == LocalizableResource<String> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<String>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupViewProtocol.self, method:
    """
    didReceiveTitle(viewModel: LocalizableResource<String>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didReceiveHints<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(LocalizableResource<[TitleIconViewModel]>)> where M1.MatchedType == LocalizableResource<[TitleIconViewModel]> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<[TitleIconViewModel]>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupViewProtocol.self, method:
    """
    didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondSetupViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceiveAsset<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<AssetBalanceViewModelProtocol>), Void> where M1.MatchedType == LocalizableResource<AssetBalanceViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<AssetBalanceViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveFee<M1: Cuckoo.OptionalMatchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<NetworkFeeFooterViewModelProtocol>?), Void> where M1.OptionalMatchedType == LocalizableResource<NetworkFeeFooterViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<NetworkFeeFooterViewModelProtocol>?)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveInput<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<IAmountInputViewModel>), Void> where M1.MatchedType == LocalizableResource<IAmountInputViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<IAmountInputViewModel>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveBonding<M1: Cuckoo.Matchable>(duration: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<TitleWithSubtitleViewModel>), Void> where M1.MatchedType == LocalizableResource<TitleWithSubtitleViewModel> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<TitleWithSubtitleViewModel>)>] = [wrap(matchable: duration) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveAccount<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(AccountViewModel), Void> where M1.MatchedType == AccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveAccount(viewModel: AccountViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveCollator<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(AccountViewModel), Void> where M1.MatchedType == AccountViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(AccountViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveCollator(viewModel: AccountViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveTitle<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<String>), Void> where M1.MatchedType == LocalizableResource<String> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<String>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveTitle(viewModel: LocalizableResource<String>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didReceiveHints<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(LocalizableResource<[TitleIconViewModel]>), Void> where M1.MatchedType == LocalizableResource<[TitleIconViewModel]> {
            let matchers: [Cuckoo.ParameterMatcher<(LocalizableResource<[TitleIconViewModel]>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondSetupViewProtocolStub: StakingUnbondSetupViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didReceiveAsset(viewModel: LocalizableResource<AssetBalanceViewModelProtocol>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveFee(viewModel: LocalizableResource<NetworkFeeFooterViewModelProtocol>?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveInput(viewModel: LocalizableResource<IAmountInputViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveBonding(duration: LocalizableResource<TitleWithSubtitleViewModel>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveAccount(viewModel: AccountViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveCollator(viewModel: AccountViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveTitle(viewModel: LocalizableResource<String>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didReceiveHints(viewModel: LocalizableResource<[TitleIconViewModel]>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingUnbondSetupPresenterProtocol: StakingUnbondSetupPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondSetupPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondSetupPresenterProtocol
     typealias Verification = __VerificationProxy_StakingUnbondSetupPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondSetupPresenterProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondSetupPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)  {
        
    return cuckoo_manager.call(
    """
    selectAmountPercentage(_: Float)
    """,
            parameters: (percentage),
            escapingParameters: (percentage),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.selectAmountPercentage(percentage))
        
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)  {
        
    return cuckoo_manager.call(
    """
    updateAmount(_: Decimal)
    """,
            parameters: (newValue),
            escapingParameters: (newValue),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.updateAmount(newValue))
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    
    
    
    
     func close()  {
        
    return cuckoo_manager.call(
    """
    close()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close())
        
    }
    
    
    
    
    
     func didTapBackButton()  {
        
    return cuckoo_manager.call(
    """
    didTapBackButton()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didTapBackButton())
        
    }
    
    

     struct __StubbingProxy_StakingUnbondSetupPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Float)> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupPresenterProtocol.self, method:
    """
    selectAmountPercentage(_: Float)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Decimal)> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupPresenterProtocol.self, method:
    """
    updateAmount(_: Decimal)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func close() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupPresenterProtocol.self, method:
    """
    close()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didTapBackButton() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupPresenterProtocol.self, method:
    """
    didTapBackButton()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondSetupPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func selectAmountPercentage<M1: Cuckoo.Matchable>(_ percentage: M1) -> Cuckoo.__DoNotUse<(Float), Void> where M1.MatchedType == Float {
            let matchers: [Cuckoo.ParameterMatcher<(Float)>] = [wrap(matchable: percentage) { $0 }]
            return cuckoo_manager.verify(
    """
    selectAmountPercentage(_: Float)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func updateAmount<M1: Cuckoo.Matchable>(_ newValue: M1) -> Cuckoo.__DoNotUse<(Decimal), Void> where M1.MatchedType == Decimal {
            let matchers: [Cuckoo.ParameterMatcher<(Decimal)>] = [wrap(matchable: newValue) { $0 }]
            return cuckoo_manager.verify(
    """
    updateAmount(_: Decimal)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func close() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    close()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didTapBackButton() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    didTapBackButton()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondSetupPresenterProtocolStub: StakingUnbondSetupPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func selectAmountPercentage(_ percentage: Float)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func updateAmount(_ newValue: Decimal)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func close()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didTapBackButton()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingUnbondSetupInteractorInputProtocol: StakingUnbondSetupInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondSetupInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondSetupInteractorInputProtocol
     typealias Verification = __VerificationProxy_StakingUnbondSetupInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondSetupInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondSetupInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?)  {
        
    return cuckoo_manager.call(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?)
    """,
            parameters: (builderClosure),
            escapingParameters: (builderClosure),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.estimateFee(builderClosure: builderClosure))
        
    }
    
    

     struct __StubbingProxy_StakingUnbondSetupInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func estimateFee<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(ExtrinsicBuilderClosure?)> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupInteractorInputProtocol.self, method:
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondSetupInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func estimateFee<M1: Cuckoo.OptionalMatchable>(builderClosure: M1) -> Cuckoo.__DoNotUse<(ExtrinsicBuilderClosure?), Void> where M1.OptionalMatchedType == ExtrinsicBuilderClosure {
            let matchers: [Cuckoo.ParameterMatcher<(ExtrinsicBuilderClosure?)>] = [wrap(matchable: builderClosure) { $0 }]
            return cuckoo_manager.verify(
    """
    estimateFee(builderClosure: ExtrinsicBuilderClosure?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondSetupInteractorInputProtocolStub: StakingUnbondSetupInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func estimateFee(builderClosure: ExtrinsicBuilderClosure?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingUnbondSetupInteractorOutputProtocol: StakingUnbondSetupInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondSetupInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondSetupInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StakingUnbondSetupInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondSetupInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondSetupInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)  {
        
    return cuckoo_manager.call(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """,
            parameters: (result),
            escapingParameters: (result),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceivePriceData(result: result))
        
    }
    
    

     struct __StubbingProxy_StakingUnbondSetupInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Result<PriceData?, Error>)> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupInteractorOutputProtocol.self, method:
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondSetupInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceivePriceData<M1: Cuckoo.Matchable>(result: M1) -> Cuckoo.__DoNotUse<(Result<PriceData?, Error>), Void> where M1.MatchedType == Result<PriceData?, Error> {
            let matchers: [Cuckoo.ParameterMatcher<(Result<PriceData?, Error>)>] = [wrap(matchable: result) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceivePriceData(result: Result<PriceData?, Error>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondSetupInteractorOutputProtocolStub: StakingUnbondSetupInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceivePriceData(result: Result<PriceData?, Error>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStakingUnbondSetupWireframeProtocol: StakingUnbondSetupWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StakingUnbondSetupWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StakingUnbondSetupWireframeProtocol
     typealias Verification = __VerificationProxy_StakingUnbondSetupWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StakingUnbondSetupWireframeProtocol?

     func enableDefaultImplementation(_ stub: StakingUnbondSetupWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func close(view: StakingUnbondSetupViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(view: StakingUnbondSetupViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view: view))
        
    }
    
    
    
    
    
     func proceed(view: StakingUnbondSetupViewProtocol?, flow: StakingUnbondConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)  {
        
    return cuckoo_manager.call(
    """
    proceed(view: StakingUnbondSetupViewProtocol?, flow: StakingUnbondConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """,
            parameters: (view, flow, chainAsset, wallet),
            escapingParameters: (view, flow, chainAsset, wallet),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(view: view, flow: flow, chainAsset: chainAsset, wallet: wallet))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    

     struct __StubbingProxy_StakingUnbondSetupWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingUnbondSetupViewProtocol?)> where M1.OptionalMatchedType == StakingUnbondSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingUnbondSetupViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupWireframeProtocol.self, method:
    """
    close(view: StakingUnbondSetupViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.ProtocolStubNoReturnFunction<(StakingUnbondSetupViewProtocol?, StakingUnbondConfirmFlow, ChainAsset, MetaAccountModel)> where M1.OptionalMatchedType == StakingUnbondSetupViewProtocol, M2.MatchedType == StakingUnbondConfirmFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingUnbondSetupViewProtocol?, StakingUnbondConfirmFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupWireframeProtocol.self, method:
    """
    proceed(view: StakingUnbondSetupViewProtocol?, flow: StakingUnbondConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStakingUnbondSetupWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StakingUnbondSetupWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(StakingUnbondSetupViewProtocol?), Void> where M1.OptionalMatchedType == StakingUnbondSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StakingUnbondSetupViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(view: StakingUnbondSetupViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable, M4: Cuckoo.Matchable>(view: M1, flow: M2, chainAsset: M3, wallet: M4) -> Cuckoo.__DoNotUse<(StakingUnbondSetupViewProtocol?, StakingUnbondConfirmFlow, ChainAsset, MetaAccountModel), Void> where M1.OptionalMatchedType == StakingUnbondSetupViewProtocol, M2.MatchedType == StakingUnbondConfirmFlow, M3.MatchedType == ChainAsset, M4.MatchedType == MetaAccountModel {
            let matchers: [Cuckoo.ParameterMatcher<(StakingUnbondSetupViewProtocol?, StakingUnbondConfirmFlow, ChainAsset, MetaAccountModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: chainAsset) { $0.2 }, wrap(matchable: wallet) { $0.3 }]
            return cuckoo_manager.verify(
    """
    proceed(view: StakingUnbondSetupViewProtocol?, flow: StakingUnbondConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StakingUnbondSetupWireframeProtocolStub: StakingUnbondSetupWireframeProtocol {
    

    

    
    
    
    
     func close(view: StakingUnbondSetupViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed(view: StakingUnbondSetupViewProtocol?, flow: StakingUnbondConfirmFlow, chainAsset: ChainAsset, wallet: MetaAccountModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import Foundation
import SoraFoundation






 class MockStoriesViewProtocol: StoriesViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StoriesViewProtocol
    
     typealias Stubbing = __StubbingProxy_StoriesViewProtocol
     typealias Verification = __VerificationProxy_StoriesViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StoriesViewProtocol?

     func enableDefaultImplementation(_ stub: StoriesViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return cuckoo_manager.getter("localizationManager",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager)
        }
        
        set {
            cuckoo_manager.setter("localizationManager",
                value: newValue,
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.localizationManager = newValue)
        }
        
    }
    
    

    

    
    
    
    
     func didRecieve(viewModel: [SlideViewModel], startingFrom slide: StaringIndex)  {
        
    return cuckoo_manager.call(
    """
    didRecieve(viewModel: [SlideViewModel], startingFrom: StaringIndex)
    """,
            parameters: (viewModel, slide),
            escapingParameters: (viewModel, slide),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRecieve(viewModel: viewModel, startingFrom: slide))
        
    }
    
    
    
    
    
     func didRecieve(newSlideIndex index: Int)  {
        
    return cuckoo_manager.call(
    """
    didRecieve(newSlideIndex: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didRecieve(newSlideIndex: index))
        
    }
    
    
    
    
    
    public func applyLocalization()  {
        
    return cuckoo_manager.call(
    """
    applyLocalization()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.applyLocalization())
        
    }
    
    

     struct __StubbingProxy_StoriesViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStoriesViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockStoriesViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        var localizationManager: Cuckoo.ProtocolToBeStubbedOptionalProperty<MockStoriesViewProtocol, LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager")
        }
        
        
        
        
        
        func didRecieve<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(viewModel: M1, startingFrom slide: M2) -> Cuckoo.ProtocolStubNoReturnFunction<([SlideViewModel], StaringIndex)> where M1.MatchedType == [SlideViewModel], M2.MatchedType == StaringIndex {
            let matchers: [Cuckoo.ParameterMatcher<([SlideViewModel], StaringIndex)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: slide) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesViewProtocol.self, method:
    """
    didRecieve(viewModel: [SlideViewModel], startingFrom: StaringIndex)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didRecieve<M1: Cuckoo.Matchable>(newSlideIndex index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesViewProtocol.self, method:
    """
    didRecieve(newSlideIndex: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func applyLocalization() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesViewProtocol.self, method:
    """
    applyLocalization()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StoriesViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var localizationManager: Cuckoo.VerifyOptionalProperty<LocalizationManagerProtocol> {
            return .init(manager: cuckoo_manager, name: "localizationManager", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didRecieve<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable>(viewModel: M1, startingFrom slide: M2) -> Cuckoo.__DoNotUse<([SlideViewModel], StaringIndex), Void> where M1.MatchedType == [SlideViewModel], M2.MatchedType == StaringIndex {
            let matchers: [Cuckoo.ParameterMatcher<([SlideViewModel], StaringIndex)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: slide) { $0.1 }]
            return cuckoo_manager.verify(
    """
    didRecieve(viewModel: [SlideViewModel], startingFrom: StaringIndex)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didRecieve<M1: Cuckoo.Matchable>(newSlideIndex index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    didRecieve(newSlideIndex: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func applyLocalization() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    applyLocalization()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StoriesViewProtocolStub: StoriesViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    
    
    
    
    public var localizationManager: LocalizationManagerProtocol? {
        get {
            return DefaultValueRegistry.defaultValue(for: (LocalizationManagerProtocol?).self)
        }
        
        set { }
        
    }
    
    

    

    
    
    
    
     func didRecieve(viewModel: [SlideViewModel], startingFrom slide: StaringIndex)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didRecieve(newSlideIndex index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
    public func applyLocalization()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStoriesPresenterProtocol: StoriesPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StoriesPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_StoriesPresenterProtocol
     typealias Verification = __VerificationProxy_StoriesPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StoriesPresenterProtocol?

     func enableDefaultImplementation(_ stub: StoriesPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func activateClose()  {
        
    return cuckoo_manager.call(
    """
    activateClose()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateClose())
        
    }
    
    
    
    
    
     func activateWeb()  {
        
    return cuckoo_manager.call(
    """
    activateWeb()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.activateWeb())
        
    }
    
    
    
    
    
     func proceedToNextStory()  {
        
    return cuckoo_manager.call(
    """
    proceedToNextStory()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceedToNextStory())
        
    }
    
    
    
    
    
     func proceedToPreviousStory(startingFrom slide: StaringIndex)  {
        
    return cuckoo_manager.call(
    """
    proceedToPreviousStory(startingFrom: StaringIndex)
    """,
            parameters: (slide),
            escapingParameters: (slide),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceedToPreviousStory(startingFrom: slide))
        
    }
    
    
    
    
    
     func proceedToNextSlide()  {
        
    return cuckoo_manager.call(
    """
    proceedToNextSlide()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceedToNextSlide())
        
    }
    
    
    
    
    
     func proceedToPreviousSlide()  {
        
    return cuckoo_manager.call(
    """
    proceedToPreviousSlide()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceedToPreviousSlide())
        
    }
    
    

     struct __StubbingProxy_StoriesPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateClose() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesPresenterProtocol.self, method:
    """
    activateClose()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func activateWeb() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesPresenterProtocol.self, method:
    """
    activateWeb()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceedToNextStory() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesPresenterProtocol.self, method:
    """
    proceedToNextStory()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceedToPreviousStory<M1: Cuckoo.Matchable>(startingFrom slide: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StaringIndex)> where M1.MatchedType == StaringIndex {
            let matchers: [Cuckoo.ParameterMatcher<(StaringIndex)>] = [wrap(matchable: slide) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesPresenterProtocol.self, method:
    """
    proceedToPreviousStory(startingFrom: StaringIndex)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceedToNextSlide() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesPresenterProtocol.self, method:
    """
    proceedToNextSlide()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceedToPreviousSlide() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesPresenterProtocol.self, method:
    """
    proceedToPreviousSlide()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StoriesPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateClose() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateClose()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func activateWeb() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    activateWeb()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceedToNextStory() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceedToNextStory()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceedToPreviousStory<M1: Cuckoo.Matchable>(startingFrom slide: M1) -> Cuckoo.__DoNotUse<(StaringIndex), Void> where M1.MatchedType == StaringIndex {
            let matchers: [Cuckoo.ParameterMatcher<(StaringIndex)>] = [wrap(matchable: slide) { $0 }]
            return cuckoo_manager.verify(
    """
    proceedToPreviousStory(startingFrom: StaringIndex)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceedToNextSlide() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceedToNextSlide()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceedToPreviousSlide() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceedToPreviousSlide()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StoriesPresenterProtocolStub: StoriesPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateClose()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func activateWeb()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceedToNextStory()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceedToPreviousStory(startingFrom slide: StaringIndex)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceedToNextSlide()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceedToPreviousSlide()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStoriesInteractorInputProtocol: StoriesInteractorInputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StoriesInteractorInputProtocol
    
     typealias Stubbing = __StubbingProxy_StoriesInteractorInputProtocol
     typealias Verification = __VerificationProxy_StoriesInteractorInputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StoriesInteractorInputProtocol?

     func enableDefaultImplementation(_ stub: StoriesInteractorInputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    

     struct __StubbingProxy_StoriesInteractorInputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesInteractorInputProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StoriesInteractorInputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StoriesInteractorInputProtocolStub: StoriesInteractorInputProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStoriesInteractorOutputProtocol: StoriesInteractorOutputProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StoriesInteractorOutputProtocol
    
     typealias Stubbing = __StubbingProxy_StoriesInteractorOutputProtocol
     typealias Verification = __VerificationProxy_StoriesInteractorOutputProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StoriesInteractorOutputProtocol?

     func enableDefaultImplementation(_ stub: StoriesInteractorOutputProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didReceive(storiesModel: StoriesModel)  {
        
    return cuckoo_manager.call(
    """
    didReceive(storiesModel: StoriesModel)
    """,
            parameters: (storiesModel),
            escapingParameters: (storiesModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(storiesModel: storiesModel))
        
    }
    
    

     struct __StubbingProxy_StoriesInteractorOutputProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(storiesModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StoriesModel)> where M1.MatchedType == StoriesModel {
            let matchers: [Cuckoo.ParameterMatcher<(StoriesModel)>] = [wrap(matchable: storiesModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesInteractorOutputProtocol.self, method:
    """
    didReceive(storiesModel: StoriesModel)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StoriesInteractorOutputProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(storiesModel: M1) -> Cuckoo.__DoNotUse<(StoriesModel), Void> where M1.MatchedType == StoriesModel {
            let matchers: [Cuckoo.ParameterMatcher<(StoriesModel)>] = [wrap(matchable: storiesModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(storiesModel: StoriesModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StoriesInteractorOutputProtocolStub: StoriesInteractorOutputProtocol {
    

    

    
    
    
    
     func didReceive(storiesModel: StoriesModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockStoriesWireframeProtocol: StoriesWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = StoriesWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_StoriesWireframeProtocol
     typealias Verification = __VerificationProxy_StoriesWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: StoriesWireframeProtocol?

     func enableDefaultImplementation(_ stub: StoriesWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func close(view: StoriesViewProtocol?)  {
        
    return cuckoo_manager.call(
    """
    close(view: StoriesViewProtocol?)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.close(view: view))
        
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)  {
        
    return cuckoo_manager.call(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """,
            parameters: (url, view, style),
            escapingParameters: (url, view, style),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.showWeb(url: url, from: view, style: style))
        
    }
    
    

     struct __StubbingProxy_StoriesWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(StoriesViewProtocol?)> where M1.OptionalMatchedType == StoriesViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StoriesViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesWireframeProtocol.self, method:
    """
    close(view: StoriesViewProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(URL, ControllerBackedProtocol, WebPresentableStyle)> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockStoriesWireframeProtocol.self, method:
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_StoriesWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func close<M1: Cuckoo.OptionalMatchable>(view: M1) -> Cuckoo.__DoNotUse<(StoriesViewProtocol?), Void> where M1.OptionalMatchedType == StoriesViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(StoriesViewProtocol?)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    close(view: StoriesViewProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func showWeb<M1: Cuckoo.Matchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(url: M1, from view: M2, style: M3) -> Cuckoo.__DoNotUse<(URL, ControllerBackedProtocol, WebPresentableStyle), Void> where M1.MatchedType == URL, M2.MatchedType == ControllerBackedProtocol, M3.MatchedType == WebPresentableStyle {
            let matchers: [Cuckoo.ParameterMatcher<(URL, ControllerBackedProtocol, WebPresentableStyle)>] = [wrap(matchable: url) { $0.0 }, wrap(matchable: view) { $0.1 }, wrap(matchable: style) { $0.2 }]
            return cuckoo_manager.verify(
    """
    showWeb(url: URL, from: ControllerBackedProtocol, style: WebPresentableStyle)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class StoriesWireframeProtocolStub: StoriesWireframeProtocol {
    

    

    
    
    
    
     func close(view: StoriesViewProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func showWeb(url: URL, from view: ControllerBackedProtocol, style: WebPresentableStyle)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import SoraFoundation






 class MockUsernameSetupViewProtocol: UsernameSetupViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = UsernameSetupViewProtocol
    
     typealias Stubbing = __StubbingProxy_UsernameSetupViewProtocol
     typealias Verification = __VerificationProxy_UsernameSetupViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: UsernameSetupViewProtocol?

     func enableDefaultImplementation(_ stub: UsernameSetupViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func bindUsername(viewModel: SelectableViewModel<InputViewModelProtocol>)  {
        
    return cuckoo_manager.call(
    """
    bindUsername(viewModel: SelectableViewModel<InputViewModelProtocol>)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.bindUsername(viewModel: viewModel))
        
    }
    
    
    
    
    
     func bindUniqueChain(viewModel: UniqueChainViewModel)  {
        
    return cuckoo_manager.call(
    """
    bindUniqueChain(viewModel: UniqueChainViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.bindUniqueChain(viewModel: viewModel))
        
    }
    
    

     struct __StubbingProxy_UsernameSetupViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockUsernameSetupViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockUsernameSetupViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func bindUsername<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(SelectableViewModel<InputViewModelProtocol>)> where M1.MatchedType == SelectableViewModel<InputViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(SelectableViewModel<InputViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockUsernameSetupViewProtocol.self, method:
    """
    bindUsername(viewModel: SelectableViewModel<InputViewModelProtocol>)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func bindUniqueChain<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UniqueChainViewModel)> where M1.MatchedType == UniqueChainViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(UniqueChainViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockUsernameSetupViewProtocol.self, method:
    """
    bindUniqueChain(viewModel: UniqueChainViewModel)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_UsernameSetupViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func bindUsername<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(SelectableViewModel<InputViewModelProtocol>), Void> where M1.MatchedType == SelectableViewModel<InputViewModelProtocol> {
            let matchers: [Cuckoo.ParameterMatcher<(SelectableViewModel<InputViewModelProtocol>)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    bindUsername(viewModel: SelectableViewModel<InputViewModelProtocol>)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func bindUniqueChain<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(UniqueChainViewModel), Void> where M1.MatchedType == UniqueChainViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(UniqueChainViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    bindUniqueChain(viewModel: UniqueChainViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class UsernameSetupViewProtocolStub: UsernameSetupViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func bindUsername(viewModel: SelectableViewModel<InputViewModelProtocol>)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func bindUniqueChain(viewModel: UniqueChainViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockUsernameSetupPresenterProtocol: UsernameSetupPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = UsernameSetupPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_UsernameSetupPresenterProtocol
     typealias Verification = __VerificationProxy_UsernameSetupPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: UsernameSetupPresenterProtocol?

     func enableDefaultImplementation(_ stub: UsernameSetupPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func didLoad(view: UsernameSetupViewProtocol)  {
        
    return cuckoo_manager.call(
    """
    didLoad(view: UsernameSetupViewProtocol)
    """,
            parameters: (view),
            escapingParameters: (view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didLoad(view: view))
        
    }
    
    
    
    
    
     func proceed()  {
        
    return cuckoo_manager.call(
    """
    proceed()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed())
        
    }
    
    

     struct __StubbingProxy_UsernameSetupPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(UsernameSetupViewProtocol)> where M1.MatchedType == UsernameSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(UsernameSetupViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockUsernameSetupPresenterProtocol.self, method:
    """
    didLoad(view: UsernameSetupViewProtocol)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func proceed() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockUsernameSetupPresenterProtocol.self, method:
    """
    proceed()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_UsernameSetupPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func didLoad<M1: Cuckoo.Matchable>(view: M1) -> Cuckoo.__DoNotUse<(UsernameSetupViewProtocol), Void> where M1.MatchedType == UsernameSetupViewProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(UsernameSetupViewProtocol)>] = [wrap(matchable: view) { $0 }]
            return cuckoo_manager.verify(
    """
    didLoad(view: UsernameSetupViewProtocol)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func proceed() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    proceed()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class UsernameSetupPresenterProtocolStub: UsernameSetupPresenterProtocol {
    

    

    
    
    
    
     func didLoad(view: UsernameSetupViewProtocol)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func proceed()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockUsernameSetupWireframeProtocol: UsernameSetupWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = UsernameSetupWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_UsernameSetupWireframeProtocol
     typealias Verification = __VerificationProxy_UsernameSetupWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: UsernameSetupWireframeProtocol?

     func enableDefaultImplementation(_ stub: UsernameSetupWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func proceed(from view: UsernameSetupViewProtocol?, flow: AccountCreateFlow, model: UsernameSetupModel)  {
        
    return cuckoo_manager.call(
    """
    proceed(from: UsernameSetupViewProtocol?, flow: AccountCreateFlow, model: UsernameSetupModel)
    """,
            parameters: (view, flow, model),
            escapingParameters: (view, flow, model),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(from: view, flow: flow, model: model))
        
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """,
            parameters: (viewModel, view),
            escapingParameters: (viewModel, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(viewModel: viewModel, from: view))
        
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])  {
        
    return cuckoo_manager.call(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """,
            parameters: (message, title, closeAction, view, actions),
            escapingParameters: (message, title, closeAction, view, actions),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.present(message: message, title: title, closeAction: closeAction, from: view, actions: actions))
        
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)  {
        
    return cuckoo_manager.call(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """,
            parameters: (message, title, view),
            escapingParameters: (message, title, view),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.presentInfo(message: message, title: title, from: view))
        
    }
    
    

     struct __StubbingProxy_UsernameSetupWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, flow: M2, model: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(UsernameSetupViewProtocol?, AccountCreateFlow, UsernameSetupModel)> where M1.OptionalMatchedType == UsernameSetupViewProtocol, M2.MatchedType == AccountCreateFlow, M3.MatchedType == UsernameSetupModel {
            let matchers: [Cuckoo.ParameterMatcher<(UsernameSetupViewProtocol?, AccountCreateFlow, UsernameSetupModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: model) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockUsernameSetupWireframeProtocol.self, method:
    """
    proceed(from: UsernameSetupViewProtocol?, flow: AccountCreateFlow, model: UsernameSetupModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockUsernameSetupWireframeProtocol.self, method:
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return .init(stub: cuckoo_manager.createStub(for: MockUsernameSetupWireframeProtocol.self, method:
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.ProtocolStubNoReturnFunction<(String?, String, ControllerBackedProtocol?)> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return .init(stub: cuckoo_manager.createStub(for: MockUsernameSetupWireframeProtocol.self, method:
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_UsernameSetupWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.Matchable>(from view: M1, flow: M2, model: M3) -> Cuckoo.__DoNotUse<(UsernameSetupViewProtocol?, AccountCreateFlow, UsernameSetupModel), Void> where M1.OptionalMatchedType == UsernameSetupViewProtocol, M2.MatchedType == AccountCreateFlow, M3.MatchedType == UsernameSetupModel {
            let matchers: [Cuckoo.ParameterMatcher<(UsernameSetupViewProtocol?, AccountCreateFlow, UsernameSetupModel)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: flow) { $0.1 }, wrap(matchable: model) { $0.2 }]
            return cuckoo_manager.verify(
    """
    proceed(from: UsernameSetupViewProtocol?, flow: AccountCreateFlow, model: UsernameSetupModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.Matchable, M2: Cuckoo.OptionalMatchable>(viewModel: M1, from view: M2) -> Cuckoo.__DoNotUse<(SheetAlertPresentableViewModel, ControllerBackedProtocol?), Void> where M1.MatchedType == SheetAlertPresentableViewModel, M2.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(SheetAlertPresentableViewModel, ControllerBackedProtocol?)>] = [wrap(matchable: viewModel) { $0.0 }, wrap(matchable: view) { $0.1 }]
            return cuckoo_manager.verify(
    """
    present(viewModel: SheetAlertPresentableViewModel, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func present<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable, M4: Cuckoo.OptionalMatchable, M5: Cuckoo.Matchable>(message: M1, title: M2, closeAction: M3, from view: M4, actions: M5) -> Cuckoo.__DoNotUse<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction]), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == String, M4.OptionalMatchedType == ControllerBackedProtocol, M5.MatchedType == [SheetAlertPresentableAction] {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, String?, ControllerBackedProtocol?, [SheetAlertPresentableAction])>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: closeAction) { $0.2 }, wrap(matchable: view) { $0.3 }, wrap(matchable: actions) { $0.4 }]
            return cuckoo_manager.verify(
    """
    present(message: String?, title: String, closeAction: String?, from: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func presentInfo<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable, M3: Cuckoo.OptionalMatchable>(message: M1, title: M2, from view: M3) -> Cuckoo.__DoNotUse<(String?, String, ControllerBackedProtocol?), Void> where M1.OptionalMatchedType == String, M2.MatchedType == String, M3.OptionalMatchedType == ControllerBackedProtocol {
            let matchers: [Cuckoo.ParameterMatcher<(String?, String, ControllerBackedProtocol?)>] = [wrap(matchable: message) { $0.0 }, wrap(matchable: title) { $0.1 }, wrap(matchable: view) { $0.2 }]
            return cuckoo_manager.verify(
    """
    presentInfo(message: String?, title: String, from: ControllerBackedProtocol?)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class UsernameSetupWireframeProtocolStub: UsernameSetupWireframeProtocol {
    

    

    
    
    
    
     func proceed(from view: UsernameSetupViewProtocol?, flow: AccountCreateFlow, model: UsernameSetupModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(viewModel: SheetAlertPresentableViewModel, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func present(message: String?, title: String, closeAction: String?, from view: ControllerBackedProtocol?, actions: [SheetAlertPresentableAction])   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func presentInfo(message: String?, title: String, from view: ControllerBackedProtocol?)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}





import Cuckoo
@testable import fearless

import CommonWallet






 class MockWalletHistoryFilterViewProtocol: WalletHistoryFilterViewProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = WalletHistoryFilterViewProtocol
    
     typealias Stubbing = __StubbingProxy_WalletHistoryFilterViewProtocol
     typealias Verification = __VerificationProxy_WalletHistoryFilterViewProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: WalletHistoryFilterViewProtocol?

     func enableDefaultImplementation(_ stub: WalletHistoryFilterViewProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    
    
    
    
     var isSetup: Bool {
        get {
            return cuckoo_manager.getter("isSetup",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.isSetup)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return cuckoo_manager.getter("controller",
                superclassCall:
                    
                    Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                    ,
                defaultCall: __defaultImplStub!.controller)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(viewModel: WalletHistoryFilterViewModel)  {
        
    return cuckoo_manager.call(
    """
    didReceive(viewModel: WalletHistoryFilterViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didReceive(viewModel: viewModel))
        
    }
    
    
    
    
    
     func didConfirm(viewModel: WalletHistoryFilterViewModel)  {
        
    return cuckoo_manager.call(
    """
    didConfirm(viewModel: WalletHistoryFilterViewModel)
    """,
            parameters: (viewModel),
            escapingParameters: (viewModel),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.didConfirm(viewModel: viewModel))
        
    }
    
    

     struct __StubbingProxy_WalletHistoryFilterViewProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        var isSetup: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockWalletHistoryFilterViewProtocol, Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup")
        }
        
        
        
        
        var controller: Cuckoo.ProtocolToBeStubbedReadOnlyProperty<MockWalletHistoryFilterViewProtocol, UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller")
        }
        
        
        
        
        
        func didReceive<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(WalletHistoryFilterViewModel)> where M1.MatchedType == WalletHistoryFilterViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(WalletHistoryFilterViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockWalletHistoryFilterViewProtocol.self, method:
    """
    didReceive(viewModel: WalletHistoryFilterViewModel)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func didConfirm<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(WalletHistoryFilterViewModel)> where M1.MatchedType == WalletHistoryFilterViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(WalletHistoryFilterViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockWalletHistoryFilterViewProtocol.self, method:
    """
    didConfirm(viewModel: WalletHistoryFilterViewModel)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_WalletHistoryFilterViewProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
        
        
        var isSetup: Cuckoo.VerifyReadOnlyProperty<Bool> {
            return .init(manager: cuckoo_manager, name: "isSetup", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
        
        
        var controller: Cuckoo.VerifyReadOnlyProperty<UIViewController> {
            return .init(manager: cuckoo_manager, name: "controller", callMatcher: callMatcher, sourceLocation: sourceLocation)
        }
        
        
    
        
        
        
        @discardableResult
        func didReceive<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(WalletHistoryFilterViewModel), Void> where M1.MatchedType == WalletHistoryFilterViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(WalletHistoryFilterViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didReceive(viewModel: WalletHistoryFilterViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func didConfirm<M1: Cuckoo.Matchable>(viewModel: M1) -> Cuckoo.__DoNotUse<(WalletHistoryFilterViewModel), Void> where M1.MatchedType == WalletHistoryFilterViewModel {
            let matchers: [Cuckoo.ParameterMatcher<(WalletHistoryFilterViewModel)>] = [wrap(matchable: viewModel) { $0 }]
            return cuckoo_manager.verify(
    """
    didConfirm(viewModel: WalletHistoryFilterViewModel)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class WalletHistoryFilterViewProtocolStub: WalletHistoryFilterViewProtocol {
    
    
    
    
     var isSetup: Bool {
        get {
            return DefaultValueRegistry.defaultValue(for: (Bool).self)
        }
        
    }
    
    
    
    
    
     var controller: UIViewController {
        get {
            return DefaultValueRegistry.defaultValue(for: (UIViewController).self)
        }
        
    }
    
    

    

    
    
    
    
     func didReceive(viewModel: WalletHistoryFilterViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func didConfirm(viewModel: WalletHistoryFilterViewModel)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockWalletHistoryFilterPresenterProtocol: WalletHistoryFilterPresenterProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = WalletHistoryFilterPresenterProtocol
    
     typealias Stubbing = __StubbingProxy_WalletHistoryFilterPresenterProtocol
     typealias Verification = __VerificationProxy_WalletHistoryFilterPresenterProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: WalletHistoryFilterPresenterProtocol?

     func enableDefaultImplementation(_ stub: WalletHistoryFilterPresenterProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func setup()  {
        
    return cuckoo_manager.call(
    """
    setup()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.setup())
        
    }
    
    
    
    
    
     func toggleFilterItem(at index: Int)  {
        
    return cuckoo_manager.call(
    """
    toggleFilterItem(at: Int)
    """,
            parameters: (index),
            escapingParameters: (index),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.toggleFilterItem(at: index))
        
    }
    
    
    
    
    
     func apply()  {
        
    return cuckoo_manager.call(
    """
    apply()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.apply())
        
    }
    
    
    
    
    
     func reset()  {
        
    return cuckoo_manager.call(
    """
    reset()
    """,
            parameters: (),
            escapingParameters: (),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.reset())
        
    }
    
    

     struct __StubbingProxy_WalletHistoryFilterPresenterProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func setup() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockWalletHistoryFilterPresenterProtocol.self, method:
    """
    setup()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func toggleFilterItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.ProtocolStubNoReturnFunction<(Int)> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return .init(stub: cuckoo_manager.createStub(for: MockWalletHistoryFilterPresenterProtocol.self, method:
    """
    toggleFilterItem(at: Int)
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func apply() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockWalletHistoryFilterPresenterProtocol.self, method:
    """
    apply()
    """, parameterMatchers: matchers))
        }
        
        
        
        
        func reset() -> Cuckoo.ProtocolStubNoReturnFunction<()> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return .init(stub: cuckoo_manager.createStub(for: MockWalletHistoryFilterPresenterProtocol.self, method:
    """
    reset()
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_WalletHistoryFilterPresenterProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func setup() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    setup()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func toggleFilterItem<M1: Cuckoo.Matchable>(at index: M1) -> Cuckoo.__DoNotUse<(Int), Void> where M1.MatchedType == Int {
            let matchers: [Cuckoo.ParameterMatcher<(Int)>] = [wrap(matchable: index) { $0 }]
            return cuckoo_manager.verify(
    """
    toggleFilterItem(at: Int)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func apply() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    apply()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
        
        
        @discardableResult
        func reset() -> Cuckoo.__DoNotUse<(), Void> {
            let matchers: [Cuckoo.ParameterMatcher<Void>] = []
            return cuckoo_manager.verify(
    """
    reset()
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class WalletHistoryFilterPresenterProtocolStub: WalletHistoryFilterPresenterProtocol {
    

    

    
    
    
    
     func setup()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func toggleFilterItem(at index: Int)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func apply()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
    
    
    
     func reset()   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}










 class MockWalletHistoryFilterWireframeProtocol: WalletHistoryFilterWireframeProtocol, Cuckoo.ProtocolMock {
    
     typealias MocksType = WalletHistoryFilterWireframeProtocol
    
     typealias Stubbing = __StubbingProxy_WalletHistoryFilterWireframeProtocol
     typealias Verification = __VerificationProxy_WalletHistoryFilterWireframeProtocol

     let cuckoo_manager = Cuckoo.MockManager.preconfiguredManager ?? Cuckoo.MockManager(hasParent: false)

    
    private var __defaultImplStub: WalletHistoryFilterWireframeProtocol?

     func enableDefaultImplementation(_ stub: WalletHistoryFilterWireframeProtocol) {
        __defaultImplStub = stub
        cuckoo_manager.enableDefaultStubImplementation()
    }
    

    

    

    
    
    
    
     func proceed(from view: WalletHistoryFilterViewProtocol?, applying filter: WalletHistoryFilter)  {
        
    return cuckoo_manager.call(
    """
    proceed(from: WalletHistoryFilterViewProtocol?, applying: WalletHistoryFilter)
    """,
            parameters: (view, filter),
            escapingParameters: (view, filter),
            superclassCall:
                
                Cuckoo.MockManager.crashOnProtocolSuperclassCall()
                ,
            defaultCall: __defaultImplStub!.proceed(from: view, applying: filter))
        
    }
    
    

     struct __StubbingProxy_WalletHistoryFilterWireframeProtocol: Cuckoo.StubbingProxy {
        private let cuckoo_manager: Cuckoo.MockManager
    
         init(manager: Cuckoo.MockManager) {
            self.cuckoo_manager = manager
        }
        
        
        
        
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, applying filter: M2) -> Cuckoo.ProtocolStubNoReturnFunction<(WalletHistoryFilterViewProtocol?, WalletHistoryFilter)> where M1.OptionalMatchedType == WalletHistoryFilterViewProtocol, M2.MatchedType == WalletHistoryFilter {
            let matchers: [Cuckoo.ParameterMatcher<(WalletHistoryFilterViewProtocol?, WalletHistoryFilter)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: filter) { $0.1 }]
            return .init(stub: cuckoo_manager.createStub(for: MockWalletHistoryFilterWireframeProtocol.self, method:
    """
    proceed(from: WalletHistoryFilterViewProtocol?, applying: WalletHistoryFilter)
    """, parameterMatchers: matchers))
        }
        
        
    }

     struct __VerificationProxy_WalletHistoryFilterWireframeProtocol: Cuckoo.VerificationProxy {
        private let cuckoo_manager: Cuckoo.MockManager
        private let callMatcher: Cuckoo.CallMatcher
        private let sourceLocation: Cuckoo.SourceLocation
    
         init(manager: Cuckoo.MockManager, callMatcher: Cuckoo.CallMatcher, sourceLocation: Cuckoo.SourceLocation) {
            self.cuckoo_manager = manager
            self.callMatcher = callMatcher
            self.sourceLocation = sourceLocation
        }
    
        
    
        
        
        
        @discardableResult
        func proceed<M1: Cuckoo.OptionalMatchable, M2: Cuckoo.Matchable>(from view: M1, applying filter: M2) -> Cuckoo.__DoNotUse<(WalletHistoryFilterViewProtocol?, WalletHistoryFilter), Void> where M1.OptionalMatchedType == WalletHistoryFilterViewProtocol, M2.MatchedType == WalletHistoryFilter {
            let matchers: [Cuckoo.ParameterMatcher<(WalletHistoryFilterViewProtocol?, WalletHistoryFilter)>] = [wrap(matchable: view) { $0.0 }, wrap(matchable: filter) { $0.1 }]
            return cuckoo_manager.verify(
    """
    proceed(from: WalletHistoryFilterViewProtocol?, applying: WalletHistoryFilter)
    """, callMatcher: callMatcher, parameterMatchers: matchers, sourceLocation: sourceLocation)
        }
        
        
    }
}


 class WalletHistoryFilterWireframeProtocolStub: WalletHistoryFilterWireframeProtocol {
    

    

    
    
    
    
     func proceed(from view: WalletHistoryFilterViewProtocol?, applying filter: WalletHistoryFilter)   {
        return DefaultValueRegistry.defaultValue(for: (Void).self)
    }
    
    
}




